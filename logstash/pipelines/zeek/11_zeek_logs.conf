######################## # zeek -> arkime session creation and enrichment
#
# see https://docs.zeek.org/en/stable/script-reference/log-files.html for Zeek logfile documentation
#
# see source.zeeklogs.js for the Arkime code that turns these into UI fields
#
# to profile, debug:
#   - get filters sorted by execution time (where in > 0)
#   $ docker-compose exec logstash curl -XGET http://localhost:9600/_node/stats/pipelines | jq -r '.. | .filters? // empty | .[] | objects | select (.events.in > 0) | [.id, .events.in, .events.out, .events.duration_in_millis] | join (";")' | sort -n -t ';' -k4
#   - get filters where in != out
#   $ docker-compose exec logstash curl -XGET http://localhost:9600/_node/stats/pipelines | jq -r '.. | .filters? // empty | .[] | objects | select (.events.in != .events.out) | [.id, .events.in, .events.out, .events.duration_in_millis] | join (";")'
#
# Copyright (c) 2022 Battelle Energy Alliance, LLC.  All rights reserved.
#######################

filter {

  if (([message] =~ /^\s*#/) or (![log][file][path])) {
    drop { id => "drop_zeek_invalid_logs" }
  }

  # tags may have been specified, like: conn(tagA,tagB,tagC).log, extract the log type (conn) and the tags (tagA,tagB,tagC)
  # also normalize log types with - in their names to _ (e.g., opcua-binary -> opcua_binary)
  ruby {
    id => "ruby_zeek_source_extract"
                                                                  #↓Type     ↓Tags
    code => "
      if fileParts = event.get('[log][file][path]').split('/').last.match(/^(.*?)(?:\((.*)\))?\.log/i) then
        logType, tags = fileParts.captures
        event.set('[log_source]', logType.gsub('-', '_')) unless logType.nil?
        event.set('[@metadata][zeek_log_tags]', tags) unless tags.nil?
      end"
  }

  # report types we're going to ignore
  if (([log_source] == "bsap_ip_unknown") or
      ([log_source] == "bsap_serial_unknown") or
      ([log_source] == "ecat_arp_info") or
      ([log_source] == "reporter") or
      ([log_source] == "broker") or
      ([log_source] == "cluster") or
      ([log_source] == "capture_loss") or
      ([log_source] == "communication") or
      ([log_source] == "packet_filter") or
      ([log_source] == "png") or
      ([log_source] == "stats") or
      ([log_source] == "stderr") or
      ([log_source] == "stdout") or
      ([log_source] == "loaded_scripts")) {
    drop { id => "drop_zeek_ignored_source" }
  }

  # remove some tags pulled from the filename we might not want
  if ([@metadata][zeek_log_tags]) {
    ruby {
      id => "ruby_zeek_prune_tags"
      code => "
        filenameTags = event.get('[@metadata][zeek_log_tags]').split(',')
        zeekFieldsTag = filenameTags.select { |str| str.start_with?('ZEEKFLDx') }
        if (zeekFieldsTag.size > 0) then
          zeekFieldsTags = zeekFieldsTag.first.split('x', 3)
          if (zeekFieldsTags.size == 3) then
            event.set('[@metadata][zeek_fields_bitmap_version]', zeekFieldsTags[1].to_i(16))
            event.set('[@metadata][zeek_fields_bitmap]', zeekFieldsTags[2].to_i(16))
          end
        end
        filenameTags.delete_if{|v| ((v == nil) or (v == '') or (v !~ /\D/) or (v =~ /\A\s*(ZEEKFLDx|autocarve)/i) or (v =~ /\A\s*(pcap|dmp|log|bro|zeek|suricata|m?tcpdump|m?netsniff|autozeek|autosuricata)s?\s*\z/i) or (v == event.get('[log_source]')))}
        event.set('[@metadata][zeek_log_tags]', filenameTags.uniq) unless (filenameTags.length == 0)
      "
      #
      #  ZEEKFLDx00x01FFFFFF
      #  |      |  └ bitmap of included fields within field list
      #  |      └ index into zeek-log-field-bitmap.py:ZEEK_LOG_FIELDS list indicating field configuration within differing Zeek versions
      #  └ indicates that the field list has been pre-processed by zeek-process-pcap.py
      #
      # when logstash-filter-dissect gets this implemented, we *may* not have to do this
      #   - see zeek-process-pcap.py for the format of the bitmap number
      #   - https://github.com/logstash-plugins/logstash-filter-dissect/issues/56
      #   - https://github.com/logstash-plugins/logstash-filter-dissect/issues/62
      #
      # todo: right now rather than using the bitmap intelligently to build the field list, I'm just looking for
      # known preconfigurations. look into doing it "smart".
      #
    }
    if ([@metadata][zeek_log_tags]) { mutate { id => "mutate_merge_zeek_log_tags"
                                                  merge => { "[tags]" => "[@metadata][zeek_log_tags]" } } }
  }

  # The Dissect is WAY faster than CSV, and quite a bit faster than mutate.split. However, it
  # is not as flexible when it comes to missing or extra columns
  # (See https://github.com/logstash-plugins/logstash-filter-dissect/issues/62)
  #
  # So, if the dissect filter fails, we're going to fall back to split-then-zip solution.
  # This should be a good tradeoff between performance (in the case where the Zeek logs
  # match what we think they should look like) and flexibility (when they don't).
  #
  # The one drawback is that if you make a change to the fields in dissect, make sure
  # you make the corresponding change in the ruby init code.

  if ([log_source] == "conn") {
    #############################################################################################################################
    # conn.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/conn/main.zeek.html#type-Conn::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap conn.log field configuration version 0
      #
      # Todo: I need to just bite the bullet and code this up in a Ruby block rather than hardcoding values.
      #
      # vlan + mac + community_id:  0x3ffffff / 67108863
      # vlan + mac:                 0x1ffffff / 33554431
      # mac + community_id:         0x39fffff / 60817407
      # mac only:                   0x19fffff / 27262975
      # vlan + community_id:        0x27fffff / 41943039
      # vlan only:                   0x7fffff /  8388607
      # community_id only:           0x1fffff /  2097151
      # no custom fields:

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 67108863) {
          # conn.log has vlans + macs + community_id
          dissect {
            id => "dissect_zeek_conn_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 33554431) {
          # conn.log has vlans + macs
          dissect {
            id => "dissect_zeek_conn_with_vlan_and_mac_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 60817407) {
          # conn.log has macs + community_id
          dissect {
            id => "dissect_zeek_conn_with_mac_and_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 27262975) {
          # conn.log has macs
          dissect {
            id => "dissect_zeek_conn_with_mac_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 41943039) {
          # conn.log has vlans + community_id
          dissect {
            id => "dissect_zeek_conn_with_vlan_and_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {
          # conn.log has vlans
          dissect {
            id => "dissect_zeek_conn_with_vlan_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {
          # conn.log has community_id
          dissect {
            id => "dissect_zeek_conn_with_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {
          # conn.log has no custom fields
          dissect {
            id => "dissect_zeek_conn_with_minimal_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}"
            }
          }

        } else {
          # who knows? the conn.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_conn_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the conn.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_conn_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the conn.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_conn_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_conn"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_conn"
        init => "$zeek_conn_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'service', 'duration', 'orig_bytes', 'resp_bytes', 'conn_state', 'local_orig', 'local_resp', 'missed_bytes', 'history', 'orig_pkts', 'orig_ip_bytes', 'resp_pkts', 'resp_ip_bytes', 'tunnel_parents', 'vlan', 'inner_vlan', 'orig_l2_addr', 'resp_l2_addr', 'community_id' ]"
        code => "event.set('[zeek_cols]', $zeek_conn_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    # normalize service string(s)

    # some services are named like blah_udp/blah_tcp/blah_data, and we don't care about the suffix
    mutate { id => "mutate_gsub_field_zeek_conn_service_protocol_suffix"
             gsub => [ "[zeek_cols][service]", "[_-](tcp|udp|data)", "" ] }

    if ([zeek_cols][service] =~ /spicy_/) {
      # if it's coming from spicy, we don't care to have that in the service name
      mutate { id => "mutate_gsub_field_zeek_conn_service_spicy_prefix"
               gsub => [ "[zeek_cols][service]", "spicy_", "" ] }

      mutate { id => "mutate_gsub_field_zeek_conn_service_spicy_cipher_suffix"
               gsub => [ "[zeek_cols][service]", "(_hmac)?(_(sha|md)\d+)?$", "" ] }
    }

    if ([zeek_cols][orig_ip_bytes]) and ([zeek_cols][orig_ip_bytes] != '-') and ([zeek_cols][orig_ip_bytes] != '(empty)') and ([zeek_cols][orig_ip_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_srcBytes"
               add_field => { "[source][bytes]" => "%{[zeek_cols][orig_ip_bytes]}" } }
    }
    if ([zeek_cols][resp_ip_bytes]) and ([zeek_cols][resp_ip_bytes] != '-') and ([zeek_cols][resp_ip_bytes] != '(empty)') and ([zeek_cols][resp_ip_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_dstBytes"
               add_field => { "[destination][bytes]" => "%{[zeek_cols][resp_ip_bytes]}" } }
    }
    if ([zeek_cols][orig_pkts]) and ([zeek_cols][orig_pkts] != '-') and ([zeek_cols][orig_pkts] != '(empty)') and ([zeek_cols][orig_pkts] != '') {
      mutate { id => "mutate_add_field_zeek_srcPackets"
               add_field => { "[source][packets]" => "%{[zeek_cols][orig_pkts]}" } }
    }
    if ([zeek_cols][orig_bytes]) and ([zeek_cols][orig_bytes] != '-') and ([zeek_cols][orig_bytes] != '(empty)') and ([zeek_cols][orig_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_srcDataBytes"
               add_field => { "[client][bytes]" => "%{[zeek_cols][orig_bytes]}" } }
    }
    if ([zeek_cols][resp_pkts]) and ([zeek_cols][resp_pkts] != '-') and ([zeek_cols][resp_pkts] != '(empty)') and ([zeek_cols][resp_pkts] != '') {
      mutate { id => "mutate_add_field_zeek_dstPackets"
               add_field => { "[destination][packets]" => "%{[zeek_cols][resp_pkts]}" } }
    }
    if ([zeek_cols][resp_bytes]) and ([zeek_cols][resp_bytes] != '-') and ([zeek_cols][resp_bytes] != '(empty)') and ([zeek_cols][resp_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_dstDataBytes"
               add_field => { "[server][bytes]" => "%{[zeek_cols][resp_bytes]}" } }
    }
    if ([zeek_cols][tunnel_parents]) and ([zeek_cols][tunnel_parents] != '(empty)') and ([zeek_cols][tunnel_parents] != '-') and ([zeek_cols][tunnel_parents] != '') {
      mutate { id => "mutate_split_zeek_tunnel_parents"
               split => { "[zeek_cols][tunnel_parents]" => "," } }
      mutate { id => "mutate_add_field_zeek_conn_rootId"
               add_field => { "[rootId]" => "%{[zeek_cols][tunnel_parents][0]}" } }
    }

  } else if ([log_source] == "bacnet") {
    #############################################################################################################################
    # bacnet.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][bvlc_function]}	%{[zeek_cols][pdu_type]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][invoke_id]}	%{[zeek_cols][result_code]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet"
        init => "$zeek_bacnet_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'bvlc_function', 'pdu_type', 'pdu_service', 'invoke_id', 'result_code' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bestguess") {
    #############################################################################################################################
    # bestguess.log

    dissect {
      id => "dissect_zeek_bestguess"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][name]}	%{[zeek_cols][category]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bestguess"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bestguess"
        init => "$zeek_bestguess_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'name', 'category' ]"
        code => "event.set('[zeek_cols]', $zeek_bestguess_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_tag_ics_best_guess_log"
             add_tag => [ "ics_best_guess" ] }

  } else if ([log_source] == "bsap_ip_header") {
    #############################################################################################################################
    # bsap_ip_header.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_ip_header"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][num_msg]}	%{[zeek_cols][type_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_ip_header"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_ip_header"
        init => "$zeek_bsap_ip_header_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'num_msg', 'type_name' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_ip_header_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_ip_header"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bsap_ip_rdb") {
    #############################################################################################################################
    # bsap_ip_rdb.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_ip_rdb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][header_size]}	%{[zeek_cols][mes_seq]}	%{[zeek_cols][res_seq]}	%{[zeek_cols][data_len]}	%{[zeek_cols][sequence]}	%{[zeek_cols][app_func_code]}	%{[zeek_cols][node_status]}	%{[zeek_cols][func_code]}	%{[zeek_cols][variable_count]}	%{[zeek_cols][variables]}	%{[zeek_cols][variable_value]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_ip_rdb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_ip_rdb"
        init => "$zeek_bsap_ip_rdb_field_names = [ 'ts', 'uid', 'header_size', 'mes_seq', 'res_seq', 'data_len', 'sequence', 'app_func_code', 'node_status', 'func_code', 'variable_count', 'variables', 'variable_value' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_ip_rdb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_ip_rdb"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bsap_serial_header") {
    #############################################################################################################################
    # bsap_serial_header.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_header"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ser]}	%{[zeek_cols][dadd]}	%{[zeek_cols][sadd]}	%{[zeek_cols][ctl]}	%{[zeek_cols][dfun]}	%{[zeek_cols][seq]}	%{[zeek_cols][sfun]}	%{[zeek_cols][nsb]}	%{[zeek_cols][type_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_header"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_header"
        init => "$zeek_bsap_serial_header_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'ser', 'dadd', 'sadd', 'ctl', 'dfun', 'seq', 'sfun', 'nsb', 'type_name' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_header_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_header"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bsap_serial_rdb") {
    #############################################################################################################################
    # bsap_serial_rdb.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_rdb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][func_code]}	%{[zeek_cols][variable_count]}	%{[zeek_cols][variables]}	%{[zeek_cols][variable_value]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_rdb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_rdb"
        init => "$zeek_bsap_serial_rdb_field_names = [ 'ts', 'uid', 'func_code', 'variable_count', 'variables', 'variable_value' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_rdb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_rdb"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bsap_serial_rdb_ext") {
    #############################################################################################################################
    # bsap_serial_rdb_ext.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_rdb_ext"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][dfun]}	%{[zeek_cols][seq]}	%{[zeek_cols][sfun]}	%{[zeek_cols][nsb]}	%{[zeek_cols][extfun]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_rdb_ext"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_rdb_ext"
        init => "$zeek_bsap_serial_rdb_ext_field_names = [ 'ts', 'uid', 'dfun', 'seq', 'sfun', 'nsb', 'extfun', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_rdb_ext_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_rdb_ext"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
      add_tag => [ "ics" ]
    }

    # for now, drop hex-encoded binary data for size
    if ([zeek_cols][data]) {
      mutate { id => "mutate_remove_field_zeek_bsap_serial_rdb_ext_data"
               remove_field => [ "[zeek_cols][data]" ] }
    }


  } else if ([log_source] == "bacnet_discovery") {
    #############################################################################################################################
    # bacnet_discovery.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet_discovery"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][object_type]}	%{[zeek_cols][instance_number]}	%{[zeek_cols][vendor]}	%{[zeek_cols][range]}	%{[zeek_cols][object_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet_discovery"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet_discovery"
        init => "$zeek_bacnet_discovery_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'pdu_service', 'object_type', 'instance_number', 'vendor', 'range', 'object_name' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_discovery_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet_discovery"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "bacnet_property") {
    #############################################################################################################################
    # bacnet_property.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet_property"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][object_type]}	%{[zeek_cols][instance_number]}	%{[zeek_cols][property]}	%{[zeek_cols][array_index]}	%{[zeek_cols][value]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet_property"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet_property"
        init => "$zeek_bacnet_property_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'pdu_service', 'object_type', 'instance_number', 'property', 'array_index', 'value' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_property_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet_property"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "cip") {
    #############################################################################################################################
    # cip.log
    # https://github.com/cisagov/ICSNPP
    #
    # todo: class_id, instance_id is a hex integer, should it be converted to an integer?

    dissect {
      id => "dissect_zeek_cip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cip_sequence_count]}	%{[zeek_cols][direction]}	%{[zeek_cols][cip_service_code]}	%{[zeek_cols][cip_service]}	%{[zeek_cols][cip_status]}	%{[zeek_cols][class_id]}	%{[zeek_cols][class_name]}	%{[zeek_cols][instance_id]}	%{[zeek_cols][attribute_id]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip"
        init => "$zeek_cip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cip_sequence_count', 'direction', 'cip_service', 'cip_status', 'class_id', 'class_name', 'instance_id', 'attribute_id' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip"
      add_field => { "[zeek_cols][service]" => "cip" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "cip_identity") {
    #############################################################################################################################
    # cip_identity.log
    # https://github.com/cisagov/ICSNPP
    #
    # TODO: device_status and device_state are a hex int string, convert to int?

    dissect {
      id => "dissect_zeek_cip_identity"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][encapsulation_version]}	%{[zeek_cols][socket_address]}	%{[zeek_cols][socket_port]}	%{[zeek_cols][vendor_id]}	%{[zeek_cols][vendor_name]}	%{[zeek_cols][device_type_id]}	%{[zeek_cols][device_type_name]}	%{[zeek_cols][product_code]}	%{[zeek_cols][revision]}	%{[zeek_cols][device_status]}	%{[zeek_cols][serial_number]}	%{[zeek_cols][product_name]}	%{[zeek_cols][device_state]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip_identity"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip_identity"
        init => "$zeek_cip_identity_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'encapsulation_version', 'socket_address', 'socket_port', 'vendor_id', 'vendor_name', 'device_type_id', 'device_type_name', 'product_code', 'device_status', 'serial_number', 'product_name', 'device_state' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_identity_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip_identity"
      add_field => { "[zeek_cols][service]" => "cip" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "cip_io") {
    #############################################################################################################################
    # cip_io.log
    # https://github.com/cisagov/ICSNPP
    #

    dissect {
      id => "dissect_zeek_cip_io"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][connection_id]}	%{[zeek_cols][sequence_number]}	%{[zeek_cols][data_length]}	%{[zeek_cols][io_data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip_io"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip_io"
        init => "$zeek_cip_io_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'connection_id', 'sequence_number', 'data_length', 'io_data' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_io_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip_io"
      add_field => { "[zeek_cols][service]" => "cip" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "dce_rpc") {
    #############################################################################################################################
    # dce_rpc.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dce-rpc/main.zeek.html#type-DCE_RPC::Info

    dissect {
      id => "dissect_zeek_dce_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][rtt]}	%{[zeek_cols][named_pipe]}	%{[zeek_cols][endpoint]}	%{[zeek_cols][operation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dce_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dce_rpc"
        init => "$zeek_dce_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'rtt', 'named_pipe', 'endpoint', 'operation' ]"
        code => "event.set('[zeek_cols]', $zeek_dce_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dce_rpc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "dce_rpc"
      }
    }

  } else if ([log_source] == "dhcp") {
    #############################################################################################################################
    # dhcp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dhcp/main.zeek.html#type-DHCP::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap dhcp.log field configuration version 0
      #
      # all fields               : 0x0001FFFF / 131071
      # all fields minus software: 0x00007FFF /  32767

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 131071) {
          dissect {
            id => "dissect_zeek_dhcp_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][host_name]}	%{[zeek_cols][client_fqdn]}	%{[zeek_cols][domain]}	%{[zeek_cols][requested_ip]}	%{[zeek_cols][assigned_ip]}	%{[zeek_cols][lease_time]}	%{[zeek_cols][client_message]}	%{[zeek_cols][server_message]}	%{[zeek_cols][msg_types]}	%{[zeek_cols][duration]}	%{[zeek_cols][client_software]}	%{[zeek_cols][server_software]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 32767) {
          dissect {
            id => "dissect_zeek_dhcp_with_all_fields_minus_software"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][host_name]}	%{[zeek_cols][client_fqdn]}	%{[zeek_cols][domain]}	%{[zeek_cols][requested_ip]}	%{[zeek_cols][assigned_ip]}	%{[zeek_cols][lease_time]}	%{[zeek_cols][client_message]}	%{[zeek_cols][server_message]}	%{[zeek_cols][msg_types]}	%{[zeek_cols][duration]}"
            }
          }

        } else {
          # who knows? the dhcp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_dhcp_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the dhcp.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_dhcp_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the dhcp.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_dhcp_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dhcp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dhcp"
        init => "$zeek_dhcp_field_names = [ 'ts', 'uid', 'orig_h', 'resp_h', 'orig_l2_addr', 'host_name', 'client_fqdn', 'domain', 'requested_ip', 'assigned_ip', 'lease_time', 'client_message', 'server_message', 'msg_types', 'duration', 'client_software', 'server_software' ]"
        code => "event.set('[zeek_cols]', $zeek_dhcp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if ([zeek_cols][uid]) and ([zeek_cols][uid] != '(empty)') and ([zeek_cols][uid] != '') {
      mutate { id => "mutate_split_zeek_dhcp_uids"
               split => { "[zeek_cols][uid]" => "," } }
    }
    if ([zeek_cols][uid] and [zeek_cols][uid][0]) {
      mutate { id => "mutate_add_field_zeek_dhcp_uids"
               add_field => { "[rootId]" => "%{[zeek_cols][uid][0]}" } }
    }

    if ((![zeek_cols][orig_p]) and (![zeek_cols][resp_p])) {
      mutate {
        id => "mutate_add_field_zeek_dhcp_ports"
        add_field => {
          "[zeek_cols][orig_p]" => 68
          "[zeek_cols][resp_p]" => 67
        }
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dhcp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "dhcp"
      }
    }

  } else if ([log_source] == "dnp3") {
    #############################################################################################################################
    # dnp3.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dnp3/main.zeek.html#type-DNP3::Info

    dissect {
      id => "dissect_zeek_dnp3"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fc_request]}	%{[zeek_cols][fc_reply]}	%{[zeek_cols][iin]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3"
        init => "$zeek_dnp3_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fc_request', 'fc_reply', 'iin' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3"
      add_field => { "[zeek_cols][service]" => "dnp3" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "dnp3_control") {
    #############################################################################################################################
    # dnp3_control.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_dnp3_control"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][block_type]}	%{[zeek_cols][function_code]}	%{[zeek_cols][index_number]}	%{[zeek_cols][trip_control_code]}	%{[zeek_cols][operation_type]}	%{[zeek_cols][execute_count]}	%{[zeek_cols][on_time]}	%{[zeek_cols][off_time]}	%{[zeek_cols][status_code]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3_control"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3_control"
        init => "$zeek_dnp3_control_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'block_type', 'function_code', 'index_number', 'trip_control_code', 'operation_type', 'execute_count', 'on_time', 'off_time', 'status_code' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_control_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3_control"
      add_field => { "[zeek_cols][service]" => "dnp3" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "dnp3_objects") {
    #############################################################################################################################
    # dnp3_objects.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_dnp3_objects"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][function_code]}	%{[zeek_cols][object_type]}	%{[zeek_cols][object_count]}	%{[zeek_cols][range_low]}	%{[zeek_cols][range_high]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3_objects"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3_objects"
        init => "$zeek_dnp3_objects_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'function_code', 'object_type', 'object_count', 'range_low', 'range_high' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_objects_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3_objects"
      add_field => { "[zeek_cols][service]" => "dnp3" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "dns") {
    #############################################################################################################################
    # dns.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dns/main.zeek.html#type-DNS::Info

    dissect {
      id => "dissect_zeek_dns"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][trans_id]}	%{[zeek_cols][rtt]}	%{[zeek_cols][query]}	%{[zeek_cols][qclass]}	%{[zeek_cols][qclass_name]}	%{[zeek_cols][qtype]}	%{[zeek_cols][qtype_name]}	%{[zeek_cols][rcode]}	%{[zeek_cols][rcode_name]}	%{[zeek_cols][AA]}	%{[zeek_cols][TC]}	%{[zeek_cols][RD]}	%{[zeek_cols][RA]}	%{[zeek_cols][Z]}	%{[zeek_cols][answers]}	%{[zeek_cols][TTLs]}	%{[zeek_cols][rejected]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dns"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dns"
        init => "$zeek_dns_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'trans_id', 'rtt', 'query', 'qclass', 'qclass_name', 'qtype', 'qtype_name', 'rcode', 'rcode_name', 'AA', 'TC', 'RD', 'RA', 'Z', 'answers', 'TTLs', 'rejected' ]"
        code => "event.set('[zeek_cols]', $zeek_dns_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    # remove C_ prefix from qclass_name
    mutate { id => "mutate_gsub_field_zeek_dns_qclass_name"
             gsub => [ "[zeek_cols][qclass_name]", "^C_", "" ] }

    mutate {
      id => "mutate_add_fields_zeek_dns"
      add_field => { "[zeek_cols][service]" => "dns" }
    }

  } else if ([log_source] == "dpd") {
    #############################################################################################################################
    # dpd.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/dpd/main.zeek.html#type-DPD::Info

    dissect {
      id => "dissect_zeek_dpd"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][failure_reason]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dpd"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dpd"
        init => "$zeek_dpd_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'service', 'failure_reason' ]"
        code => "event.set('[zeek_cols]', $zeek_dpd_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_lowercase_zeek_dpd_service"
             lowercase => [ "[zeek_cols][service]" ] }

    # normalize service string(s)
    if ([zeek_cols][service] =~ /^spicy_/) {
      # if it's coming from spicy, we don't care to have that in the service name
      mutate { id => "mutate_gsub_field_zeek_dpd_service_spicy_prefix"
               gsub => [ "[zeek_cols][service]", "^spicy_", "" ] }

      # some spicy services are named like blah_udp or blah_tcp,
      # and we don't care about the _udp/_tcp suffix
      mutate { id => "mutate_gsub_field_zeek_dpd_service_spicy_suffix"
               gsub => [ "[zeek_cols][service]", "_(tcp|udp)(_hmac)?(_(sha|md)\d+)?$", "" ] }
    }

  } else if ([log_source] == "enip") {
    #############################################################################################################################
    # enip.log
    # https://github.com/cisagov/ICSNPP
    #

    dissect {
      id => "dissect_zeek_enip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][enip_command_code]}	%{[zeek_cols][enip_command]}	%{[zeek_cols][length]}	%{[zeek_cols][session_handle]}	%{[zeek_cols][enip_status]}	%{[zeek_cols][sender_context]}	%{[zeek_cols][options]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_enip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_enip"
        init => "$zeek_enip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'enip_command', 'length', 'session_handle', 'enip_status', 'sender_context', 'options' ]"
        code => "event.set('[zeek_cols]', $zeek_enip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_enip"
      add_field => { "[zeek_cols][service]" => "enip" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_registers") {
    #############################################################################################################################
    # ecat_registers.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_registers"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][command]}	%{[zeek_cols][server_addr]}	%{[zeek_cols][register_type]}	%{[zeek_cols][register_addr]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_registers"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_registers"
        init => "$zeek_ecat_registers_field_names = [ 'ts', 'orig_l2_addr', 'resp_l2_addr', 'command', 'server_addr', 'register_type', 'register_addr', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_registers_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_registers"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_log_address") {
    #############################################################################################################################
    # ecat_log_address.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_log_address"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][log_addr]}	%{[zeek_cols][length]}	%{[zeek_cols][command]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_log_address"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_log_address"
        init => "$zeek_ecat_log_address_field_names = [ 'ts', 'orig_l2_addr', 'resp_l2_addr', 'log_addr', 'length', 'command', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_log_address_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_log_address"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_dev_info") {
    #############################################################################################################################
    # ecat_dev_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_dev_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][server_id]}	%{[zeek_cols][revision]}	%{[zeek_cols][dev_type]}	%{[zeek_cols][build]}	%{[zeek_cols][fmmucnt]}	%{[zeek_cols][smcount]}	%{[zeek_cols][ports]}	%{[zeek_cols][dpram]}	%{[zeek_cols][features]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_dev_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_dev_info"
        init => "$zeek_ecat_dev_info_field_names = [ 'ts', 'server_id', 'revision', 'dev_type', 'build', 'fmmucnt', 'smcount', 'ports', 'dpram', 'features' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_dev_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_dev_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_aoe_info") {
    #############################################################################################################################
    # ecat_aoe_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_aoe_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][resp_port]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][orig_port]}	%{[zeek_cols][command]}	%{[zeek_cols][state]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_aoe_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_aoe_info"
        init => "$zeek_ecat_aoe_info_field_names = [ 'ts', 'resp_l2_addr', 'resp_port', 'orig_l2_addr', 'orig_port', 'command', 'state', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_aoe_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_aoe_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_coe_info") {
    #############################################################################################################################
    # ecat_coe_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_coe_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][number]}	%{[zeek_cols][type]}	%{[zeek_cols][req_resp]}	%{[zeek_cols][index]}	%{[zeek_cols][subindex]}	%{[zeek_cols][dataoffset]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_coe_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_coe_info"
        init => "$zeek_ecat_coe_info_field_names = [ 'ts', 'number', 'type', 'req_resp', 'index', 'subindex', 'dataoffset' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_coe_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_coe_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_foe_info") {
    #############################################################################################################################
    # ecat_foe_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_foe_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][opcode]}	%{[zeek_cols][reserved]}	%{[zeek_cols][packet_num]}	%{[zeek_cols][error_code]}	%{[zeek_cols][filename]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_foe_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_foe_info"
        init => "$zeek_ecat_foe_info_field_names = [ 'ts', 'opcode', 'reserved', 'packet_num', 'error_code', 'filename', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_foe_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_foe_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_soe_info") {
    #############################################################################################################################
    # ecat_soe_info.log
    # https://github.com/cisagov/icsnpp-ethercat

    dissect {
      id => "dissect_zeek_ecat_soe_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][opcode]}	%{[zeek_cols][incomplete]}	%{[zeek_cols][error]}	%{[zeek_cols][drive_num]}	%{[zeek_cols][element]}	%{[zeek_cols][index]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_soe_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_soe_info"
        init => "$zeek_ecat_soe_info_field_names = [ 'ts', 'opcode', 'incomplete', 'error', 'drive_num', 'element', 'index' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_soe_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_soe_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "ecat_arp_info") {
    #############################################################################################################################
    # ecat_arp_info.log
    # https://github.com/cisagov/icsnpp-ethercat
    #
    # NOTE: I currently have this disabled by including ecat_arp_info in drop_zeek_ignored_source
    # above, as it is including ALL arps and not just those from ethercat traffic which can
    # be misleading (i.e., indicating ecat traffic where there is none)

    dissect {
      id => "dissect_zeek_ecat_arp_info"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][arp_type]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][orig_proto_addr]}	%{[zeek_cols][orig_hw_addr]}	%{[zeek_cols][resp_proto_addr]}	%{[zeek_cols][resp_hw_addr]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ecat_arp_info"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ecat_arp_info"
        init => "$zeek_ecat_arp_info_field_names = [ 'ts', 'arp_type', 'orig_l2_addr', 'resp_l2_addr', 'orig_proto_addr', 'orig_hw_addr', 'resp_proto_addr', 'resp_hw_addr' ]"
        code => "event.set('[zeek_cols]', $zeek_ecat_arp_info_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ecat_arp_info"
      add_field => {
        "[zeek_cols][service]" => "ethercat"
      }
    }

    # TODO: check orig_proto_addr/orig_hw_addr resp_proto_addr/resp_hw_addr and convert to ip, etc. if necessary?

  } else if ([log_source] == "files") {
    #############################################################################################################################
    # files.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/files/main.zeek.html#type-Files::Info

    # TODO: spicy-zip adds ftime (https://github.com/zeek/spicy-zip/blob/main/analyzer/main.zeek) which screws my bitmaps up :/

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap files.log field configuration version 0
      #
      # all fields (with extracted file size info) :    0x01FFFFFF / 33554431
      # all fields (without extracted file size info) : 0x007FFFFF / 8388607

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 33554431) {

          dissect {
            id => "dissect_zeek_files_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][tx_hosts]}	%{[zeek_cols][rx_hosts]}	%{[zeek_cols][conn_uids]}	%{[zeek_cols][source]}	%{[zeek_cols][depth]}	%{[zeek_cols][analyzers]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][filename]}	%{[zeek_cols][duration]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][seen_bytes]}	%{[zeek_cols][total_bytes]}	%{[zeek_cols][missing_bytes]}	%{[zeek_cols][overflow_bytes]}	%{[zeek_cols][timedout]}	%{[zeek_cols][parent_fuid]}	%{[zeek_cols][md5]}	%{[zeek_cols][sha1]}	%{[zeek_cols][sha256]}	%{[zeek_cols][extracted]}	%{[zeek_cols][extracted_cutoff]}	%{[zeek_cols][extracted_size]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {

          dissect {
            id => "dissect_zeek_files_with_all_fields_minus_extract_size"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][tx_hosts]}	%{[zeek_cols][rx_hosts]}	%{[zeek_cols][conn_uids]}	%{[zeek_cols][source]}	%{[zeek_cols][depth]}	%{[zeek_cols][analyzers]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][filename]}	%{[zeek_cols][duration]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][seen_bytes]}	%{[zeek_cols][total_bytes]}	%{[zeek_cols][missing_bytes]}	%{[zeek_cols][overflow_bytes]}	%{[zeek_cols][timedout]}	%{[zeek_cols][parent_fuid]}	%{[zeek_cols][md5]}	%{[zeek_cols][sha1]}	%{[zeek_cols][sha256]}	%{[zeek_cols][extracted]}"
            }
          }

        } else {
          # who knows? the files.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_files_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the files.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_files_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the files.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_files_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_files"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_files"
        init => "$zeek_files_field_names = [ 'ts', 'fuid', 'tx_hosts', 'rx_hosts', 'conn_uids', 'source', 'depth', 'analyzers', 'mime_type', 'filename', 'duration', 'local_orig', 'is_orig', 'seen_bytes', 'total_bytes', 'missing_bytes', 'overflow_bytes', 'timedout', 'parent_fuid', 'md5', 'sha1', 'sha256', 'extracted', 'extracted_cutoff', 'extracted_size', 'ftime' ]"
        code => "event.set('[zeek_cols]', $zeek_files_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if ([zeek_cols][conn_uids]) and ([zeek_cols][conn_uids] != '(empty)') and ([zeek_cols][conn_uids] != '') {
      mutate { id => "mutate_split_zeek_files_conn_uids"
               split => { "[zeek_cols][conn_uids]" => "," } }
    }
    if ([zeek_cols][tx_hosts]) and ([zeek_cols][tx_hosts] != '(empty)') and ([zeek_cols][tx_hosts] != '') {
      mutate { id => "mutate_split_zeek_files_tx_hosts"
               split => { "[zeek_cols][tx_hosts]" => "," } }
    }
    if ([zeek_cols][rx_hosts]) and ([zeek_cols][rx_hosts] != '(empty)') and ([zeek_cols][rx_hosts] != '') {
      mutate { id => "mutate_split_zeek_files_rx_hosts"
               split => { "[zeek_cols][rx_hosts]" => "," } }
    }

    if ([zeek_cols][conn_uids] and [zeek_cols][conn_uids][0]) {
      mutate {
        id => "mutate_add_field_zeek_files_conn_uids_to_uid"
        add_field => { "[rootId]"         => "%{[zeek_cols][conn_uids][0]}"
                       "[zeek_cols][uid]" => "%{[zeek_cols][conn_uids][0]}" }
        }
    } else {
      mutate {
        id => "mutate_add_fields_zeek_files_fuid_to_uid"
        add_field =>  { "[zeek_cols][uid]" => "%{[zeek_cols][fuid]}" }
      }
    }

    if ([zeek_cols][tx_hosts] and [zeek_cols][tx_hosts][0]) {
      mutate { id => "mutate_add_field_zeek_tx_hosts"
               add_field => { "[source][ip]" => "%{[zeek_cols][tx_hosts][0]}" } }
    }

    if ([zeek_cols][rx_hosts] and [zeek_cols][rx_hosts][0]) {
      mutate { id => "mutate_add_field_zeek_rx_hosts"
               add_field => { "[destination][ip]" => "%{[zeek_cols][rx_hosts][0]}" } }
    }


  } else if ([log_source] == "ftp") {
    #############################################################################################################################
    # ftp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ftp/info.zeek.html#type-FTP::Info

    dissect {
      id => "dissect_zeek_ftp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][command]}	%{[zeek_cols][arg]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][file_size]}	%{[zeek_cols][reply_code]}	%{[zeek_cols][reply_msg]}	%{[zeek_cols][data_channel_passive]}	%{[zeek_cols][data_channel_orig_h]}	%{[zeek_cols][data_channel_resp_h]}	%{[zeek_cols][data_channel_resp_p]}	%{[zeek_cols][fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ftp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ftp"
        init => "$zeek_ftp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'password', 'command', 'arg', 'mime_type', 'file_size', 'reply_code', 'reply_msg', 'data_channel_passive', 'data_channel_orig_h', 'data_channel_resp_h', 'data_channel_resp_p', 'fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_ftp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ftp"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "ftp"
      }
    }

  } else if ([log_source] == "genisys") {
    #############################################################################################################################
    # genisys.log
    # https://github.com/cisagov/icsnpp-genisys

    dissect {
      id => "dissect_zeek_genisys"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][header]}	%{[zeek_cols][server]}	%{[zeek_cols][direction]}	%{[zeek_cols][crc_transmitted]}	%{[zeek_cols][crc_calculated]}	%{[zeek_cols][payload_raw]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_genisys"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => " " }
      }
      ruby {
        id => "ruby_zip_zeek_genisys"
        init => "$zeek_genisys_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'header', 'server', 'direction', 'crc_transmitted', 'crc_calculated', 'payload_raw' ]"
        code => "event.set('[zeek_cols]', $zeek_genisys_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_genisys"
      add_field => {
        "[zeek_cols][service]" => "genisys"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "gquic") {
    #############################################################################################################################
    # gquic.log
    # https://github.com/salesforce/GQUIC_Protocol_Analyzer/blob/master/scripts/Salesforce/GQUIC/main.bro

    dissect {
      id => "dissect_zeek_gquic"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][server_name]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][tag_count]}	%{[zeek_cols][cyu]}	%{[zeek_cols][cyutags]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_gquic"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_gquic"
        init => "$zeek_gquic_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'server_name', 'user_agent', 'tag_count', 'cyu', 'cyutags' ]"
        code => "event.set('[zeek_cols]', $zeek_gquic_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_gquic"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "quic"
      }
    }

  } else if ([log_source] == "http") {
    #############################################################################################################################
    # http.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/http/main.zeek.html#type-HTTP::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap http.log field configuration version 0
      # all fields:                                       0x7FFFFFFFF / 34359738367
      # minus fields added by zeek-sniffpass:             0x03FFFFFFF /  1073741823
      # minus origin and fields added by zeek-sniffpass:  0x03FFFDFFF /  1073733631

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 34359738367) {
          dissect {
            id => "dissect_zeek_http_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][origin]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}	%{[zeek_cols][post_username]}	%{[zeek_cols][post_password_plain]}	%{[zeek_cols][post_password_md5]}	%{[zeek_cols][post_password_sha1]}	%{[zeek_cols][post_password_sha256]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 1073741823) {
          dissect {
            id => "dissect_zeek_http_with_all_fields_minus_sniffpass"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][origin]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 1073733631) {
          dissect {
            id => "dissect_zeek_http_with_all_fields_minus_origin"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}"
            }
          }

        } else {
          # who knows? the http.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_http_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the http.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_http_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the http.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_http_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_http"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_http"
        init => "$zeek_http_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'method', 'host', 'uri', 'referrer', 'version', 'user_agent', 'origin', 'request_body_len', 'response_body_len', 'status_code', 'status_msg', 'info_code', 'info_msg', 'tags', 'user', 'password', 'proxied', 'orig_fuids', 'orig_filenames', 'orig_mime_types', 'resp_fuids', 'resp_filenames', 'resp_mime_types', 'post_username', 'post_password_plain', 'post_password_md5', 'post_password_sha1', 'post_password_sha256' ]"
        code => "event.set('[zeek_cols]', $zeek_http_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_http"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "http"
      }
    }

  } else if ([log_source] == "intel") {
    #############################################################################################################################
    # intel.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/intel/main.zeek.html#type-Intel::Info

    dissect {
      id => "dissect_zeek_intel"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][seen_indicator]}	%{[zeek_cols][seen_indicator_type]}	%{[zeek_cols][seen_where]}	%{[zeek_cols][seen_node]}	%{[zeek_cols][matched]}	%{[zeek_cols][sources]}	%{[zeek_cols][fuid]}	%{[zeek_cols][file_mime_type]}	%{[zeek_cols][file_desc]}	%{[zeek_cols][cif_tags]}	%{[zeek_cols][cif_confidence]}	%{[zeek_cols][cif_source]}	%{[zeek_cols][cif_description]}	%{[zeek_cols][cif_firstseen]}	%{[zeek_cols][cif_lastseen]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_intel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_intel"
        init => "$zeek_intel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'seen_indicator', 'seen_indicator_type', 'seen_where', 'seen_node', 'matched', 'sources', 'fuid', 'file_mime_type', 'file_desc', 'cif_tags', 'cif_confidence', 'cif_source', 'cif_description', 'cif_firstseen', 'cif_lastseen' ]"
        code => "event.set('[zeek_cols]', $zeek_intel_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "ipsec") {
    #############################################################################################################################
    # ipsec.log
    # https://github.com/corelight/zeek-spicy-ipsec/blob/master/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_ipsec"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][initiator_spi]}	%{[zeek_cols][responder_spi]}	%{[zeek_cols][maj_ver]}	%{[zeek_cols][min_ver]}	%{[zeek_cols][exchange_type]}	%{[zeek_cols][flag_e]}	%{[zeek_cols][flag_c]}	%{[zeek_cols][flag_a]}	%{[zeek_cols][flag_i]}	%{[zeek_cols][flag_v]}	%{[zeek_cols][flag_r]}	%{[zeek_cols][message_id]}	%{[zeek_cols][vendor_ids]}	%{[zeek_cols][notify_messages]}	%{[zeek_cols][transforms]}	%{[zeek_cols][ke_dh_groups]}	%{[zeek_cols][proposals]}	%{[zeek_cols][protocol_id]}	%{[zeek_cols][certificates]}	%{[zeek_cols][transform_attributes]}	%{[zeek_cols][length]}	%{[zeek_cols][hash]}	%{[zeek_cols][doi]}	%{[zeek_cols][situation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ipsec"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ipsec"
        init => "$zeek_ipsec_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'is_orig', 'initiator_spi', 'responder_spi', 'maj_ver', 'min_ver', 'exchange_type', 'flag_e', 'flag_c', 'flag_a', 'flag_i', 'flag_v', 'flag_r', 'message_id', 'vendor_ids', 'notify_messages', 'transforms', 'ke_dh_groups', 'proposals', 'protocol_id', 'certificates', 'transform_attributes', 'length', 'hash', 'doi', 'situation' ]"
        code => "event.set('[zeek_cols]', $zeek_ipsec_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ipsec"
      add_field => {
        "[zeek_cols][service]" => "ipsec"
      }
    }

  } else if ([log_source] == "irc") {
    #############################################################################################################################
    # irc.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/irc/main.zeek.html#type-IRC::Info

    dissect {
      id => "dissect_zeek_irc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][nick]}	%{[zeek_cols][user]}	%{[zeek_cols][command]}	%{[zeek_cols][value]}	%{[zeek_cols][addl]}	%{[zeek_cols][dcc_file_name]}	%{[zeek_cols][dcc_file_size]}	%{[zeek_cols][dcc_mime_type]}	%{[zeek_cols][fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_irc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_irc"
        init => "$zeek_irc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'nick', 'user', 'command', 'value', 'addl', 'dcc_file_name', 'dcc_file_size', 'dcc_mime_type', 'fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_irc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_irc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "irc"
      }
    }

  } else if ([log_source] == "iso_cotp") {
    #############################################################################################################################
    # iso_cotp.log
    # https://github.com/amzn/zeek-plugin-s7comm/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_iso_cotp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][pdu_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_iso_cotp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_iso_cotp"
        init => "$zeek_iso_cotp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'pdu_type' ]"
        code => "event.set('[zeek_cols]', $zeek_iso_cotp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_iso_cotp"
      add_field =>  { "[zeek_cols][service]" => "cotp" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "kerberos") {
    #############################################################################################################################
    # kerberos.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/krb/main.zeek.html#type-KRB::Info

    dissect {
      id => "dissect_zeek_kerberos"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][request_type]}	%{[zeek_cols][cname]}	%{[zeek_cols][sname]}	%{[zeek_cols][success]}	%{[zeek_cols][error_msg]}	%{[zeek_cols][from]}	%{[zeek_cols][till]}	%{[zeek_cols][cipher]}	%{[zeek_cols][forwardable]}	%{[zeek_cols][renewable]}	%{[zeek_cols][client_cert_subject]}	%{[zeek_cols][client_cert_fuid]}	%{[zeek_cols][server_cert_subject]}	%{[zeek_cols][server_cert_fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_kerberos"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_kerberos"
        init => "$zeek_kerberos_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'request_type', 'cname', 'sname', 'success', 'error_msg', 'from', 'till', 'cipher', 'forwardable', 'renewable', 'client_cert_subject', 'client_cert_fuid', 'server_cert_subject', 'server_cert_fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_kerberos_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_krb5"
      add_field =>  { "[zeek_cols][service]" => "krb" }
    }

  } else if ([log_source] == "known_certs") {
    #############################################################################################################################
    # known_certs.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/ssl/known-certs.zeek.html#type-Known::CertsInfo

    dissect {
      id => "dissect_zeek_known_certs"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][subject]}	%{[zeek_cols][issuer_subject]}	%{[zeek_cols][serial]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_certs"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_certs"
        init => "$zeek_known_certs_field_names = [ 'ts', 'orig_h', 'orig_p', 'subject', 'resp_h', 'issuer_subject', 'serial' ]"
        code => "event.set('[zeek_cols]', $zeek_known_certs_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_known_certs"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tls"
      }
    }

  } else if ([log_source] == "known_hosts") {
    #############################################################################################################################
    # known_hosts.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/conn/known-hosts.zeek.html#type-Known::HostsInfo

    dissect {
      id => "dissect_zeek_known_hosts"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_hosts"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_hosts"
        init => "$zeek_known_hosts_field_names = [ 'ts', 'orig_h' ]"
        code => "event.set('[zeek_cols]', $zeek_known_hosts_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "known_modbus") {
    #############################################################################################################################
    # known_modbus.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/modbus/known-masters-slaves.zeek.html#type-Known::ModbusInfo

    dissect {
      id => "dissect_zeek_known_modbus"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][device_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_modbus"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_modbus"
        init => "$zeek_known_modbus_field_names = [ 'ts', 'orig_h', 'device_type' ]"
        code => "event.set('[zeek_cols]', $zeek_known_modbus_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_gsub_zeek_known_modbus_device_type"
             gsub => [ "[zeek_cols][device_type]", "Known::", "" ] }

    mutate { id => "mutate_add_tag_ics_known_modbus_log"
             add_tag => [ "ics" ] }

  } else if ([log_source] == "known_services") {
    #############################################################################################################################
    # known_services.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/conn/known-services.zeek.html#type-Known::ServicesInfo

    dissect {
      id => "dissect_zeek_known_services"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_services"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_services"
        init => "$zeek_known_services_field_names = [ 'ts', 'resp_h', 'resp_p', 'proto', 'service' ]"
        code => "event.set('[zeek_cols]', $zeek_known_services_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_lowercase_zeek_known_services_service"
             lowercase => [ "[zeek_cols][service]" ] }

    # normalize service string(s)

    # some services are named like blah_udp/blah_tcp/blah_data, and we don't care about the suffix
    mutate { id => "mutate_gsub_field_zeek_known_services_protocol_suffix"
             gsub => [ "[zeek_cols][service]", "[_-](tcp|udp|data)", "" ] }

    if ([zeek_cols][service] =~ /^spicy_/) {
      # if it's coming from spicy, we don't care to have that in the service name
      mutate { id => "mutate_gsub_field_zeek_known_service_spicy_prefix"
               gsub => [ "[zeek_cols][service]", "^spicy_", "" ] }

      # some spicy services are named like blah_udp or blah_tcp,
      # and we don't care about the _udp/_tcp suffix
      mutate { id => "mutate_gsub_field_zeek_known_service_spicy_suffix"
               gsub => [ "[zeek_cols][service]", "(_hmac)?(_(sha|md)\d+)?$", "" ] }

    }

  } else if ([log_source] == "ldap") {
    #############################################################################################################################
    # ldap.log
    # https://github.com/zeek/spicy-ldap/blob/main/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_ldap"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][message_id]}	%{[zeek_cols][version]}	%{[zeek_cols][operation]}	%{[zeek_cols][result_code]}	%{[zeek_cols][result_message]}	%{[zeek_cols][object]}	%{[zeek_cols][argument]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ldap"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ldap"
        init => "$zeek_ldap_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'message_id', 'version', 'operation', 'result_code', 'result_message', 'object', 'argument' ]"
        code => "event.set('[zeek_cols]', $zeek_ldap_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ldap"
      add_field =>  { "[zeek_cols][service]" => "ldap" }
    }

  } else if ([log_source] == "ldap_search") {
    #############################################################################################################################
    # ldap_search.log
    # https://github.com/zeek/spicy-ldap/blob/main/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_ldap_search"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][message_id]}	%{[zeek_cols][scope]}	%{[zeek_cols][deref]}	%{[zeek_cols][base_object]}	%{[zeek_cols][result_count]}	%{[zeek_cols][result_code]}	%{[zeek_cols][result_message]}	%{[zeek_cols][filter]}	%{[zeek_cols][attributes]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ldap_search"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ldap_search"
        init => "$zeek_ldap_search_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'message_id', 'scope', 'deref', 'base_object', 'result_count', 'result_code', 'result_message', 'filter', 'attributes' ]"
        code => "event.set('[zeek_cols]', $zeek_ldap_search_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ldap_search"
      add_field =>  { "[zeek_cols][service]" => "ldap" }
    }

  } else if ([log_source] == "login") {
    #############################################################################################################################
    # login.log
    # custom login.log module (rudimentary, telnet/rlogin/rsh analyzers are old and not the greatest)

    dissect {
      id => "dissect_zeek_login"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][service]}	%{[zeek_cols][success]}	%{[zeek_cols][confused]}	%{[zeek_cols][user]}	%{[zeek_cols][client_user]}	%{[zeek_cols][password]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_login"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_login"
        init => "$zeek_login_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'service', 'success', 'confused', 'user', 'client_user', 'password' ]"
        code => "event.set('[zeek_cols]', $zeek_login_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "modbus") {
    #############################################################################################################################
    # modbus.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/modbus/main.zeek.html#type-Modbus::Info

    dissect {
      id => "dissect_zeek_modbus"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][func]}	%{[zeek_cols][exception]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus"
        init => "$zeek_modbus_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'func', 'exception' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "modbus_detailed") {
    #############################################################################################################################
    # modbus_detailed.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_modbus_detailed"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][unit_id]}	%{[zeek_cols][func]}	%{[zeek_cols][network_direction]}	%{[zeek_cols][address]}	%{[zeek_cols][quantity]}	%{[zeek_cols][values]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_detailed"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_detailed"
        init => "$zeek_modbus_detailed_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'unit_id', 'func', 'network_direction', 'address', 'quantity', 'values' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_detailed_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus_detailed"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "modbus_mask_write_register") {
    #############################################################################################################################
    # modbus_mask_write_register.log
    # https://github.com/cisagov/ICSNPP

    dissect {
      id => "dissect_zeek_modbus_mask_write_register"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][unit_id]}	%{[zeek_cols][func]}	%{[zeek_cols][network_direction]}	%{[zeek_cols][address]}	%{[zeek_cols][and_mask]}	%{[zeek_cols][or_mask]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_mask_write_register"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_mask_write_register"
        init => "$zeek_modbus_mask_write_register_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'unit_id', 'func', 'network_direction', 'address', 'and_mask', 'or_mask' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_modbus_mask_write_register_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_modbus_mask_write_register"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "modbus_read_write_multiple_registers") {
    #############################################################################################################################
    # modbus_read_write_multiple_registers.log
    # https://github.com/cisagov/ICSNPP
    dissect {
      id => "dissect_zeek_modbus_read_write_multiple_registers"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][unit_id]}	%{[zeek_cols][func]}	%{[zeek_cols][network_direction]}	%{[zeek_cols][write_start_address]}	%{[zeek_cols][write_registers]}	%{[zeek_cols][read_start_address]}	%{[zeek_cols][read_quantity]}	%{[zeek_cols][read_registers]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_read_write_multiple_registers"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_read_write_multiple_registers"
        init => "$zeek_modbus_read_write_multiple_registers_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'unit_id', 'func', 'network_direction', 'write_start_address', 'write_registers', 'read_start_address', 'read_quantity', 'read_registers' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_read_write_multiple_registers_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus_read_write_multiple_registers"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "mqtt_connect") {
    #############################################################################################################################
    # mqtt_connect.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/mqtt/main.zeek.html#type-MQTT::ConnectInfo

    dissect {
      id => "dissect_zeek_mqtt_connect"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto_name]}	%{[zeek_cols][proto_version]}	%{[zeek_cols][client_id]}	%{[zeek_cols][connect_status]}	%{[zeek_cols][will_topic]}	%{[zeek_cols][will_payload]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_connect"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_connect"
        init => "$zeek_mqtt_connect_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto_name', 'proto_version', 'client_id', 'connect_status', 'will_topic', 'will_payload' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_connect_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mqtt_connect"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

  } else if ([log_source] == "mqtt_publish") {
    #############################################################################################################################
    # mqtt_publish.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/mqtt/main.zeek.html#type-MQTT::PublishInfo

    dissect {
      id => "dissect_zeek_mqtt_publish"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][from_client]}	%{[zeek_cols][retain]}	%{[zeek_cols][qos]}	%{[zeek_cols][status]}	%{[zeek_cols][topic]}	%{[zeek_cols][payload]}	%{[zeek_cols][payload_len]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_publish"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_publish"
        init => "$zeek_mqtt_publish_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'from_client', 'retain', 'qos', 'status', 'topic', 'payload', 'payload_len' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_publish_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mqtt_publish"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

  } else if ([log_source] == "mqtt_subscribe") {
    #############################################################################################################################
    # mqtt_subscribe.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/mqtt/main.zeek.html#type-MQTT::SubscribeInfo

    dissect {
      id => "dissect_zeek_mqtt_subscribe"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][action]}	%{[zeek_cols][topics]}	%{[zeek_cols][qos_levels]}	%{[zeek_cols][granted_qos_level]}	%{[zeek_cols][ack]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_subscribe"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_subscribe"
        init => "$zeek_mqtt_subscribe_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'action', 'topics', 'qos_levels', 'granted_qos_level', 'ack' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_subscribe_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mqtt_subscribe"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

    mutate { id => "mutate_gsub_zeek_mqtt_subscribe_action"
             gsub => [ "[zeek_cols][action]", "MQTT::", "" ] }

  } else if ([log_source] == "mysql") {
    #############################################################################################################################
    # mysql.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/mysql/main.zeek.html#type-MySQL::Info

    dissect {
      id => "dissect_zeek_mysql"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cmd]}	%{[zeek_cols][arg]}	%{[zeek_cols][success]}	%{[zeek_cols][rows]}	%{[zeek_cols][response]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mysql"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mysql"
        init => "$zeek_mysql_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cmd', 'arg', 'success', 'rows', 'response' ]"
        code => "event.set('[zeek_cols]', $zeek_mysql_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mysql"
      add_field =>  { "[zeek_cols][service]" => "mysql" }
    }

  } else if ([log_source] == "notice") {
    #############################################################################################################################
    # notice.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/notice/main.zeek.html#type-Notice::Info

    dissect {
      id => "dissect_zeek_notice_with_all_fields"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][file_mime_type]}	%{[zeek_cols][file_desc]}	%{[zeek_cols][proto]}	%{[zeek_cols][note]}	%{[zeek_cols][msg]}	%{[zeek_cols][sub]}	%{[zeek_cols][src]}	%{[zeek_cols][dst]}	%{[zeek_cols][p]}	%{[zeek_cols][n]}	%{[zeek_cols][peer_descr]}	%{[zeek_cols][actions]}	%{[zeek_cols][email_dest]}	%{[zeek_cols][suppress_for]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_notice"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_notice"
        init => "$zeek_notice_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fuid', 'file_mime_type', 'file_desc', 'proto', 'note', 'msg', 'sub', 'src', 'dst', 'p', 'n', 'peer_descr', 'actions', 'email_dest', 'suppress_for', 'remote_location_country_code', 'remote_location_region', 'remote_location_city', 'remote_location_latitude', 'remote_location_longitude' ]"
        code => "event.set('[zeek_cols]', $zeek_notice_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if (![zeek_cols][orig_h])       or ([zeek_cols][orig_h] == '(empty)') or
       ([zeek_cols][orig_h] == '-') or ([zeek_cols][orig_h] == '') {
      mutate { id => "mutate_replace_zeek_notice_orig_h"
               replace => { "[zeek_cols][orig_h]" => "%{[zeek_cols][src]}" } }
    }
    if (![zeek_cols][resp_h])       or ([zeek_cols][resp_h] == '(empty)') or
       ([zeek_cols][resp_h] == '-') or ([zeek_cols][resp_h] == '') {
      mutate { id => "mutate_replace_zeek_notice_resp_h"
               replace => { "[zeek_cols][resp_h]" => "%{[zeek_cols][dst]}" } }
    }
    if (![zeek_cols][resp_p])       or ([zeek_cols][resp_p] == '(empty)') or
       ([zeek_cols][resp_p] == '-') or ([zeek_cols][resp_p] == '') {
      mutate { id => "mutate_replace_zeek_resp_p"
               replace => { "[zeek_cols][resp_p]" => "%{[zeek_cols][p]}" } }
    }

  } else if ([log_source] == "ntlm") {
    #############################################################################################################################
    # ntlm.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ntlm/main.zeek.html#type-NTLM::Info

    dissect {
      id => "dissect_zeek_ntlm_with_all_fields"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][host]}	%{[zeek_cols][domain]}	%{[zeek_cols][server_nb_computer]}	%{[zeek_cols][server_dns_computer]}	%{[zeek_cols][server_tree]}	%{[zeek_cols][success]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ntlm"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ntlm"
        init => "$zeek_ntlm_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'host', 'domain', 'server_nb_computer', 'server_dns_computer', 'server_tree', 'success' ]"
        code => "event.set('[zeek_cols]', $zeek_ntlm_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ntlm"
      add_field =>  { "[zeek_cols][service]" => "ntlm" }
    }

  } else if ([log_source] == "ntp") {
    #############################################################################################################################
    # ntp.log
    # https://docs.zeek.org/en/latest/scripts/base/protocols/ntp/main.zeek.html#type-NTP::Info

    dissect {
      id => "dissect_zeek_ntp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][mode]}	%{[zeek_cols][stratum]}	%{[zeek_cols][poll]}	%{[zeek_cols][precision]}	%{[zeek_cols][root_delay]}	%{[zeek_cols][root_disp]}	%{[zeek_cols][ref_id]}	%{[zeek_cols][ref_time]}	%{[zeek_cols][org_time]}	%{[zeek_cols][rec_time]}	%{[zeek_cols][xmt_time]}	%{[zeek_cols][num_exts]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ntp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ntp"
        init => "$zeek_ntp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'mode', 'stratum', 'poll', 'precision', 'root_delay', 'root_disp', 'ref_id', 'ref_time', 'org_time', 'rec_time', 'xmt_time', 'num_exts' ]"
        code => "event.set('[zeek_cols]', $zeek_ntp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ntp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "ntp"
      }
    }

  } else if ([log_source] == "ocsp") {
    #############################################################################################################################
    # ocsp.log
    # https://docs.zeek.org/en/stable/scripts/policy/files/x509/log-ocsp.zeek.html#type-OCSP::Info

    dissect {
      id => "dissect_zeek_ocsp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][hashAlgorithm]}	%{[zeek_cols][issuerNameHash]}	%{[zeek_cols][issuerKeyHash]}	%{[zeek_cols][serialNumber]}	%{[zeek_cols][certStatus]}	%{[zeek_cols][revoketime]}	%{[zeek_cols][revokereason]}	%{[zeek_cols][thisUpdate]}	%{[zeek_cols][nextUpdate]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ocsp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_ocsp"
        init => "$zeek_ocsp_field_names = [ 'ts', 'fuid', 'hashAlgorithm', 'issuerNameHash', 'issuerKeyHash', 'serialNumber', 'certStatus', 'revoketime', 'revokereason', 'thisUpdate', 'nextUpdate' ]"
        code => "event.set('[zeek_cols]', $zeek_ocsp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_service_ocsp"
             add_field => { "[zeek_cols][service]" => "X.509" } }

  } else if ([log_source] == "opcua_binary_diag_info_detail") {
    #############################################################################################################################
    # opcua-binary-diag-info-detail.log
    # https://github.com/cisagov/icsnpp-opcua-binary/blob/main/scripts/types.zeek

    dissect {
      id => "dissect_zeek_opcua_binary_diag_info_detail"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_id]}	%{[zeek_cols][inner_diag_level]}	%{[zeek_cols][has_symbolic_id]}	%{[zeek_cols][symbolic_id]}	%{[zeek_cols][symbolic_id_str]}	%{[zeek_cols][has_namespace_uri]}	%{[zeek_cols][namespace_uri]}	%{[zeek_cols][namespace_uri_str]}	%{[zeek_cols][has_locale]}	%{[zeek_cols][locale]}	%{[zeek_cols][locale_str]}	%{[zeek_cols][has_locale_txt]}	%{[zeek_cols][locale_txt]}	%{[zeek_cols][locale_txt_str]}	%{[zeek_cols][has_addl_info]}	%{[zeek_cols][addl_info]}	%{[zeek_cols][has_inner_stat_code]}	%{[zeek_cols][inner_stat_code]}	%{[zeek_cols][has_inner_diag_info]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_opcua_binary_diag_info_detail"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_opcua_binary_diag_info_detail"
        init => "$zeek_opcua_binary_diag_info_detail_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_id', 'inner_diag_level', 'has_symbolic_id', 'symbolic_id', 'symbolic_id_str', 'has_namespace_uri', 'namespace_uri', 'namespace_uri_str', 'has_locale', 'locale', 'locale_str', 'has_locale_txt', 'locale_txt', 'locale_txt_str', 'has_addl_info', 'addl_info', 'has_inner_stat_code', 'inner_stat_code', 'has_inner_diag_info' ]"
        code => "event.set('[zeek_cols]', $zeek_opcua_binary_diag_info_detail_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_service_opcua_binary_diag_info_detail"
             add_field => { "[zeek_cols][proto]" => "tcp"
                            "[zeek_cols][service]" => "opcua-binary" }
             add_tag => [ "ics" ] }

  } else if ([log_source] == "opcua_binary_get_endpoints") {
    #############################################################################################################################
    # opcua-binary-get-endpoints.log
    # https://github.com/cisagov/icsnpp-opcua-binary/blob/main/scripts/types.zeek

    dissect {
      id => "dissect_zeek_opcua_binary_get_endpoints"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_id]}	%{[zeek_cols][endpoint_url]}	%{[zeek_cols][locale_id]}	%{[zeek_cols][profile_uri]}	%{[zeek_cols][application_uri]}	%{[zeek_cols][product_uri]}	%{[zeek_cols][encoding_mask]}	%{[zeek_cols][locale]}	%{[zeek_cols][text]}	%{[zeek_cols][application_type]}	%{[zeek_cols][gateway_server_uri]}	%{[zeek_cols][discovery_profile_id]}	%{[zeek_cols][cert_size]}	%{[zeek_cols][server_cert]}	%{[zeek_cols][message_security_mode]}	%{[zeek_cols][security_policy_uri]}	%{[zeek_cols][user_token_id]}	%{[zeek_cols][transport_profile_uri]}	%{[zeek_cols][security_level]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_opcua_binary_get_endpoints"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_opcua_binary_get_endpoints"
        init => "$zeek_opcua_binary_get_endpoints_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_id', 'endpoint_url', 'locale_id', 'profile_uri', 'application_uri', 'product_uri', 'encoding_mask', 'locale', 'text', 'application_type', 'gateway_server_uri', 'discovery_profile_id', 'cert_size', 'server_cert', 'message_security_mode', 'security_policy_uri', 'user_token_id', 'transport_profile_uri', 'security_level' ]"
        code => "event.set('[zeek_cols]', $zeek_opcua_binary_get_endpoints_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_service_opcua_binary_get_endpoints"
             add_field => { "[zeek_cols][proto]" => "tcp"
                            "[zeek_cols][service]" => "opcua-binary" }
             add_tag => [ "ics" ] }

  } else if ([log_source] == "opcua_binary_get_endpoints_discovery") {
    #############################################################################################################################
    # opcua-binary-get-endpoints-discovery.log
    # https://github.com/cisagov/icsnpp-opcua-binary/blob/main/scripts/types.zeek

    dissect {
      id => "dissect_zeek_opcua_binary_get_endpoints_discovery"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][discovery_profile_id]}	%{[zeek_cols][discovery_profile_uri]}	%{[zeek_cols][discovery_profile_url]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_opcua_binary_get_endpoints_discovery"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_opcua_binary_get_endpoints_discovery"
        init => "$zeek_opcua_binary_get_endpoints_discovery_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'discovery_profile_id', 'discovery_profile_uri', 'discovery_profile_url' ]"
        code => "event.set('[zeek_cols]', $zeek_opcua_binary_get_endpoints_discovery_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_service_opcua_binary_get_endpoints_discovery"
             add_field => { "[zeek_cols][proto]" => "tcp"
                            "[zeek_cols][service]" => "opcua-binary" }
             add_tag => [ "ics" ] }

  } else if ([log_source] == "opcua_binary_get_endpoints_user_token") {
    #############################################################################################################################
    # opcua-binary-get-endpoints-user-token.log
    # https://github.com/cisagov/icsnpp-opcua-binary/blob/main/scripts/types.zeek

    dissect {
      id => "dissect_zeek_opcua_binary_get_endpoints_user_token"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user_token_id]}	%{[zeek_cols][user_token_policy_id]}	%{[zeek_cols][user_token_type]}	%{[zeek_cols][user_token_issued_type]}	%{[zeek_cols][user_token_endpoint_url]}	%{[zeek_cols][user_token_sec_policy_uri]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_opcua_binary_get_endpoints_user_token"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_opcua_binary_get_endpoints_user_token"
        init => "$zeek_opcua_binary_get_endpoints_user_token_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user_token_id', 'user_token_policy_id', 'user_token_type', 'user_token_issued_type', 'user_token_endpoint_url', 'user_token_sec_policy_uri' ]"
        code => "event.set('[zeek_cols]', $zeek_opcua_binary_get_endpoints_user_token_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_service_opcua_binary_get_endpoints_user_token"
             add_field => { "[zeek_cols][proto]" => "tcp"
                            "[zeek_cols][service]" => "opcua-binary" }
             add_tag => [ "ics" ] }

  } else if ([log_source] == "opcua_binary") {
    #############################################################################################################################
    # opcua-binary.log
    # https://github.com/cisagov/icsnpp-opcua-binary/blob/main/scripts/types.zeek

    dissect {
      id => "dissect_zeek_opcua_binary"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_id]}	%{[zeek_cols][msg_type]}	%{[zeek_cols][is_final]}	%{[zeek_cols][msg_size]}	%{[zeek_cols][error]}	%{[zeek_cols][reason]}	%{[zeek_cols][version]}	%{[zeek_cols][rcv_buf_size]}	%{[zeek_cols][snd_buf_size]}	%{[zeek_cols][max_msg_size]}	%{[zeek_cols][max_chunk_cnt]}	%{[zeek_cols][endpoint_url]}	%{[zeek_cols][sec_channel_id]}	%{[zeek_cols][sec_policy_uri_len]}	%{[zeek_cols][sec_policy_uri]}	%{[zeek_cols][snd_cert_len]}	%{[zeek_cols][snd_cert]}	%{[zeek_cols][rcv_cert_len]}	%{[zeek_cols][rcv_cert]}	%{[zeek_cols][seq_number]}	%{[zeek_cols][request_id]}	%{[zeek_cols][encoding_mask]}	%{[zeek_cols][namespace_idx]}	%{[zeek_cols][identifier]}	%{[zeek_cols][identifier_str]}	%{[zeek_cols][req_hdr_node_id_type]}	%{[zeek_cols][req_hdr_node_id_namespace_idx]}	%{[zeek_cols][req_hdr_node_id_numeric]}	%{[zeek_cols][req_hdr_node_id_string]}	%{[zeek_cols][req_hdr_node_id_guid]}	%{[zeek_cols][req_hdr_node_id_opaque]}	%{[zeek_cols][req_hdr_timestamp]}	%{[zeek_cols][req_hdr_request_handle]}	%{[zeek_cols][req_hdr_return_diag]}	%{[zeek_cols][req_hdr_audit_entry_id]}	%{[zeek_cols][req_hdr_timeout_hint]}	%{[zeek_cols][req_hdr_add_hdr_type_id]}	%{[zeek_cols][req_hdr_add_hdr_enc_mask]}	%{[zeek_cols][res_hdr_timestamp]}	%{[zeek_cols][res_hdr_request_handle]}	%{[zeek_cols][res_hdr_service_result]}	%{[zeek_cols][res_hdr_service_diag_encoding]}	%{[zeek_cols][res_hdr_add_hdr_type_id]}	%{[zeek_cols][res_hdr_add_hdr_enc_mask]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_opcua_binary"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_opcua_binary"
        init => "$zeek_opcua_binary_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_id', 'msg_type', 'is_final', 'msg_size', 'error', 'reason', 'version', 'rcv_buf_size', 'snd_buf_size', 'max_msg_size', 'max_chunk_cnt', 'endpoint_url', 'sec_channel_id', 'sec_policy_uri_len', 'sec_policy_uri', 'snd_cert_len', 'snd_cert', 'rcv_cert_len', 'rcv_cert', 'seq_number', 'request_id', 'encoding_mask', 'namespace_idx', 'identifier', 'identifier_str', 'req_hdr_node_id_type', 'req_hdr_node_id_namespace_idx', 'req_hdr_node_id_numeric', 'req_hdr_node_id_string', 'req_hdr_node_id_guid', 'req_hdr_node_id_opaque', 'req_hdr_timestamp', 'req_hdr_request_handle', 'req_hdr_return_diag', 'req_hdr_audit_entry_id', 'req_hdr_timeout_hint', 'req_hdr_add_hdr_type_id', 'req_hdr_add_hdr_enc_mask', 'res_hdr_timestamp', 'res_hdr_request_handle', 'res_hdr_service_result', 'res_hdr_service_diag_encoding', 'res_hdr_add_hdr_type_id', 'res_hdr_add_hdr_enc_mask' ]"
        code => "event.set('[zeek_cols]', $zeek_opcua_binary_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_service_opcua_binary"
             add_field => { "[zeek_cols][proto]" => "tcp"
                            "[zeek_cols][service]" => "opcua-binary" }
             add_tag => [ "ics" ] }

  } else if ([log_source] == "opcua_binary_opensecure_channel") {
    #############################################################################################################################
    # opcua-binary-opensecure-channel.log
    # https://github.com/cisagov/icsnpp-opcua-binary/blob/main/scripts/types.zeek

    dissect {
      id => "dissect_zeek_opcua_binary_opensecure_channel"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_id]}	%{[zeek_cols][client_proto_ver]}	%{[zeek_cols][sec_token_request_type]}	%{[zeek_cols][message_security_mode]}	%{[zeek_cols][client_nonce]}	%{[zeek_cols][req_lifetime]}	%{[zeek_cols][server_proto_ver]}	%{[zeek_cols][sec_token_sec_channel_id]}	%{[zeek_cols][sec_token_id]}	%{[zeek_cols][sec_token_created_at]}	%{[zeek_cols][sec_token_revised_time]}	%{[zeek_cols][server_nonce]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_opcua_binary_opensecure_channel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_opcua_binary_opensecure_channel"
        init => "$zeek_opcua_binary_opensecure_channel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_id', 'client_proto_ver', 'sec_token_request_type', 'message_security_mode', 'client_nonce', 'req_lifetime', 'server_proto_ver', 'sec_token_sec_channel_id', 'sec_token_id', 'sec_token_created_at', 'sec_token_revised_time', 'server_nonce' ]"
        code => "event.set('[zeek_cols]', $zeek_opcua_binary_opensecure_channel_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_service_opcua_binary_opensecure_channel"
             add_field => { "[zeek_cols][proto]" => "tcp"
                            "[zeek_cols][service]" => "opcua-binary" }
             add_tag => [ "ics" ] }

  } else if ([log_source] == "opcua_binary_status_code_detail") {
    #############################################################################################################################
    # opcua-binary-status-code-detail.log
    # https://github.com/cisagov/icsnpp-opcua-binary/blob/main/scripts/types.zeek

    dissect {
      id => "dissect_zeek_opcua_binary_status_code_detail"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][opcua_id]}	%{[zeek_cols][source]}	%{[zeek_cols][source_str]}	%{[zeek_cols][status_code]}	%{[zeek_cols][severity]}	%{[zeek_cols][severity_str]}	%{[zeek_cols][sub_code]}	%{[zeek_cols][sub_code_str]}	%{[zeek_cols][structure_changed]}	%{[zeek_cols][semantics_changed]}	%{[zeek_cols][info_type]}	%{[zeek_cols][info_type_str]}	%{[zeek_cols][limit_bits]}	%{[zeek_cols][limit_bits_str]}	%{[zeek_cols][overflow]}	%{[zeek_cols][historian_bits]}	%{[zeek_cols][historian_bits_str]}	%{[zeek_cols][historianPartial]}	%{[zeek_cols][historianExtraData]}	%{[zeek_cols][historianMultiValue]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_opcua_binary_status_code_detail"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_opcua_binary_status_code_detail"
        init => "$zeek_opcua_binary_status_code_detail_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'opcua_id', 'source', 'source_str', 'status_code', 'severity', 'severity_str', 'sub_code', 'sub_code_str', 'structure_changed', 'semantics_changed', 'info_type', 'info_type_str', 'limit_bits', 'limit_bits_str', 'overflow', 'historian_bits', 'historian_bits_str', 'historianPartial', 'historianExtraData', 'historianMultiValue' ]"
        code => "event.set('[zeek_cols]', $zeek_opcua_binary_status_code_detail_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_service_opcua_binary_status_code_detail"
             add_field => { "[zeek_cols][proto]" => "tcp"
                            "[zeek_cols][service]" => "opcua-binary" }
             add_tag => [ "ics" ] }

  } else if ([log_source] == "ospf") {
    #############################################################################################################################
    # ospf.log
    # https://github.com/corelight/zeek-spicy-ospf

    dissect {
      id => "dissect_zeek_ospf"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][ospf_type]}	%{[zeek_cols][version]}	%{[zeek_cols][router_id]}	%{[zeek_cols][area_id]}	%{[zeek_cols][interface_id]}	%{[zeek_cols][netmask]}	%{[zeek_cols][desig_router]}	%{[zeek_cols][backup_router]}	%{[zeek_cols][neighbors]}	%{[zeek_cols][lsa_type]}	%{[zeek_cols][link_state_id]}	%{[zeek_cols][advert_router]}	%{[zeek_cols][routers]}	%{[zeek_cols][link_id]}	%{[zeek_cols][link_data]}	%{[zeek_cols][link_type]}	%{[zeek_cols][neighbor_router_id]}	%{[zeek_cols][metrics]}	%{[zeek_cols][fwd_addrs]}	%{[zeek_cols][route_tags]}	%{[zeek_cols][neighbor_interface_id]}	%{[zeek_cols][prefix]}	%{[zeek_cols][metric]}	%{[zeek_cols][dest_router_id]}	%{[zeek_cols][link_prefixes]}	%{[zeek_cols][intra_prefixes]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ospf"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }

      ruby {
        id => "ruby_zip_zeek_ospf"
        init => "$zeek_ospf_field_names = [ 'ts', 'orig_h', 'resp_h', 'ospf_type', 'version', 'router_id', 'area_id', 'interface_id', 'netmask', 'desig_router', 'backup_router', 'neighbors', 'lsa_type', 'link_state_id', 'advert_router', 'routers', 'link_id', 'link_data', 'link_type', 'neighbor_router_id', 'metrics', 'fwd_addrs', 'route_tags', 'neighbor_interface_id', 'prefix', 'metric', 'dest_router_id', 'link_prefixes', 'intra_prefixes' ]"
        code => "event.set('[zeek_cols]', $zeek_ospf_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ospf"
      add_field => {
        "[zeek_cols][proto]" => "ospf"
        "[zeek_cols][service]" => "ospf"
      }
    }

  } else if ([log_source] == "pe") {
    #############################################################################################################################
    # pe.log
    # https://docs.zeek.org/en/stable/scripts/base/files/pe/main.zeek.html#type-PE::Info

    dissect {
      id => "dissect_zeek_pe"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][machine]}	%{[zeek_cols][compile_ts]}	%{[zeek_cols][os]}	%{[zeek_cols][subsystem]}	%{[zeek_cols][is_exe]}	%{[zeek_cols][is_64bit]}	%{[zeek_cols][uses_aslr]}	%{[zeek_cols][uses_dep]}	%{[zeek_cols][uses_code_integrity]}	%{[zeek_cols][uses_seh]}	%{[zeek_cols][has_import_table]}	%{[zeek_cols][has_export_table]}	%{[zeek_cols][has_cert_table]}	%{[zeek_cols][has_debug_data]}	%{[zeek_cols][section_names]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_pe"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_pe"
        init => "$zeek_pe_field_names = [ 'ts', 'fuid', 'machine', 'compile_ts', 'os', 'subsystem', 'is_exe', 'is_64bit', 'uses_aslr', 'uses_dep', 'uses_code_integrity', 'uses_seh', 'has_import_table', 'has_export_table', 'has_cert_table', 'has_debug_data', 'section_names' ]"
        code => "event.set('[zeek_cols]', $zeek_pe_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "profinet") {
    #############################################################################################################################
    # profinet.log
    # https://github.com/amzn/zeek-plugin-profinet/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_profinet"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][operation_type]}	%{[zeek_cols][block_version]}	%{[zeek_cols][slot_number]}	%{[zeek_cols][subslot_number]}	%{[zeek_cols][index]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_profinet"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_profinet"
        init => "$zeek_profinet_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'operation_type', 'block_version', 'slot_number', 'subslot_number', 'index' ]"
        code => "event.set('[zeek_cols]', $zeek_profinet_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_profinet"
      add_field =>  { "[zeek_cols][service]" => "profinet" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "profinet_dce_rpc") {
    #############################################################################################################################
    # profinet_dce_rpc.log
    # https://github.com/amzn/zeek-plugin-profinet/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_profinet_dce_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][packet_type]}	%{[zeek_cols][object_uuid]}	%{[zeek_cols][interface_uuid]}	%{[zeek_cols][activity_uuid]}	%{[zeek_cols][server_boot_time]}	%{[zeek_cols][operation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_profinet_dce_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_profinet_dce_rpc"
        init => "$zeek_profinet_dce_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'packet_type', 'object_uuid', 'interface_uuid', 'activity_uuid', 'server_boot_time', 'operation' ]"
        code => "event.set('[zeek_cols]', $zeek_profinet_dce_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_profinet_dce_rpc"
      add_field =>  { "[zeek_cols][service]" => "profinet_dce_rpc" }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "radius") {
    #############################################################################################################################
    # radius.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/radius/main.zeek.html#type-RADIUS::Info

    dissect {
      id => "dissect_zeek_radius"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][mac]}	%{[zeek_cols][framed_addr]}	%{[zeek_cols][tunnel_client]}	%{[zeek_cols][connect_info]}	%{[zeek_cols][reply_msg]}	%{[zeek_cols][result]}	%{[zeek_cols][ttl]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_radius"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_radius"
        init => "$zeek_radius_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'mac', 'framed_addr', 'tunnel_client', 'connect_info', 'reply_msg', 'result', 'ttl' ]"
        code => "event.set('[zeek_cols]', $zeek_radius_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_radius"
      add_field =>  { "[zeek_cols][service]" => "radius" }
    }

  } else if ([log_source] == "rdp") {
    #############################################################################################################################
    # rdp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/rdp/main.zeek.html#type-RDP::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap rdp.log field configuration version 0
      # all fields:             0x03FFFFF / 4194303
      # minus client_channels:  0x03FFDFF / 4193791

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 4194303) {
          dissect {
            id => "dissect_zeek_rdp_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cookie]}	%{[zeek_cols][result]}	%{[zeek_cols][security_protocol]}	%{[zeek_cols][client_channels]}	%{[zeek_cols][keyboard_layout]}	%{[zeek_cols][client_build]}	%{[zeek_cols][client_name]}	%{[zeek_cols][client_dig_product_id]}	%{[zeek_cols][desktop_width]}	%{[zeek_cols][desktop_height]}	%{[zeek_cols][requested_color_depth]}	%{[zeek_cols][cert_type]}	%{[zeek_cols][cert_count]}	%{[zeek_cols][cert_permanent]}	%{[zeek_cols][encryption_level]}	%{[zeek_cols][encryption_method]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 4193791) {
          dissect {
            id => "dissect_zeek_rdp_with_all_fields_minus_client_channels"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cookie]}	%{[zeek_cols][result]}	%{[zeek_cols][security_protocol]}	%{[zeek_cols][keyboard_layout]}	%{[zeek_cols][client_build]}	%{[zeek_cols][client_name]}	%{[zeek_cols][client_dig_product_id]}	%{[zeek_cols][desktop_width]}	%{[zeek_cols][desktop_height]}	%{[zeek_cols][requested_color_depth]}	%{[zeek_cols][cert_type]}	%{[zeek_cols][cert_count]}	%{[zeek_cols][cert_permanent]}	%{[zeek_cols][encryption_level]}	%{[zeek_cols][encryption_method]}"
            }
          }

        } else {
          # who knows? the rdp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_rdp_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the rdp.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_rdp_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the rdp.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_rdp_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_rdp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_rdp"
        init => "$zeek_rdp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cookie', 'result', 'security_protocol', 'client_channels', 'keyboard_layout', 'client_build', 'client_name', 'client_dig_product_id', 'desktop_width', 'desktop_height', 'requested_color_depth', 'cert_type', 'cert_count', 'cert_permanent', 'encryption_level', 'encryption_method' ]"
        code => "event.set('[zeek_cols]', $zeek_rdp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_rdp"
      add_field =>  { "[zeek_cols][service]" => "rdp" }
    }

    # remove RDP prefix from client_build (version)
    mutate { id => "mutate_gsub_field_zeek_rdp_client_build"
             gsub => [ "[zeek_cols][client_build]", "^RDP ", "" ] }

  } else if ([log_source] == "rfb") {
    #############################################################################################################################
    # rfb.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/rfb/main.zeek.html#type-RFB::Info

    dissect {
      id => "dissect_zeek_rfb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][client_major_version]}	%{[zeek_cols][client_minor_version]}	%{[zeek_cols][server_major_version]}	%{[zeek_cols][server_minor_version]}	%{[zeek_cols][authentication_method]}	%{[zeek_cols][auth]}	%{[zeek_cols][share_flag]}	%{[zeek_cols][desktop_name]}	%{[zeek_cols][width]}	%{[zeek_cols][height]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_rfb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_rfb"
        init => "$zeek_rfb_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'client_major_version', 'client_minor_version', 'server_major_version', 'server_minor_version', 'authentication_method', 'auth', 'share_flag', 'desktop_name', 'width', 'height' ]"
        code => "event.set('[zeek_cols]', $zeek_rfb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_rfb"
      add_field =>  { "[zeek_cols][service]" => "rfb" }
    }

  } else if ([log_source] == "s7comm") {
    #############################################################################################################################
    # s7comm.log
    # https://github.com/amzn/zeek-plugin-s7comm/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_s7comm"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][rosctr]}	%{[zeek_cols][parameter]}	%{[zeek_cols][item_count]}	%{[zeek_cols][data_info]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_s7comm"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_s7comm"
        init => "$zeek_s7comm_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'rosctr', 'parameter', 'item_count', 'data_info' ]"
        code => "event.set('[zeek_cols]', $zeek_s7comm_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_s7comm"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "s7comm"
      }
      add_tag => [ "ics" ]
    }

  } else if ([log_source] == "signatures") {
    #############################################################################################################################
    # signatures.log

    dissect {
      id => "dissect_zeek_signatures"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][note]}	%{[zeek_cols][signature_id]}	%{[zeek_cols][event_message]}	%{[zeek_cols][sub_message]}	%{[zeek_cols][signature_count]}	%{[zeek_cols][host_count]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_signatures"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_signatures"
        init => "$zeek_signatures_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'note', 'signature_id', 'event_message', 'sub_message', 'signature_count', 'host_count' ]"
        code => "event.set('[zeek_cols]', $zeek_signatures_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "sip") {
    #############################################################################################################################
    # sip.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/sip/main.zeek.html#type-SIP::Info

    dissect {
      id => "dissect_zeek_sip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][uri]}	%{[zeek_cols][date]}	%{[zeek_cols][request_from]}	%{[zeek_cols][request_to]}	%{[zeek_cols][response_from]}	%{[zeek_cols][response_to]}	%{[zeek_cols][reply_to]}	%{[zeek_cols][call_id]}	%{[zeek_cols][seq]}	%{[zeek_cols][subject]}	%{[zeek_cols][request_path]}	%{[zeek_cols][response_path]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][warning]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][content_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_sip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_sip"
        init => "$zeek_sip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'method', 'uri', 'date', 'request_from', 'request_to', 'response_from', 'response_to', 'reply_to', 'call_id', 'seq', 'subject', 'request_path', 'response_path', 'user_agent', 'status_code', 'status_msg', 'warning', 'request_body_len', 'response_body_len', 'content_type' ]"
        code => "event.set('[zeek_cols]', $zeek_sip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_sip"
      add_field =>  { "[zeek_cols][service]" => "sip" }
    }

  } else if ([log_source] == "smb_cmd") {
    #############################################################################################################################
    # smb_cmd.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smb/main.zeek.html#type-SMB::CmdInfo
    #
    # note that smb_cmd.referenced_file is exactly the same structure as the log line for smb_files. later on it will be
    # merged up as its own top-level entity so I don't have to duplicate the parsing effort below

    dissect {
      id => "dissect_zeek_smb_cmd"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][command]}	%{[zeek_cols][sub_command]}	%{[zeek_cols][argument]}	%{[zeek_cols][status]}	%{[zeek_cols][rtt]}	%{[zeek_cols][version]}	%{[zeek_cols][user]}	%{[zeek_cols][tree]}	%{[zeek_cols][tree_service]}	%{[zeek_cols][referenced_file][ts]}	%{[zeek_cols][referenced_file][uid]}	%{[zeek_cols][referenced_file][orig_h]}	%{[zeek_cols][referenced_file][orig_p]}	%{[zeek_cols][referenced_file][resp_h]}	%{[zeek_cols][referenced_file][resp_p]}	%{[zeek_cols][referenced_file][fuid]}	%{[zeek_cols][referenced_file][action]}	%{[zeek_cols][referenced_file][path]}	%{[zeek_cols][referenced_file][name]}	%{[zeek_cols][referenced_file][size]}	%{[zeek_cols][referenced_file][prev_name]}	%{[zeek_cols][referenced_file][times_modified]}	%{[zeek_cols][referenced_file][times_accessed]}	%{[zeek_cols][referenced_file][times_created]}	%{[zeek_cols][referenced_file][times_changed]}	%{[zeek_cols][referenced_file][data_offset_req]}	%{[zeek_cols][referenced_file][data_len_req]}	%{[zeek_cols][referenced_file][data_len_rsp]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_cmd"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_cmd"
        init => "$zeek_smb_cmd_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'command', 'sub_command', 'argument', 'status', 'rtt', 'version', 'user', 'tree', 'tree_service', 'referenced_file.ts', 'referenced_file.uid', 'referenced_file.orig_h', 'referenced_file.orig_p', 'referenced_file.resp_h', 'referenced_file.resp_p', 'referenced_file.fuid', 'referenced_file.action', 'referenced_file.path', 'referenced_file.name', 'referenced_file.size', 'referenced_file.prev_name', 'referenced_file.times_modified', 'referenced_file.times_accessed', 'referenced_file.times_created', 'referenced_file.times_changed', 'referenced_file.data_offset_req', 'referenced_file.data_len_req', 'referenced_file.data_len_rsp' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_cmd_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_cmd"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

    # remove SMB prefix from version
    mutate { id => "mutate_gsub_field_zeek_smb_cmd_version"
             gsub => [ "[zeek_cols][version]", "^SMB", "" ] }

    mutate { id => "mutate_gsub_zeek_smb_cmd_command"
             gsub => [ "[zeek_cols][command]", "^SMB::", "" ] }

  } else if ([log_source] == "smb_files") {
    #############################################################################################################################
    # smb_files.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smb/main.zeek.html#type-SMB::FileInfo

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap smb_files.log field configuration version 0
      #
      # smb_files.log without data_offset_req, data_len_req, data_len_rsp : 0x0000FFFF / 65535
      # smb_files.log with data_offset_req, data_len_req, data_len_rsp :    0x0007FFFF / 524287

      # smb_files.log with data_offset_req, data_len_req, data_len_rsp

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 524287) {

          dissect {
            id => "dissect_zeek_smb_files_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][action]}	%{[zeek_cols][path]}	%{[zeek_cols][name]}	%{[zeek_cols][size]}	%{[zeek_cols][prev_name]}	%{[zeek_cols][times_modified]}	%{[zeek_cols][times_accessed]}	%{[zeek_cols][times_created]}	%{[zeek_cols][times_changed]}	%{[zeek_cols][data_offset_req]}	%{[zeek_cols][data_len_req]}	%{[zeek_cols][data_len_rsp]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 65535) {

          dissect {
            id => "dissect_zeek_smb_files_without_data_lens"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][action]}	%{[zeek_cols][path]}	%{[zeek_cols][name]}	%{[zeek_cols][size]}	%{[zeek_cols][prev_name]}	%{[zeek_cols][times_modified]}	%{[zeek_cols][times_accessed]}	%{[zeek_cols][times_created]}	%{[zeek_cols][times_changed]}"
            }
          }

        } else {
          # who knows? the smb_files.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_smb_files_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the smb_files.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_smb_files_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the smb_files.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_smb_files_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_files"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_files"
        init => "$zeek_smb_files_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fuid', 'action', 'path', 'name', 'size', 'prev_name', 'times_modified', 'times_accessed', 'times_created', 'times_changed', 'data_offset_req', 'data_len_req', 'data_len_rsp' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_files_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_files"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

    mutate { id => "mutate_gsub_zeek_smb_files_action"
             gsub => [ "[zeek_cols][action]", "^SMB::", "" ] }

  } else if ([log_source] == "smb_mapping") {
    #############################################################################################################################
    # smb_mapping.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smb/main.zeek.html#type-SMB::TreeInfo

    dissect {
      id => "dissect_zeek_smb_mapping"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][path]}	%{[zeek_cols][resource_type]}	%{[zeek_cols][native_file_system]}	%{[zeek_cols][share_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_mapping"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_mapping"
        init => "$zeek_smb_mapping_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'path', 'resource_type', 'native_file_system', 'share_type' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_mapping_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_mapping"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

  } else if ([log_source] == "smtp") {
    #############################################################################################################################
    # smtp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smtp/main.zeek.html#type-SMTP::Info

    dissect {
      id => "dissect_zeek_smtp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][helo]}	%{[zeek_cols][mailfrom]}	%{[zeek_cols][rcptto]}	%{[zeek_cols][date]}	%{[zeek_cols][from]}	%{[zeek_cols][to]}	%{[zeek_cols][cc]}	%{[zeek_cols][reply_to]}	%{[zeek_cols][msg_id]}	%{[zeek_cols][in_reply_to]}	%{[zeek_cols][subject]}	%{[zeek_cols][x_originating_ip]}	%{[zeek_cols][first_received]}	%{[zeek_cols][second_received]}	%{[zeek_cols][last_reply]}	%{[zeek_cols][path]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][tls]}	%{[zeek_cols][fuid]}	%{[zeek_cols][is_webmail]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smtp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smtp"
        init => "$zeek_smtp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'helo', 'mailfrom', 'rcptto', 'date', 'from', 'to', 'cc', 'reply_to', 'msg_id', 'in_reply_to', 'subject', 'x_originating_ip', 'first_received', 'second_received', 'last_reply', 'path', 'user_agent', 'tls', 'fuid', 'is_webmail' ]"
        code => "event.set('[zeek_cols]', $zeek_smtp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smtp"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smtp"
      }
    }

  } else if ([log_source] == "snmp") {
    #############################################################################################################################
    # snmp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/snmp/main.zeek.html#type-SNMP::Info

    dissect {
      id => "dissect_zeek_snmp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][duration]}	%{[zeek_cols][version]}	%{[zeek_cols][community]}	%{[zeek_cols][get_requests]}	%{[zeek_cols][get_bulk_requests]}	%{[zeek_cols][get_responses]}	%{[zeek_cols][set_requests]}	%{[zeek_cols][display_string]}	%{[zeek_cols][up_since]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_snmp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_snmp"
        init => "$zeek_snmp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'duration', 'version', 'community', 'get_requests', 'get_bulk_requests', 'get_responses', 'set_requests', 'display_string', 'up_since' ]"
        code => "event.set('[zeek_cols]', $zeek_snmp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_snmp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "snmp"
      }
    }

  } else if ([log_source] == "socks") {
    #############################################################################################################################
    # socks.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/socks/main.zeek.html#type-SOCKS::Info

    dissect {
      id => "dissect_zeek_socks"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][server_status]}	%{[zeek_cols][request_host]}	%{[zeek_cols][request_name]}	%{[zeek_cols][request_port]}	%{[zeek_cols][bound_host]}	%{[zeek_cols][bound_name]}	%{[zeek_cols][bound_port]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_socks"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_socks"
        init => "$zeek_socks_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'user', 'password', 'server_status', 'request_host', 'request_name', 'request_port', 'bound_host', 'bound_name', 'bound_port' ]"
        code => "event.set('[zeek_cols]', $zeek_socks_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_socks"
      add_field =>  { "[zeek_cols][service]" => "socks" }
    }

  } else if ([log_source] == "software") {
    #############################################################################################################################
    # software.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/software/main.zeek.html#type-Software::Info

    dissect {
      id => "dissect_zeek_software"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][software_type]}	%{[zeek_cols][name]}	%{[zeek_cols][version_major]}	%{[zeek_cols][version_minor]}	%{[zeek_cols][version_minor2]}	%{[zeek_cols][version_minor3]}	%{[zeek_cols][version_addl]}	%{[zeek_cols][unparsed_version]}	%{[zeek_cols][url]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_software"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_software"
        init => "$zeek_software_field_names = [ 'ts', 'orig_h', 'orig_p', 'software_type', 'name', 'version_major', 'version_minor', 'version_minor2', 'version_minor3', 'version_addl', 'unparsed_version', 'url' ]"
        code => "event.set('[zeek_cols]', $zeek_software_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "wireguard") {
    #############################################################################################################################
    # wireguard.log
    # https://github.com/corelight/zeek-spicy-wireguard/blob/master/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_wireguard"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][established]}	%{[zeek_cols][initiations]}	%{[zeek_cols][responses]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_wireguard"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_wireguard"
        init => "$zeek_wireguard_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'established', 'initiations', 'responses' ]"
        code => "event.set('[zeek_cols]', $zeek_wireguard_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_gsub_zeek_wireguard_packet_type"
             gsub => [ "[zeek_cols][packet_type]", "Wireguard::WG_", "" ] }

    mutate {
      id => "mutate_add_field_zeek_service_wireguard"
      add_field =>  {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "wireguard"
      }
    }

  } else if ([log_source] == "ssh") {
    #############################################################################################################################
    # ssh.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ssh/main.zeek.html#type-SSH::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ssh.log field configuration version 0
      #
      # standard ssh.log without HASSH fingerprinting add-on script : 0x007FFFFF / 8388607
      # ssh.log with HASSH fingerprinting add-on script :             0x3FFFFFFF / 1073741823

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 1073741823) {

          dissect {
            id => "dissect_zeek_ssh_with_all_fields_with_hassh"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][auth_success]}	%{[zeek_cols][auth_attempts]}	%{[zeek_cols][direction]}	%{[zeek_cols][client]}	%{[zeek_cols][server]}	%{[zeek_cols][cipher_alg]}	%{[zeek_cols][mac_alg]}	%{[zeek_cols][compression_alg]}	%{[zeek_cols][kex_alg]}	%{[zeek_cols][host_key_alg]}	%{[zeek_cols][host_key]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}	%{[zeek_cols][hasshVersion]}	%{[zeek_cols][hassh]}	%{[zeek_cols][hasshServer]}	%{[zeek_cols][cshka]}	%{[zeek_cols][hasshAlgorithms]}	%{[zeek_cols][sshka]}	%{[zeek_cols][hasshServerAlgorithms]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {

          dissect {
            id => "dissect_zeek_ssh_with_all_fields_no_hassh"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][auth_success]}	%{[zeek_cols][auth_attempts]}	%{[zeek_cols][direction]}	%{[zeek_cols][client]}	%{[zeek_cols][server]}	%{[zeek_cols][cipher_alg]}	%{[zeek_cols][mac_alg]}	%{[zeek_cols][compression_alg]}	%{[zeek_cols][kex_alg]}	%{[zeek_cols][host_key_alg]}	%{[zeek_cols][host_key]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}"
            }
          }

        } else {
          # who knows? the ssh.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ssh_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ssh.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ssh_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ssh.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ssh_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ssh"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ssh"
        init => "$zeek_ssh_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'auth_success', 'auth_attempts', 'direction', 'client', 'server', 'cipher_alg', 'mac_alg', 'compression_alg', 'kex_alg', 'host_key_alg', 'host_key', 'remote_location_country_code', 'remote_location_region', 'remote_location_city', 'remote_location_latitude', 'remote_location_longitude', 'hasshVersion', 'hassh', 'hasshServer', 'cshka', 'hasshAlgorithms', 'sshka', 'hasshServerAlgorithms' ]"
        code => "event.set('[zeek_cols]', $zeek_ssh_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ssh"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "ssh"
      }
    }

  } else if ([log_source] == "ssl") {
    #############################################################################################################################
    # ssl.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ssl/main.zeek.html#type-SSL::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ssl.log (v4.1.0+) field configuration version 0
      #
      # standard ssl.log fields without add-on JA3 fingerprinting script :  0x0007FFFF /  524287
      # ssl.log fields with add-on JA3 fingerprinting script :              0x001FFFFF / 2097151

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 2097151) {

          dissect {
            id => "dissect_zeek_ssl_v1_with_ja3"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ssl_version]}	%{[zeek_cols][cipher]}	%{[zeek_cols][curve]}	%{[zeek_cols][server_name]}	%{[zeek_cols][resumed]}	%{[zeek_cols][last_alert]}	%{[zeek_cols][next_protocol]}	%{[zeek_cols][established]}	%{[zeek_cols][ssl_history]}	%{[zeek_cols][cert_chain_fps]}	%{[zeek_cols][client_cert_chain_fps]}	%{[zeek_cols][sni_matches_cert]}	%{[zeek_cols][validation_status]}	%{[zeek_cols][ja3]}	%{[zeek_cols][ja3s]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 524287) {

          dissect {
            id => "dissect_zeek_ssl_v1_without_ja3"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ssl_version]}	%{[zeek_cols][cipher]}	%{[zeek_cols][curve]}	%{[zeek_cols][server_name]}	%{[zeek_cols][resumed]}	%{[zeek_cols][last_alert]}	%{[zeek_cols][next_protocol]}	%{[zeek_cols][established]}	%{[zeek_cols][ssl_history]}	%{[zeek_cols][cert_chain_fps]}	%{[zeek_cols][client_cert_chain_fps]}	%{[zeek_cols][sni_matches_cert]}	%{[zeek_cols][validation_status]}"
            }
          }

        } else {
          # who knows? the ssl.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ssl_v1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ssl.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ssl_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ssl.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ssl_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ssl"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ssl"
        init => "$zeek_ssl_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'ssl_version', 'cipher', 'curve', 'server_name', 'resumed', 'last_alert', 'next_protocol', 'established', 'ssl_history', 'cert_chain_fps', 'client_cert_chain_fps', 'sni_matches_cert', 'validation_status', 'ja3', 'ja3s' ]"
        code => "event.set('[zeek_cols]', $zeek_ssl_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ssl"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tls"
      }
    }

  } else if ([log_source] == "stun") {
    #############################################################################################################################
    # stun.log
    # https://github.com/corelight/zeek-spicy-stun/blob/master/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_stun"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][trans_id]}	%{[zeek_cols][method]}	%{[zeek_cols][class]}	%{[zeek_cols][attr_type]}	%{[zeek_cols][attr_val]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_stun"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_stun"
        init => "$zeek_stun_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'is_orig', 'trans_id', 'method', 'class', 'attr_type', 'attr_val' ]"
        code => "event.set('[zeek_cols]', $zeek_stun_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_stun"
      add_field => {
        "[zeek_cols][service]" => "stun"
      }
    }

  } else if ([log_source] == "stun_nat") {
    #############################################################################################################################
    # stun.log
    # https://github.com/corelight/zeek-spicy-stun/blob/master/analyzer/main.zeek

    dissect {
      id => "dissect_zeek_stun_nat"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][wan_addr]}	%{[zeek_cols][wan_port]}	%{[zeek_cols][lan_addr]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_stun_nat"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_stun_nat"
        init => "$zeek_stun_nat_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'is_orig', 'wan_addr', 'wan_port', 'lan_addr' ]"
        code => "event.set('[zeek_cols]', $zeek_stun_nat_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_stun_nat"
      add_field => {
        "[zeek_cols][service]" => "stun"
      }
    }

  } else if ([log_source] == "syslog") {
    #############################################################################################################################
    # syslog.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/syslog/main.zeek.html#type-Syslog::Info

    dissect {
      id => "dissect_zeek_syslog"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][facility]}	%{[zeek_cols][severity]}	%{[zeek_cols][message]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_syslog"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_syslog"
        init => "$zeek_syslog_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'facility', 'severity', 'message' ]"
        code => "event.set('[zeek_cols]', $zeek_syslog_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_syslog"
      add_field =>  { "[zeek_cols][service]" => "syslog" }
    }

  } else if ([log_source] == "tds") {
    #############################################################################################################################
    # tds.log
    # https://github.com/amzn/zeek-plugin-tds/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_tds"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][command]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds"
        init => "$zeek_tds_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'command' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([log_source] == "tds_rpc") {
    #############################################################################################################################
    # tds_rpc.log
    # https://github.com/amzn/zeek-plugin-tds/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_tds_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][procedure_name]}	%{[zeek_cols][parameter]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds_rpc"
        init => "$zeek_tds_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'procedure_name', 'parameter' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds_rpc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([log_source] == "tds_sql_batch") {
    #############################################################################################################################
    # tds_sql_batch.log
    # https://github.com/amzn/zeek-plugin-tds/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_tds_sql_batch"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][header_type]}	%{[zeek_cols][query]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds_sql_batch"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds_sql_batch"
        init => "$zeek_tds_sql_batch_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'header_type', 'query' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_sql_batch_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds_sql_batch"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([log_source] == "tftp") {
    #############################################################################################################################
    # tftp.log
    # https://github.com/zeek/spicy-tftp

    dissect {
      id => "dissect_zeek_tftp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][wrq]}	%{[zeek_cols][fname]}	%{[zeek_cols][mode]}	%{[zeek_cols][uid_data]}	%{[zeek_cols][size]}	%{[zeek_cols][block_sent]}	%{[zeek_cols][block_acked]}	%{[zeek_cols][error_code]}	%{[zeek_cols][error_msg]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tftp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tftp"
        init => "$zeek_tftp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'wrq', 'fname', 'mode', 'uid_data', 'size', 'block_sent', 'block_acked', 'error_code', 'error_msg' ]"
        code => "event.set('[zeek_cols]', $zeek_tftp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tftp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "tftp"
      }
    }

  } else if ([log_source] == "tunnel") {
    #############################################################################################################################
    # tunnel.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/tunnels/main.zeek.html#type-Tunnel::Info

    dissect {
      id => "dissect_zeek_tunnel"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][tunnel_type]}	%{[zeek_cols][action]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tunnel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tunnel"
        init => "$zeek_tunnel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'tunnel_type', 'action' ]"
        code => "event.set('[zeek_cols]', $zeek_tunnel_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_gsub_zeek_tunnel_action"
             gsub => [ "[zeek_cols][action]", "Tunnel::", "" ] }

    mutate { id => "mutate_gsub_zeek_tunnel_type"
             gsub => [ "[zeek_cols][tunnel_type]", "Tunnel::", "" ] }

    mutate {
      id => "mutate_add_fields_zeek_tunnel"
      add_field =>  { "[zeek_cols][service]" => "%{[zeek_cols][tunnel_type]}" }
    }

    mutate { id => "mutate_lowercase_zeek_tunnel_service"
             lowercase => [ "[zeek_cols][service]" ] }

  } else if ([log_source] == "weird") {
    #############################################################################################################################
    # weird.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/notice/weird.zeek.html#type-Weird::Info

    dissect {
      id => "dissect_zeek_weird"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][name]}	%{[zeek_cols][addl]}	%{[zeek_cols][notice]}	%{[zeek_cols][peer]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_weird"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_weird"
        init => "$zeek_weird_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'name', 'addl', 'notice', 'peer' ]"
        code => "event.set('[zeek_cols]', $zeek_weird_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([log_source] == "x509") {
    #############################################################################################################################
    # x509.log
    # https://docs.zeek.org/en/stable/scripts/base/files/x509/main.zeek.html#type-X509::Info

    dissect {
      id => "dissect_zeek_x509_v1"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fingerprint]}	%{[zeek_cols][certificate_version]}	%{[zeek_cols][certificate_serial]}	%{[zeek_cols][certificate_subject]}	%{[zeek_cols][certificate_issuer]}	%{[zeek_cols][certificate_not_valid_before]}	%{[zeek_cols][certificate_not_valid_after]}	%{[zeek_cols][certificate_key_alg]}	%{[zeek_cols][certificate_sig_alg]}	%{[zeek_cols][certificate_key_type]}	%{[zeek_cols][certificate_key_length]}	%{[zeek_cols][certificate_exponent]}	%{[zeek_cols][certificate_curve]}	%{[zeek_cols][san_dns]}	%{[zeek_cols][san_uri]}	%{[zeek_cols][san_email]}	%{[zeek_cols][san_ip]}	%{[zeek_cols][basic_constraints_ca]}	%{[zeek_cols][basic_constraints_path_len]}	%{[zeek_cols][host_cert]}	%{[zeek_cols][client_cert]}"
      }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_x509"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_x509"
        init => "$zeek_x509_field_names = [ 'ts', 'fuid', 'certificate_version', 'certificate_serial', 'certificate_subject', 'certificate_issuer', 'certificate_not_valid_before', 'certificate_not_valid_after', 'certificate_key_alg', 'certificate_sig_alg', 'certificate_key_type', 'certificate_key_length', 'certificate_exponent', 'certificate_curve', 'san_dns', 'san_uri', 'san_email', 'san_ip', 'basic_constraints_ca', 'basic_constraints_path_len', 'host_cert', 'client_cert' ]"
        code => "event.set('[zeek_cols]', $zeek_x509_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_x509"
             add_field => { "[zeek_cols][service]" => "X.509" } }

  } else {

    if ([log_source] =~ /\.\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2}$/) {
      # filebeat caught a file right in the middle of being renamed/moved (ie., renamed from conn.log to
      # conn.2020-01-16-14-00-00.log). this has actually already been processed, so ignore this event.
      drop { id => "drop_renamed_logfile" }

    } else {
      # some other unknown zeek log file. should start with ts at least!
      csv {
        id => "csv_zeek_unknown"
        columns => [
          "ts"]

        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        separator => "	"
        # there's no way to *disable* the csv quote char, so set it to something we'll never see
        quote_char => ""

        target => "[zeek_cols]"
      }

      mutate { id => "mutate_add_tag_zeek_unknown"
               add_tag => [ "_unknown_log_type" ] }
    }

  } # if / else if for source type (conn.log, dns.log, etc.)

  if ([zeek_cols]) {
    # remove unset (-) or "(empty)" top-level field values
    ruby {
      id => "ruby_zeek_remove_empty_values"
      path => "/usr/share/logstash/malcolm-ruby/compact_event.rb"
    }
  } else {
    drop { id => "drop_dissect_error" }
  }

  # ECS - "zeek" -> event.provider
  if (![event][provider]) { mutate { id => "mutate_add_field_event_provider_zeek"
                                     add_field => { "[event][provider]" => "zeek" } } }

  # rename the zeek child array to match the log type
  mutate { id => "mutate_rename_zeek_log_type"
           rename => { "[zeek_cols]" => "[zeek][%{[log_source]}]" } }

  # move "up" some fields that are considered to be "multi-log" fields (eg., they
  # show up in many types of logs)
  mutate {
    id => "mutate_rename_zeek_common_fields"
    rename => { "[zeek][%{[log_source]}][ts]"              => "[zeek][ts]" }
    rename => { "[zeek][%{[log_source]}][uid]"             => "[zeek][uid]" }
    rename => { "[zeek][%{[log_source]}][fuid]"            => "[zeek][fuid]" }
    rename => { "[zeek][%{[log_source]}][orig_h]"          => "[source][ip]" }
    rename => { "[zeek][%{[log_source]}][orig_p]"          => "[source][port]" }
    rename => { "[zeek][%{[log_source]}][orig_l2_addr]"    => "[source][mac]" }
    rename => { "[zeek][%{[log_source]}][resp_h]"          => "[destination][ip]" }
    rename => { "[zeek][%{[log_source]}][resp_p]"          => "[destination][port]" }
    rename => { "[zeek][%{[log_source]}][resp_l2_addr]"    => "[destination][mac]" }
    rename => { "[zeek][%{[log_source]}][proto]"           => "[network][transport]" }
    rename => { "[zeek][%{[log_source]}][service]"         => "[network][protocol]" }
    rename => { "[zeek][%{[log_source]}][user]"            => "[related][user]" }
    rename => { "[zeek][%{[log_source]}][password]"        => "[related][password]" }
    rename => { "[zeek][%{[log_source]}][community_id]"    => "[network][community_id]" }
  }

  # create a repeatable fingerprint for document ID
  fingerprint {
    id => "fingerprint_zeek_event_hash"
    source => [ "[event][provider]",
                "[log_source]",
                "[zeek][ts]",
                "[network][community_id]",
                "[zeek][uid]",
                "[zeek][fuid]",
                "[log][offset]" ]
    concatenate_sources => true
    # uses event.hash
    ecs_compatibility => "v8"
    method => "MURMUR3_128"
    base64encode => true
  }

  if ([source][mac]) {
    mutate { id => "mutate_split_zeek_source_mac"
             split => { "[source][mac]" => "," } }
  }

  if ([destination][mac]) {
    mutate { id => "mutate_split_zeek_destination_mac"
             split => { "[destination][mac]" => "," } }
  }

  if ([zeek][uid]) {
    # set zeek connection UID as "rootId" (see logstash.conf output section)
    if (![rootId]) { mutate { id => "mutate_add_field_zeek_rootId"
                              add_field => { "[rootId]" => "%{[zeek][uid]}" } } }

    # ECS - zeek.uid -> event.id
    mutate { id => "mutate_add_field_ecs_id_uid"
             merge => { "[event][id]" => "[zeek][uid]" } }
  }

  # if present, FUIDs are always a vector (comma-separated)
  if ([zeek][fuid]) { mutate { id => "mutate_split_zeek_fuids"
                               split => { "[zeek][fuid]" => "," } } }

  if ([zeek][ts]) {

    if ([zeek][ts] == "0.000000") {
      # missing packet timestamp, set to "now." not sure what a better option would be
      ruby {
        id => "ruby_zeek_empty_timestamp_set"
        init => "require 'time'"
        code => "event.set('[zeek][ts]', Time.now.to_f)"
      }
      mutate { id => "tag_zeek_empty_timestamp_set"
               add_tag => [ "_missing_timestamp" ] }
    }

    # set firstPacket to timestamp, lastPacket to timestamp + duration
    # timestamp, firstPacket, lastPacket are UNIX epoch milliseconds
    ruby {
      id => "ruby_zeek_timestamp_calc"
      init => "require 'time'"
      code => "msTime = (1000*event.get('[zeek][ts]').to_f).round(0)
               event.set('[timestamp]', msTime)
               event.set('[@timestamp]', LogStash::Timestamp.at(Time.strptime(msTime.to_s, '%Q')))
               event.set('[firstPacket]', msTime)"
    }

    if ([zeek][conn]) and ([zeek][conn][duration]) {
      # convert duration (floating-point seconds) to milliseconds
      ruby {
        id => "ruby_zeek_duration_calc"
        code => "event.set('[length]', (1000*event.get('[zeek][conn][duration]').to_f).round(0))
                 event.set('[lastPacket]', event.get('[timestamp]').to_i + event.get('[length]').to_i)"
      }
      # ECS - zeek.conn.duration -> event.duration
      ruby {
        id => "ruby_zeek_duration_to_ecs_event_duration"
        code => "event.set('[event][duration]', (1000000000 * event.get('[zeek][conn][duration]').to_f).round(0))"
      }
    } else {
      mutate { id => "mutate_add_field_zeek_lastPacket"
               add_field => { "[lastPacket]" => "%{timestamp}" } }
      mutate { id => "mutate_add_field_zeek_length"
               add_field => { "[length]" => "0" } }
    }

    # set the ts back as something more readable
    mutate { id => "mutate_replace_zeek_ts"
             replace => { "[zeek][ts]" => "%{[@timestamp]}" } }
  } # if ([zeek][ts])

  # set user and transport- and application-level protocols if specified
  if ([related][user]) {
    mutate { id => "mutate_split_related_user"
             split => { "[related][user]" => "," } }
  }
  if ([network][transport]) {
    translate {
      id => "translate_zeek_proto"
      source => "[network][transport]"
      target => "[ipProtocol]"
      dictionary_path => "/etc/ip_protocol_name_to_number.yaml"
    }
    mutate { id => "mutate_split_zeek_proto"
             split => { "[network][transport]" => "," } }
    mutate { id => "mutate_merge_zeek_proto"
             merge => { "[protocol]" => "[network][transport]" } }
  }

  if ([network][protocol]) {
    mutate { id => "mutate_split_zeek_service"
             split => { "[network][protocol]" => "," } }
  }

  if ([log_source] == "conn") {
    #############################################################################################################################
    # conn.log specific logic

    translate {
      id => "translate_zeek_conn_state"
      source => "[zeek][conn][conn_state]"
      target => "[zeek][conn][conn_state_description]"
      dictionary_path => "/etc/conn_states.yaml"
      # TODO: can we normalize this with suricata.flow.state somewhere?
    }

    mutate { id => "mutate_split_zeek_conn_tunnel_parents"
             split => { "[zeek][conn][tunnel_parents]" => "," } }

    if ([zeek][conn][vlan] or [zeek][conn][inner_vlan]) {
      # ECS - zeek.conn.vlan -> network.vlan.id
      if ([zeek][conn][vlan]) {
        mutate { id => "mutate_merge_zeek_conn_vlan"
                 merge => { "[network][vlan][id]" => "[zeek][conn][vlan]" } }
      }
      if ([zeek][conn][inner_vlan]) {
        # ECS - zeek.conn.inner_vlan -> network.inner.vlan.id
        mutate { id => "mutate_merge_zeek_conn_inner_vlan"
                 merge => { "[network][inner][vlan][id]" => "[zeek][conn][inner_vlan]" } }
      }
    }

    # aggregate total bytes and packets
    ruby {
      id => "ruby_zeek_bytes_and_packets_calc"
      code => "event.set('[totDataBytes]', event.get('[client][bytes]').to_i + event.get('[server][bytes]').to_i)
               event.set('[network][bytes]', event.get('[source][bytes]').to_i + event.get('[destination][bytes]').to_i)
               event.set('[network][packets]', event.get('[source][packets]').to_i + event.get('[destination][packets]').to_i)"
    }

    if ([zeek][conn][history]) {
      ruby {
        id => "ruby_zeek_conn_history"
        # see https://www.zeek.org/sphinx/scripts/base/protocols/conn/main.bro.html#type-Conn::Info
        code => "historyStr = event.get('[zeek][conn][history]').upcase
                 sCnt = historyStr.count('S')
                 hCnt = historyStr.count('H')
                 aCnt = historyStr.count('A')
                 fCnt = historyStr.count('F')
                 rCnt = historyStr.count('R')
                 event.set('[tcpflags][syn]',     10**(sCnt-1)) if sCnt > 0
                 event.set('[tcpflags][syn-ack]', 10**(hCnt-1)) if hCnt > 0
                 event.set('[tcpflags][ack]',     10**(aCnt-1)) if aCnt > 0
                 event.set('[tcpflags][fin]',     10**(fCnt-1)) if fCnt > 0
                 event.set('[tcpflags][rst]',     10**(rCnt-1)) if rCnt > 0"
      }
    }

  } else if ([log_source] == "bacnet_discovery") {
    #############################################################################################################################
    # bacnet_discovery.log specific logic

    # bacnet_discovery.range ccan be split into a min/max (All, 12345-12350, etc.)
    if ([zeek][bacnet_discovery][range]) {
      if ([zeek][bacnet_discovery][range] == "All") {
        mutate { id => "mutate_add_field_zeek_bacnet_discovery_range_low"
                 add_field => { "[zeek][bacnet_discovery][range_low]" => "0" } }
        mutate { id => "mutate_add_field_zeek_bacnet_discovery_range_high"
                 add_field => { "[zeek][bacnet_discovery][range_high]" => "4194300" } }
      } else if ([zeek][bacnet_discovery][range] =~ "^\d+-\d+$") {
        ruby {
          id => "ruby_bacnet_discovery_range_split"
          code => "
            if (bacnetRange = event.get('[zeek][bacnet_discovery][range]').split('-')) and (bacnetRange.length == 2) then
              event.set('[zeek][bacnet_discovery][range_low]', bacnetRange[0])
              event.set('[zeek][bacnet_discovery][range_high]', bacnetRange[1])
            end"
        }
      }
    }

  } else if ([log_source] == "bsap_ip_rdb") {
    #############################################################################################################################
    # bsap_ip_rdb.log specific logic

    ruby {
      id => "ruby_bsap_ip_rdb_variables"
      init => "$bsap_ip_rdb_fields = [ :var, :val ]"
      code => "
        vars = event.get('[zeek][bsap_ip_rdb][variables]').to_s.split(',').zip(
                    event.get('[zeek][bsap_ip_rdb][variable_value]').to_s.split(',')).map{ |x| $bsap_ip_rdb_fields.zip(x).to_h }
        event.set('[zeek][bsap_ip_rdb][variables]', vars)
        event.set('[zeek][bsap_ip_rdb][variable_count]', vars.length)
      "
    }
    mutate { id => "mutate_remove_field_zeek_bsap_ip_rdb_variable_value"
             remove_field => [ "[zeek][bsap_ip_rdb][variable_value]",
                               "[zeek][bsap_ip_rdb][data_len]" ] }


  } else if ([log_source] == "bsap_serial_rdb") {
    #############################################################################################################################
    # bsap_serial_rdb.log specific logic

    ruby {
      id => "ruby_bsap_serial_rdb_variables"
      init => "$bsap_serial_rdb_fields = [ :var, :val ]"
      code => "
        vars = event.get('[zeek][bsap_serial_rdb][variables]').to_s.split(',').zip(
                    event.get('[zeek][bsap_serial_rdb][variable_value]').to_s.split(',')).map{ |x| $bsap_serial_rdb_fields.zip(x).to_h }
        event.set('[zeek][bsap_serial_rdb][variables]', vars)
        event.set('[zeek][bsap_serial_rdb][variable_count]', vars.length)
      "
    }
    mutate { id => "mutate_remove_field_zeek_bsap_serial_rdb_variable_value"
             remove_field => [ "[zeek][bsap_serial_rdb][variable_value]",
                               "[zeek][bsap_serial_rdb][data_len]" ] }


  } else if ([log_source] == "cip_identity") {
    #############################################################################################################################
    # cip_identity.log specific logic

    if ([zeek][cip_identity][socket_address]) {

      # if this is a zeek_cip_identity record with socket_address, ASN/GeoIP it as well
      geoip {
        id => "geoip_zeek_cip_identity_socket_address"
        default_database_type => "ASN"
        source => "[zeek][cip_identity][socket_address]"
        target => "[@metadata][zeek_cip_identity_asn]"
      }
      if ([@metadata][zeek_cip_identity_asn] and [@metadata][zeek_cip_identity_asn][as_org] and [@metadata][zeek_cip_identity_asn][asn]) {
        # this is stupid, the %{} doesn't seem to be liked by mutate.merge
        mutate { id => "mutate_add_field_zeek_cip_identity_asn"
                 add_field => { "[@metadata][cip_asn_str]" => "AS%{[@metadata][zeek_cip_identity_asn][asn]} %{[@metadata][zeek_cip_identity_asn][as_org]}" } }
        mutate { id => "mutate_merge_zeek_cip_identity_asn"
                 merge => { "[zeek][cip_identity][socket_address_asn]" => "[@metadata][cip_asn_str]" } }
      }
      geoip {
        id => "geoip_zeek_cip_identity_socket_address_geo"
        source => "[zeek][cip_identity][socket_address]"
        target => "[zeek][cip_identity][socket_address_geo]"
      }

    }

  } else if ([log_source] == "dhcp") {
    #############################################################################################################################
    # dhcp.log specific logic

    if ([source][mac]) {
      mutate {
        id => "mutate_add_fields_zeek_dhcp_mac"
        add_field =>  { "[zeek][dhcp][mac]" => "%{[source][mac]}" }
      }
      mutate { id => "mutate_merge_zeek_dhcp_mac"
               merge => { "[dhcp][mac]" => "[source][mac]" } }
    }

    if ([zeek][dhcp][msg_types]) {
      mutate { id => "mutate_split_zeek_dhcp_msg_types"
                 split => { "[zeek][dhcp][msg_types]" => "," } }
      ruby {
        id => "ruby_zeek_dhcp_msg_types"
        path => "/usr/share/logstash/malcolm-ruby/make_unique_array.rb"
        script_params => {
          "field" => "[zeek][dhcp][msg_types]"
        }
      }
      mutate { id => "mutate_merge_zeek_dhcp_type"
               merge => { "[dhcp][type]" => "[zeek][dhcp][msg_types]" } }
    }

    if ([zeek][dhcp][trans_id]) {
      mutate { id => "mutate_merge_zeek_dhcp_id"
               merge => { "[dhcp][id]" => "[zeek][dhcp][trans_id]" } }
    }

    if ([zeek][dhcp][host_name]) {
      mutate { id => "mutate_merge_zeek_dhcp_host_name"
               merge => { "[dhcp][host]" => "[zeek][dhcp][host_name]" } }

      # ECS - zeek.dhcp.host_name -> client.domain
      mutate { id => "mutate_add_field_ecs_client_domain_dhcp_host_name"
               add_field => { "[client][domain]" => "%{[zeek][dhcp][host_name]}" } }
    }

    if ([zeek][dhcp][domain]) {
      # ECS - zeek.dhcp.domain -> client.domain
      mutate { id => "mutate_add_field_ecs_client_domain_dhcp_domain"
               add_field => { "[client][domain]" => "%{[zeek][dhcp][domain]}" } }
    }

    if ([zeek][dhcp][client_fqdn]) {
      # ECS - zeek.dhcp.client_fqdn -> client.domain
      mutate { id => "mutate_add_field_ecs_client_domain_dhcp_client_fqdn"
               add_field => { "[client][domain]" => "%{[zeek][dhcp][client_fqdn]}" } }
    }

    if ([zeek][dhcp][assigned_ip]) {
      mutate { id => "mutate_merge_zeek_dhcp_host"
               merge => { "[dhcp][host]" => "[zeek][dhcp][assigned_ip]" } }
    }

  } else if ([log_source] == "dnp3") {
    #############################################################################################################################
    # dnp3.log specific logic

    # translate IIN bitmap (least significant bit = zeek_dnp3_iin_flags[0], etc.)
    # reference: https://raw.githubusercontent.com/wireshark/wireshark/master/epan/dissectors/packet-dnp.c (search IIN)
    ruby {
      id => "ruby_parse_dnp3_iin"
      init => "$zeek_dnp3_iin_flags = [ 'Function Code not Implemented', 'Requested Objects Unknown', 'Parameters Invalid or Out of Range', 'Event Buffer Overflow', 'Operation Already Executing', 'Configuration Corrupt', 'Reserved', 'Reserved', 'Broadcast Msg Rx', 'Class 1 Data Available', 'Class 2 Data Available', 'Class 3 Data Available', 'Time Sync Required', 'Digital Outputs in Local', 'Device Trouble', 'Device Restart' ]"
      code => "
        iinNum = event.get('[zeek][dnp3][iin]').to_i
        if (iinNum > 0) then
          iinFlags = Array.new
          $zeek_dnp3_iin_flags.each_with_index do |val, idx|
            iinFlags.push(val) if (iinNum[idx] == 1)
          end
          event.set('[zeek][dnp3][iin_flags]', iinFlags)
        end"
    }

  } else if ([log_source] == "dns") {
    #############################################################################################################################
    # dns.log specific logic

    mutate { id => "mutate_split_zeek_dns_TTLs"
               split => { "[zeek][dns][TTLs]" => "," } }

    # this must be done because [dns][ip] only handles IPv4 or IPv6 addresses
    # but [answers] can contain hostnames as well
    if ([zeek][dns][answers]) {
      ruby {
        id => "ruby_zeek_dns_answers_ip_extract"
        # todo: adjust this regex so it at least sort of catches IPv6 as well
        code => "event.set('[@metadata][answers_ip]', event.get('[zeek][dns][answers]').scan(/\d+\.\d+\.\d+\.\d+/).join(','))"
      }
      mutate { id => "mutate_split_zeek_dns_answers"
               split => { "[zeek][dns][answers]" => "," } }
      mutate { id => "mutate_split_zeek_dns_answers_ip"
               split => { "[@metadata][answers_ip]" => "," } }
      # ECS - zeek.dns -> dns.answers
      ruby {
        id => "ruby_zeek_dns_answers_to_ecs"
        code => '
          event.set("[dns][answers]", [Array(event.get("[zeek][dns][answers]")), Array(event.get("[zeek][dns][TTLs]"))].transpose.map{ |d| Hash[[:data, :ttl].zip(d)] })
      '}
      mutate { id => "mutate_add_field_ecs_dns_type_answer"
               add_field => { "[dns][type]" => "answer" } }
    }

    if ([zeek][dns][query]) {
      mutate { id => "mutate_merge_zeek_query"
               merge => { "[dns][host]" => "[zeek][dns][query]" } }
      ruby { id => "ruby_add_field_zeek_dns_opcode"
             code => "event.set('[dns][opcode]', [ 'QUERY', event.get('[dns][opcode]') ].flatten.compact)" }
    }

    if ([@metadata][answers_ip]) {
      mutate { id => "mutate_merge_zeek_dns_ip"
               merge => { "[dns][ip]" => "[@metadata][answers_ip]" } }
      # ECS  dns.ip -> dns.resolved_ip
      mutate { id => "mutate_merge_ecs_dhs_resolved_ip"
               merge => { "[dns][resolved_ip]" => "[dns][ip]" } }
    }

    if ([zeek][dns][qclass_name]) {
      mutate { id => "mutate_merge_zeek_dns_qc"
               merge => { "[dns][qc]" => "[zeek][dns][qclass_name]" } }
    }

    if ([zeek][dns][qtype_name]) {
      mutate { id => "mutate_merge_zeek_dns_qt"
               merge => { "[dns][qt]" => "[zeek][dns][qtype_name]" } }
    }

    # dns.op_code
    if ([dns][opcode]) {                          mutate { id => "mutate_add_field_ecs_dns_opcode"
                                                           add_field => { "[dns][op_code]" => "%{[dns][opcode]}" } } }

    # dns.question.class
    if ([zeek][dns][qclass_name]) {                mutate { id => "mutate_add_field_ecs_dns_qclass"
                                                           add_field => { "[dns][question][class]" => "%{[zeek][dns][qclass_name]}" } } }

    # dns.question.type
    if ([zeek][dns][qtype_name]) {                 mutate { id => "mutate_add_field_ecs_dns_qtype"
                                                           add_field => { "[dns][question][type]" => "%{[zeek][dns][qtype_name]}" } } }

    # dns.question.name and dns.type:query
    if ([zeek][dns][query]) {
                          mutate { id => "mutate_add_field_ecs_dns_query"
                                   add_field => { "[dns][question][name]" => "%{[zeek][dns][query]}" } }
      if (![dns][type]) { mutate { id => "mutate_add_field_ecs_dns_type_query"
                                   add_field => { "[dns][type]" => "query" } } }
    }

    if ([dns][type]) {
      # dns.header_flags
      if ([zeek][AA] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_aa"
                                                           add_field => { "[dns][header_flags]" => "AA" } } }
      if ([zeek][TC] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_tc"
                                                           add_field => { "[dns][header_flags]" => "TC" } } }
      if ([zeek][RD] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_rd"
                                                           add_field => { "[dns][header_flags]" => "RD" } } }
      if ([zeek][RA] == "T") {                    mutate { id => "mutate_add_field_ecs_dns_header_flag_ra"
                                                           add_field => { "[dns][header_flags]" => "RA" } } }
    }

    # dns.response_code
    if ([zeek][dns][rcode_name]) {                 mutate { id => "mutate_add_field_ecs_dns_response_code"
                                                           add_field => { "[dns][response_code]" => "%{[zeek][dns][rcode_name]}" } } }

    # dns.id
    if ([zeek][dns][trans_id]) {                   mutate { id => "mutate_add_field_ecs_dns_id"
                                                           add_field => { "[dns][id]" => "%{[zeek][dns][trans_id]}" } } }

    # TODO: domain stuff (dns.question.registered_domain, dns.question.subdomain, dns.question.top_level_domain)
    # perhaps use something like https://github.com/plutonbacon/logstash-filter-publicsuffix

  } else if ([log_source] == "files") {
    #############################################################################################################################
    # files.log specific logic

    # translate Zeek's double-backslashes single backslash in filenames
    ruby {
      id => "ruby_zeek_files_filename_dedoubleslash"
      path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
      script_params => {
        "source" => "[zeek][files][filename]"
        "target" => "[zeek][files][filename]"
      }
    }

    if ([zeek][files][total_bytes]) {
      ruby {
        id => "ruby_zeek_files_totBytes"
        code => "event.set('[network][bytes]', event.get('[zeek][files][total_bytes]').to_i)"
      }
    }
    if ([zeek][files][seen_bytes]) {
      ruby {
        id => "ruby_zeek_files_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek][files][seen_bytes]').to_i)"
      }
    }

    if ([zeek][files][parent_fuid]) { mutate { id => "mutate_split_zeek_files_parent_fuid"
                                              split => { "[zeek][files][parent_fuid]" => "," } } }

    if ([zeek][files][analyzers]) { mutate { id => "mutate_split_zeek_files_analyzers"
                                            split => { "[zeek][files][analyzers]" => "," } } }

    if ([zeek][files][source]) {

      # do some normalization on files source
      mutate { id => "mutate_gsub_field_zeek_files_source_spicy_suffix"
               gsub => [ "[zeek][files][source]", "_(TCP|UDP|DATA)$", "" ] }
      mutate { id => "mutate_gsub_field_zeek_files_source_spicy_prefix"
               gsub => [ "[zeek][files][source]", "^SPICY_", "" ] }

      if ([zeek][files][source] =~ /^XOR decrypted from /) {
        # PE_XOR plugin writes source as "XOR decrypted from FM7Tr545kxt3ofR7x2-"..., let's
        # standardize that to just "XOR decrypted" and put the source fuid in parent_fuid
        grok {
          id => "grok_zeek_files_source_xor"
          match => { "[zeek][files][source]" => [ "decrypted%{SPACE}from%{SPACE}%{WORD:[@metadata][source_xor_fuid]}" ] }
        }
        if ([@metadata][source_xor_fuid]) { mutate { id => "mutate_merge_zeek_files_source_xor_parent_fuid"
                                                     merge => { "[zeek][files][parent_fuid]" => "[@metadata][source_xor_fuid]" } } }
        mutate { id => "mutate_replace_zeek_files_source_xor"
                 replace => { "[zeek][files][source]" => "XOR decrypted" } }

      } else if ([zeek][files][source] == "SSL") {
        # SSL->TLS to match up with what the service field has for cross-referencing
        mutate { id => "mutate_replace_zeek_files_source_ssl_to_tls"
                 replace => { "[zeek][files][source]" => "TLS" } }
      }
    }

    # ECS - "file" -> file.type
    mutate { id => "mutate_add_field_ecs_file_type"
             add_field => { "[file][type]" => "file" } }

    # ECS -> zeek_files.total_bytes -> file.size
    if ([zeek][files][total_bytes]) {  mutate { id => "mutate_add_field_ecs_files_size"
                                      add_field => { "[file][size]" => "%{[zeek][files][total_bytes]}" } } }

    # ECS -> zeek_files.(md5|sha1|sha256) -> file.hash.(md5|sha1|sha256)
    if ([zeek][files][md5]) {          mutate { id => "mutate_add_field_ecs_files_hash_md5"
                                      add_field => { "[file][hash][md5]" => "%{[zeek][files][md5]}" } } }
    if ([zeek][files][sha1]) {         mutate { id => "mutate_add_field_ecs_files_hash_sha1"
                                      add_field => { "[file][hash][sha1]" => "%{[zeek][files][sha1]}" } } }
    if ([zeek][files][sha256]) {       mutate { id => "mutate_add_field_ecs_files_hash_sha256"
                                      add_field => { "[file][hash][sha256]" => "%{[zeek][files][sha256]}" } } }

  } else if ([log_source] == "ftp") {
    #############################################################################################################################
    # ftp.log specific logic

    if ([zeek][ftp][file_size]) {
      ruby {
        id => "ruby_zeek_ftp_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek][ftp][file_size]').to_i)"
      }
    }

  } else if ([log_source] == "genisys") {
    #############################################################################################################################
    # genisys.log specific logic

    ruby {
      id => "ruby_genisys_payload"
      init => "$genisys_fields = [ :address, :data ]"
      code => "
        vars = event.get('[zeek][genisys][payload_raw]').to_s.split(',').map{ |x| x.split('=') }.map{ |x| $genisys_fields.zip(x).to_h }
        event.set('[zeek][genisys][payload]', vars) unless vars.nil? or (vars.length == 0)
      "
    }
    mutate { id => "mutate_remove_genisys_payload_raw"
             remove_field => [ "[zeek][genisys][payload_raw]" ] }

  } else if ([log_source] == "gquic") {
    #############################################################################################################################
    # gquic.log specific logic

    if ([zeek][gquic][user_agent]) {
      mutate { id => "mutate_merge_zeek_quic_useragent"
               merge => { "[quic][useragent]" => "[zeek][gquic][user_agent]" } }
    }

    if ([zeek][gquic][server_name]) {
      mutate { id => "mutate_merge_zeek_quic_host"
               merge => { "[quic][host]" => "[zeek][gquic][server_name]" } }
    }

    if ([zeek][gquic][version]) {
      ruby {
        id => "ruby_zeek_set_quic_version"
        code => "event.set('[quic][version]', 'Q' + event.get('[zeek][gquic][version]').rjust(3, '0'))"
      }
    }


  } else if ([log_source] == "http") {
    #############################################################################################################################
    # http.log specific logic

    mutate { id => "mutate_split_zeek_http_orig_fuids"
             split => { "[zeek][http][orig_fuids]" => "," } }
    mutate { id => "mutate_split_zeek_http_orig_filenames"
             split => { "[zeek][http][orig_filenames]" => "," } }
    mutate { id => "mutate_split_zeek_http_orig_mime_types"
             split => { "[zeek][http][orig_mime_types]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_fuids"
             split => { "[zeek][http][resp_fuids]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_filenames"
             split => { "[zeek][http][resp_filenames]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_mime_types"
             split => { "[zeek][http][resp_mime_types]" => "," } }
    mutate { id => "mutate_split_zeek_http_proxied"
             split => { "[zeek][http][proxied]" => "," } }

    # translate Zeek's double-backslashes single backslash in filenames
    ruby {
      id => "ruby_zeek_http_orig_filenames_dedoubleslash"
      path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
      script_params => {
        "source" => "[zeek][http][orig_filenames]"
        "target" => "[zeek][http][orig_filenames]"
      }
    }
    ruby {
      id => "ruby_zeek_http_resp_filenames_dedoubleslash"
      path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
      script_params => {
        "source" => "[zeek][http][resp_filenames]"
        "target" => "[zeek][http][resp_filenames]"
      }
    }

    if ([zeek][http][tags]) {
      # merge zeek.http.tags into tags and then remove original
      mutate { id => "mutate_split_zeek_http_tags"
               split => { "[zeek][http][tags]" => "," } }
      mutate { id => "mutate_merge_zeek_http_tags"
               merge => { "[tags]" => "[zeek][http][tags]" } }
      mutate { id => "mutate_remove_field_zeek_http_tags"
               remove_field => [ "[zeek][http][tags]" ] }
    }

    if ([zeek][http][host]) {
      mutate { id => "mutate_merge_zeek_http_host"
               merge => { "[http][host]" => "[zeek][http][host]" } }
    }

    if ([zeek][http][uri]) {
      if ([zeek][http][host]) {
        mutate { id => "mutate_add_field_metadata_http_host_and_uri"
                 add_field => { "[@metadata][http_uri]" => "%{[zeek][http][host]}%{[zeek][http][uri]}" } }
        mutate { id => "mutate_merge_zeek_http_host_and_uri"
                 merge => { "[http][uri]" => "[@metadata][http_uri]" } }
      } else {
        mutate { id => "mutate_merge_zeek_http_uri"
                 merge => { "[http][uri]" => "[zeek][http][uri]" } }
      }
    } else if ([zeek][http][referrer]) {
      mutate { id => "mutate_merge_zeek_http_referrer"
      merge => { "[http][uri]" => "[zeek][http][referrer]" } }
    }

    if ([zeek][http][user_agent]) {
      mutate { id => "mutate_merge_zeek_http_user_agent"
               merge => { "[http][useragent]" => "[zeek][http][user_agent]" } }
    }

    if ([zeek][http][orig_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_orig_mime_types"
               merge => { "[http][bodyMagic]" => "[zeek][http][orig_mime_types]" } }
      # ECS - zeek.http.orig_mime_types -> http.request.mime_type
      mutate { id => "mutate_merge_ecs_http_request_mime_type"
               merge => { "[http][request][mime_type]" => "[zeek][http][orig_mime_types]" } }
    }

    if ([zeek][http][resp_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_resp_mime_types"
               merge => { "[http][bodyMagic]" => "[zeek][http][resp_mime_types]" } }
      # ECS - zeek.http.resp_mime_types -> http.response.mime_type
      mutate { id => "mutate_merge_ecs_http_response_mime_type"
               merge => { "[http][response][mime_type]" => "[zeek][http][resp_mime_types]" } }
    }

    if ([zeek][http][version]) {
      mutate { id => "mutate_merge_zeek_http_clientVersion"
               merge => { "[http][clientVersion]" => "[zeek][http][version]" } }
    }

    if ([zeek][http][status_code]) {
      mutate { id => "mutate_merge_zeek_http_statuscode"
               merge => { "[http][statuscode]" => "[zeek][http][status_code]" } }
    }

    if ([zeek][http][method]) {
      mutate { id => "mutate_merge_zeek_http_method"
               merge => { "[http][method]" => "[zeek][http][method]" } }
    }

    if ([zeek][http][post_username]) {
      mutate { id => "mutate_merge_zeek_http_post_username_1"
               merge => { "[related][user]" => "[zeek][http][post_username]" } }
      mutate { id => "mutate_merge_zeek_http_post_username_2"
               merge => { "[user]" => "[zeek][http][post_username]" } }
    }
    if (![related][password]) and ([zeek][http][post_password_plain]) {
      mutate { id => "mutate_add_field_zeek_http_post_password_plain"
               add_field =>  { "[related][password]" => "%{[zeek][http][post_password_plain]}" } }
    }

    if ([zeek][http][response_body_len]) { mutate { id => "mutate_add_field_zeek_http_server_bytes"
                                                   add_field => { "[server][bytes]" => "%{[zeek][http][response_body_len]}" } } }
    if ([zeek][http][request_body_len]) { mutate { id => "mutate_add_field_zeek_http_client_bytes"
                                                  add_field => { "[client][bytes]" => "%{[zeek][http][request_body_len]}" } } }

    ruby {
      id => "ruby_zeek_http_totDataBytes"
      code => "event.set('[totDataBytes]', event.get('[zeek][http][response_body_len]').to_i + event.get('[zeek][http][request_body_len]').to_i)"
    }

    # ECS - zeek.http.request_body_len -> http.request.body.bytes
    if ([zeek][http][request_body_len]) {        mutate { id => "mutate_add_field_ecs_http_request_body_bytes"
                                                         add_field => { "[http][request][body][bytes]" => "%{[zeek][http][request_body_len]}" } } }
    # ECS - zeek.http.method -> http.request.method
    if ([zeek][http][method]) {                  mutate { id => "mutate_add_field_ecs_http_request_method"
                                                         add_field => { "[http][request][method]" => "%{[zeek][http][method]}" } } }
    # ECS - zeek.http.referrer -> http.request.referrer
    if ([zeek][http][referrer]) {                mutate { id => "mutate_add_field_ecs_http_request_referrer"
                                                         add_field => { "[http][request][referrer]" => "%{[zeek][http][referrer]}" } } }
    # ECS - zeek.http.response_body_len -> http.response.body.bytes
    if ([zeek][http][response_body_len]) {       mutate { id => "mutate_add_field_ecs_http_response_body_bytes"
                                                         add_field => { "[http][response][body][bytes]" => "%{[zeek][http][response_body_len]}" } } }
    # ECS - zeek.http.status_code -> http.response.status_code
    if ([zeek][http][status_code]) {             mutate { id => "mutate_add_field_ecs_http_response_status_code"
                                                         add_field => { "[http][response][status_code]" => "%{[zeek][http][status_code]}" } } }
    # ECS - zeek.http.version -> http.version
    if ([zeek][http][version]) {                 mutate { id => "mutate_add_field_ecs_http_version"
                                                         add_field => { "[http][version]" => "%{[zeek][http][version]}" } } }

    # ECS - zeek.http.host and zeek_http.uri -> url.* (https://www.elastic.co/guide/en/ecs/current/ecs-url.html)
    if ([zeek][http][uri]) or ([zeek][http][host]) {
      ruby {
        id => "ruby_ecs_uri_parse_from_zeek_http"
        init => "require 'uri'"
        code => "
          scheme = 'http'
          user = event.get('[related][user]')
          password = event.get('[related][password]')
          host = event.get('[zeek][http][host]')
          port = event.get('[destination][port]')
          uri = event.get('[zeek][http][uri]')
          ext = (uri.nil? || !(uri.include? '/')) ? nil : File.extname(uri).partition('.').last.split(/[\?#]/)[0]
          fragment = uri.nil? ? nil : uri.partition('#').last
          query = uri.nil? ? nil : uri.partition('?').last
          event.set('[url][scheme]', scheme)
          event.set('[url][original]', scheme + '://' + (host.nil? ? '' : host) + (uri.nil? ? '' : uri))
          event.set('[url][full]', scheme + '://' + (user.nil? ? '' : Array(user).first) + (password.nil? ? '' : ':' + password) + ((user.nil? && password.nil?) ? '' : '@') + (host.nil? ? '' : host) + (port.nil? ? '' : ':' + port) + (uri.nil? ? '' : uri))
          event.set('[url][domain]', host) unless host.nil?
          event.set('[url][extension]', ext) unless ext.nil? || ext.empty?
          event.set('[url][fragment]', fragment) unless fragment.nil? || fragment.empty?
          event.set('[url][password]', password) unless password.nil?
          event.set('[url][path]', uri) unless uri.nil?
          event.set('[url][port]', port) unless port.nil?
          event.set('[url][query]', query) unless query.nil? || query.empty?
          event.set('[url][username]', Array(user).first) unless user.nil?
        "
        # TODO: ECS url domain stuff (url.registered_domain, url.top_level_domain)
        # perhaps use something like https://github.com/plutonbacon/logstash-filter-publicsuffix
      }
    }

  } else if ([log_source] == "ipsec") {
    #############################################################################################################################
    # ipsec.log specific logic

    mutate { id => "mutate_split_zeek_ipsec_vendor_ids"
             split => { "[zeek][ipsec][vendor_ids]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_notify_messages"
             split => { "[zeek][ipsec][notify_messages]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_transforms"
             split => { "[zeek][ipsec][transforms]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_ke_dh_groups"
             split => { "[zeek][ipsec][ke_dh_groups]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_proposals"
             split => { "[zeek][ipsec][proposals]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_certificates"
             split => { "[zeek][ipsec][certificates]" => "," } }
    mutate { id => "mutate_split_zeek_ipsec_transform_attributes"
             split => { "[zeek][ipsec][transform_attributes]" => "," } }

    ruby {
      id => "ruby_zeek_field_ipsec_flags"
      code => '
        flags = Array.new
        if (event.get("[zeek][ipsec][flag_e]") == "T") then
          flags << "E"
        end
        if (event.get("[zeek][ipsec][flag_c]") == "T") then
          flags << "C"
        end
        if (event.get("[zeek][ipsec][flag_a]") == "T") then
          flags << "A"
        end
        if (event.get("[zeek][ipsec][flag_i]") == "T") then
          flags << "I"
        end
        if (event.get("[zeek][ipsec][flag_v]") == "T") then
          flags << "V"
        end
        if (event.get("[zeek][ipsec][flag_r]") == "T") then
          flags << "R"
        end
        if !flags.empty? then
          event.set("[zeek][ipsec][flags]", flags)
        end'
    }

  } else if ([log_source] == "irc") {
    #############################################################################################################################
    # irc.log specific logic

    if ([zeek][irc][nick]) {
      mutate { id => "mutate_merge_zeek_irc_nick"
               merge => { "[irc][nick]" => "[zeek][irc][nick]" } }
      # store "nick" alongside "user"
      mutate { id => "mutate_merge_irc_nick_user_1"
               merge => { "[related][user]" => "[zeek][irc][nick]" } }
      mutate { id => "mutate_merge_irc_nick_user_2"
               merge => { "[user]" => "[zeek][irc][nick]" } }
    }

    if ([zeek][irc][command]) and ([zeek][irc][value]) and (([zeek][irc][command] == "JOIN") or ([zeek][irc][command] == "PART")) {
      mutate { id => "mutate_merge_zeek_irc_channel"
               merge => { "[irc][channel]" => "[zeek][irc][value]" } }
    }

  } else if ([log_source] == "intel") {
    #############################################################################################################################
    # intel.log specific logic

    if ([zeek][intel][sources])  { mutate { id => "mutate_split_zeek_intel_sources"
                                            split => { "[zeek][intel][sources]" => "," } } }

    if ([zeek][intel][matched])  { mutate { id => "mutate_split_zeek_intel_matched"
                                             split => { "[zeek][intel][matched]" => "," } } }

    if ([zeek][intel][cif_tags]) { mutate { id => "mutate_split_zeek_intel_cif_tags"
                                            split => { "[zeek][intel][cif_tags]" => "," } } }

    if ([zeek][intel][sources]) or ([zeek][intel][cif_tags]) {
      ruby {
        id => "ruby_zeek_intel_sources_and_tags_comma_fix"
        code => "
          if (sources = event.get('[zeek][intel][sources]')) and (sources.length > 0) then
            sourcesAdj = Array.new
            sources.each do |val|
              sourcesAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][intel][sources]', sourcesAdj)
          end
          if (tags = event.get('[zeek][intel][cif_tags]')) and (tags.length > 0) then
            tagsAdj = Array.new
            tags.each do |val|
              tagsAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][intel][cif_tags]', tagsAdj)
          end"
      }
    }

  } else if ([log_source] == "kerberos") {
    #############################################################################################################################
    # kerberos.log specific logic

    if ([zeek][kerberos][cname]) {
      mutate { id => "mutate_merge_zeek_kerberos_cname"
               merge => { "[krb5][cname]" => "[zeek][kerberos][cname]" } }
    }

    if ([zeek][kerberos][sname]) {
      mutate { id => "mutate_merge_zeek_kerberos_sname"
               merge => { "[krb5][sname]" => "[zeek][kerberos][sname]" } }
    }

    if ([zeek][kerberos][client_cert_fuid]) { mutate { id => "mutate_split_zeek_kerberos_client_cert_fuid"
                                                      split => { "[zeek][kerberos][client_cert_fuid]" => "," } } }

    if ([zeek][kerberos][server_cert_fuid]) { mutate { id => "mutate_split_zeek_kerberos_server_cert_fuid"
                                                      split => { "[zeek][kerberos][server_cert_fuid]" => "," } } }

  } else if ([log_source] == "ldap") {
    #############################################################################################################################
    # ldap.log specific logic

    mutate { id => "mutate_split_zeek_ldap_fields"
             split => { "[zeek][ldap][operation]" => ","
                        "[zeek][ldap][result_code]" => ","
                        "[zeek][ldap][result_message]" => ","
                        "[zeek][ldap][object]" => ","
                        "[zeek][ldap][argument]" => "," } }

    if ([zeek][ldap][object]) or ([zeek][ldap][argument]) {
      ruby {
        id => "ruby_zeek_ldap_object_and_arguments_adjustment"
        code => "
          if (objects = event.get('[zeek][ldap][object]')) and (objects.length > 0) then
            objectsAdj = Array.new
            objects.each do |val|
              objectsAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][ldap][object]', objectsAdj)
          end
          if (arguments = event.get('[zeek][ldap][argument]')) and (arguments.length > 0) then
            argsAdj = Array.new
            arguments.each do |val|
              argsAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][ldap][argument]', argsAdj)
          end"
      }
    }

    # map simple bind "object" and "argument" to username and password
    # and map to Arkime types
    if ("bind simple" in [zeek][ldap][operation]) {
      if ([zeek][ldap][object]) {
        mutate { id => "mutate_merge_zeek_ldap_bind_object_user"
                 merge => { "[related][user]" => "[zeek][ldap][object]" } }
        mutate { id => "mutate_merge_ldap_bind_name"
                 merge => { "[ldap][bindname]" => "[zeek][ldap][object]" } }
      }
      if ([zeek][ldap][argument]) {
        mutate { id => "mutate_merge_zeek_ldap_bind_argument_password"
                 merge => { "[related][password]" => "[zeek][ldap][argument]" } }
      }
      mutate { id => "mutate_add_field_ldap_authtype_simple"
               add_field => { "[@metadata][ldapAuthType]" => "simple" } }
    } else if ("bind SASL" in [zeek][ldap][operation]) {
      mutate { id => "mutate_add_field_ldap_authtype_sasl"
               add_field => { "[@metadata][ldapAuthType]" => "sasl" } }
    }
    if ([@metadata][ldapAuthType]) {
      mutate { id => "mutate_merge_ldap_authtype"
               merge => { "[ldap][authtype]" => "[@metadata][ldapAuthType]" } }
    }

  } else if ([log_source] == "ldap_search") {
    #############################################################################################################################
    # ldap_search.log specific logic

    mutate { id => "mutate_split_zeek_ldap_search_fields"
             split => { "[zeek][ldap_search][scope]" => ","
                        "[zeek][ldap_search][deref]" => ","
                        "[zeek][ldap_search][attributes]" => ","
                        "[zeek][ldap_search][base_object]" => ","
                        "[zeek][ldap_search][result_code]" => ","
                        "[zeek][ldap_search][result_message]" => "," } }

    if ([zeek][ldap_search][base_object]) {
      ruby {
        id => "ruby_zeek_ldap_search_base_object_adjustment"
        code => "
          if (objects = event.get('[zeek][ldap_search][base_object]')) and (objects.length > 0) then
            objectsAdj = Array.new
            objects.each do |val|
              objectsAdj.push(val.gsub('\\x2c', ','))
            end
            event.set('[zeek][ldap_search][base_object]', objectsAdj)
          end"
      }
    }

  } else if ([log_source] == "modbus_detailed") {
    #############################################################################################################################
    # modbus_detailed.log specific logic

    if ([zeek][modbus_detailed][values]) {
      mutate { id => "mutate_split_zeek_modbus_detailed_values"
               split => { "[zeek][modbus_detailed][values]" => "," } }
    }

  } else if ([log_source] == "modbus_read_write_multiple_registers") {
    #############################################################################################################################
    # modbus_read_write_multiple_registers.log specific logic

    if ([zeek][modbus_read_write_multiple_registers][read_registers]) {
      mutate { id => "mutate_split_zeek_modbus_read_write_multiple_registers_read_registers"
               split => { "[zeek][modbus_read_write_multiple_registers][read_registers]" => "," } }
    }

    if ([zeek][modbus_read_write_multiple_registers][write_registers]) {
      mutate { id => "mutate_split_zeek_modbus_read_write_multiple_registers_write_registers"
               split => { "[zeek][modbus_read_write_multiple_registers][write_registers]" => "," } }
    }

  } else if ([log_source] == "mqtt_publish") {
    #############################################################################################################################
    # mqtt_publish.log specific logic

    # MQTT payload *may* be JSON, or it may not
    json {
      skip_on_invalid_json => true
      source => "[zeek][mqtt_publish][payload]"
      target => "[zeek][mqtt_publish][payload_dict]"
    }

    if ([zeek][mqtt_publish][payload_len]) { mutate { id => "mutate_add_field_zeek_mqtt_publish_client_len"
                                                     add_field => { "[client][bytes]" => "%{[zeek][mqtt_publish][payload_len]}" } } }


  } else if ([log_source] == "mqtt_subscribe") {
    #############################################################################################################################
    # mqtt_subscribe.log specific logic

    mutate { id => "mutate_split_zeek_mqtt_subscribe_fields"
             split => { "[zeek][mqtt_subscribe][topics]" => ","
                        "[zeek][mqtt_subscribe][qos_levels]" => "," } }

  } else if ([log_source] == "mysql") {
    #############################################################################################################################
    # mysql.log specific logic

    if ([zeek][mysql][rows] == 0) {
      mutate { id => "mutate_remove_field_zeek_mysql_zero_rows"
               remove_field => [ "[zeek][mysql][rows]" ] }
    }

  } else if ([log_source] == "notice") {
    #############################################################################################################################
    # notice.log specific logic

    mutate { id => "mutate_split_zeek_notice_actions"
             split => { "[zeek][notice][actions]" => "," } }

    ruby {
      id => "ruby_add_field_zeek_notice_event_original"
      code => " event.set('[event][original]', [event.get('[zeek][notice][msg]'),
                                                event.get('[zeek][notice][sub]')].compact.join(':'))" }

    # split "Category::Subcategory" into two different fields
    ruby {
      id => "ruby_zeek_notice_category_extract"
      code => "
        if (noticeNote = event.get('[zeek][notice][note]')) and (noticeParts = noticeNote.split('::')) then
          if (noticeParts.length >= 2) then
            event.set('[zeek][notice][category]', noticeParts[0])
            event.set('[zeek][notice][sub_category]', noticeParts[1])
          elsif (noticeParts.length == 1) then
            event.set('[zeek][notice][category]', noticeParts[0])
          end
        end"
    }

    if ([zeek][notice][category] == "ATTACK") and ([zeek][notice][msg] =~ /(from|against|to)\s+host/) {
      # ATTACK::Discovery - Detected activity from host 192.168.199.133, total attempts 5 within timeframe 5.0 mins
      # but no IP addresses set :(
      if (![source][ip]) {
        grok {
          id => "grok_zeek_notice_attack_src_hosts"
          match => { "[zeek][notice][msg]" => [ "from%{SPACE}host%{SPACE}%{DATA:[source][ip]}%{SPACE}($|[^\d:\.\w-]+)" ] }
        }
      }
      if (![destination][ip]) {
        grok {
          id => "grok_zeek_notice_attack_dst_hosts"
          match => { "[zeek][notice][msg]" => [ "(against|to)%{SPACE}host%{SPACE}%{DATA:[destination][ip]}%{SPACE}($|[^\d:\.\w-]+)" ] }
        }
      }
    }

    if ([zeek][notice][note] == "Corelight::XOR_Encrypted_PE_File_Seen") and ([zeek][notice][sub] =~ /Decrypted File ID/) {
      # zeek_notice.note  Corelight::XOR_Encrypted_PE_File_Seen
      #
      #         zeek.fuid   F7QoY740DvrZF2lrsa
      # + zeek_notice.sub   Decrypted File ID: FqNQ8i3LbG2ZY5EO3k
      # -----------------
      # =       zeek.fuid   F7QoY740DvrZF2lrsa, FqNQ8i3LbG2ZY5EO3k
      grok {
        id => "grok_zeek_notice_xor_fuid"
        match => { "[zeek][notice][sub]" => [ "Decrypted%{SPACE}File%{SPACE}ID:%{SPACE}%{WORD:[@metadata][decrypted_xor_fuid]}" ] }
      }
      if ([@metadata][decrypted_xor_fuid]) { mutate { id => "mutate_merge_zeek_notice_decrypted_xor_fuid"
                                                      merge => { "[zeek][fuid]" => "[@metadata][decrypted_xor_fuid]" } } }
    }

    # add event.module to make them jive with signatures, suricata alerts, etc.
    mutate { id => "mutate_add_field_zeek_notice_module"
             add_field => { "[event][module]" => "zeek" } }

    # ECS - zeek.notice.category -> rule.category
    if ([zeek][notice][category]) {
      ruby { id => "ruby_add_field_ecs_rule_category_notice_category"
             code => "event.set('[rule][category]', [ event.get('[zeek][notice][category]'), event.get('[rule][category]') ].flatten.compact)" }
    }

    # ECS - zeek.notice.sub_category -> rule.name
    if ([zeek][notice][sub_category]) {
      ruby { id => "ruby_add_field_ecs_zeek_rule_name_notice_sub_category"
             code => "event.set('[rule][name]', [ event.get('[zeek][notice][sub_category]'), event.get('[rule][name]') ].flatten.compact)" }
    }

    # ECS - zeek.notice.category -> rule.author (mapped)
    translate {
      id => "translate_zeek_notice_author"
      source => "[zeek][notice][category]"
      target => "[@metadata][zeek_noticed_mapped_author]"
      dictionary_path => "/etc/notice_authors.yaml"
      fallback => "Zeek"
    }
    if ([@metadata][zeek_noticed_mapped_author]) {
      mutate { id => "mutate_merge_zeek_noticed_mapped_author"
               merge => { "[rule][author]" => "[@metadata][zeek_noticed_mapped_author]" } }
    }

    # ECS - zeek.notice.category -> rule.reference (mapped)
    translate {
      id => "translate_zeek_notice_reference"
      source => "[zeek][notice][category]"
      target => "[@metadata][zeek_noticed_mapped_reference]"
      dictionary_path => "/etc/notice_reference.yaml"
      fallback => "https://docs.zeek.org/en/current/zeek-noticeindex.html"
    }
    if ([@metadata][zeek_noticed_mapped_reference]) {
      mutate { id => "mutate_merge_zeek_noticed_mapped_reference"
               merge => { "[rule][reference]" => "[@metadata][zeek_noticed_mapped_reference]" } }
    }

    # ECS - zeek.notice.category -> rule.license (mapped)
    translate {
      id => "translate_zeek_notice_license"
      source => "[zeek][notice][category]"
      target => "[@metadata][zeek_noticed_mapped_license]"
      dictionary_path => "/etc/notice_license.yaml"
      fallback => "https://raw.githubusercontent.com/zeek/zeek/master/COPYING"
    }
    if ([@metadata][zeek_noticed_mapped_license]) {
      mutate { id => "mutate_merge_zeek_noticed_mapped_license"
               merge => { "[rule][license]" => "[@metadata][zeek_noticed_mapped_license]" } }
    }

    # ECS - zeek.notice.category -> threat.* (https://www.elastic.co/guide/en/ecs/current/ecs-threat.html)
    if ([zeek][notice][category] == "ATTACK") {

      # populate threat information for MITRE ATT&CK notices from mitre-attack/bzar plugin
      mutate { id => "mutate_add_field_ecs_threat_framework_mitre_attack"
               add_field => { "[threat][framework]" => "MITRE ATT&CK" } }

      if ([zeek][notice][sub_category]) {
        mutate { id => "mutate_add_field_ecs_threat_tactic_name_mitre"
                 add_field => { "[threat][tactic][name]" => "%{[zeek][notice][sub_category]}" } }
        mutate { id => "mutate_gsub_ecs_threat_tactic_name_notice_sub"
                 gsub => [ "[threat][tactic][name]", "_,", " " ] }
        translate {
          id => "translate_zeek_mitre_attack_tactic_name_to_id"
          source => "[zeek][notice][sub_category]"
          target => "[threat][tactic][id]"
          dictionary_path => "/etc/mitre_attack_tactic_ids.yaml"
        }
        translate {
          id => "translate_zeek_mitre_attack_tactic_name_to_reference"
          source => "[zeek][notice][sub_category]"
          target => "[threat][tactic][reference]"
          dictionary_path => "/etc/mitre_attack_tactic_reference.yaml"
          fallback => "https://attack.mitre.org/tactics/enterprise/"
        }
      }

      if ([zeek][notice][sub]) and ([zeek][notice][sub] =~ /^T/) {
        # eg., T1077 Windows Admin Shares + T1105 Remote File Copy
        ruby {
          id => "ruby_ecs_threat_technique_from_attack"
          code => "
            idArray = Array.new
            nameArray = Array.new
            event.get('[zeek][notice][sub]').split('+').each do |technique|
              id, name = technique.strip.match(/(^T.*?)\s+(.+$)/).captures
              idArray.push(id) unless id.nil?
              nameArray.push(name) unless name.nil?
            end
            event.set('[threat][technique][id]', idArray)
            event.set('[threat][technique][name]', nameArray)
            event.set('[threat][technique][reference]', idArray.clone.map(&:clone).map{|x| x.prepend('https://attack.mitre.org/techniques/')})
          "
        }
      }

    } else if ([zeek][notice][category] == "EternalSafety") {
      # populate threat information for EternalSafety from 0xl3x1/zeek-EternalSafety plugin
      mutate { id => "mutate_add_field_ecs_threat_framework_eternal_safety"
               add_field => { "[threat][framework]" => "EternalSafety" } }
      if ([zeek][notice][sub_category]) { mutate { id => "mutate_add_field_ecs_threat_technique_name_eternal"
                                                  add_field => { "[threat][technique][name]" => "%{[zeek][notice][sub_category]}" } } }
      if ([rule][reference])           { mutate { id => "mutate_add_field_ecs_threat_technique_reference_eternal"
                                                  add_field => { "[threat][tactic][reference]" => "%{[rule][reference]}"
                                                                 "[threat][technique][reference]" => "%{[rule][reference]}" } } }
    }

    if (([zeek][notice][category] =~ /^CVE/) or
        ([zeek][notice][category] == "EternalSafety") or
        ([zeek][notice][category] == "Ripple20") or
        ([zeek][notice][category] == "VMWareRCE2022") or
        ([zeek][notice][category] == "Zerologon")) {
      # ECS - zeek.notice.category -> vulnerability.* (https://www.elastic.co/guide/en/ecs/current/ecs-vulnerability.html)
      mutate { id => "mutate_merge_ecs_vulnerability_category_notice_category"
               merge => { "[vulnerability][category]" => "[zeek][notice][category]" } }
      mutate { id => "mutate_merge_ecs_vulnerability_description_notice_subcategory"
               merge => { "[vulnerability][description]" => "[zeek][notice][sub_category]" } }
      if ([rule][reference]) { mutate { id => "mutate_merge_zeek_noticed_mapped_vulnerability_reference"
                                        merge => { "[vulnerability][reference]" => "[rule][reference]" } } }
      if ([rule][author]) {    mutate { id => "mutate_merge_zeek_noticed_mapped_vulnerability_vendor"
                                        merge => { "[vulnerability][scanner][vendor]" => "[rule][author]" } } }
      if ([zeek][notice][category] =~ /^CVE/) {
        mutate { id => "mutate_add_field_ecs_zeek_vulnerability_enumeration_cve"
                 add_field => { "[vulnerability][enumeration]" => "CVE" } }
        mutate { id => "mutate_add_field_ecs_zeek_vulnerability_id_cve"
                 add_field => { "[vulnerability][id]" => "%{[zeek][notice][category]}" } }
      }
    }

    # remove signature fields that were mapped to ECS or not useful
    mutate { id => "mutate_remove_fields_zeek_notice"
             remove_field => [
              "[zeek][notice][sub_category]",
              "[zeek][notice][category]" ] }

  } else if ([log_source] == "ntlm") {
    #############################################################################################################################
    # ntlm.log specific logic

    # ECS - zeek.ntlm.host -> client.domain
    if ([zeek][ntlm][host]) {
      mutate { id => "mutate_add_field_ecs_client_domain_ntlm_host_name"
               add_field => { "[client][domain]" => "%{[zeek][ntlm][host]}" } }
    }

    # ECS - zeek.ntlm.domain -> client.domain
    if ([zeek][ntlm][domain]) {
      mutate { id => "mutate_add_field_ecs_client_domain_ntlm_domain"
               add_field => { "[client][domain]" => "%{[zeek][ntlm][domain]}" } }
    }

  } else if ([log_source] == "ntp") {
    #############################################################################################################################
    # ntp.log specific logic

    # map mode to string for readability
    if ([zeek][ntp][mode]) {
      translate {
        id => "translate_zeek_ntp_mode_str"
        source => "[zeek][ntp][mode]"
        target => "[zeek][ntp][mode_str]"
        dictionary_path => "/etc/ntp_modes.yaml"
      }
    }

  } else if ([log_source] =~ /^opcua_binary/) {
    #############################################################################################################################
    # opcua-binary-*.log specific logic

    # all of the opcua-binary logs are also linked together by the opcua_id field,
    # so normalize it under zeek.opcua_binary.opcua_id like the "parent" log is so
    # they can be filtered together
    if (![zeek][opcua_binary][opcua_id]) {
      mutate {
        id => "mutate_rename_opcua_binary_opcua_id"
        rename => { "[zeek][%{[log_source]}][opcua_id]" => "[zeek][opcua_binary][opcua_id]" }
      }
    }

  } else if ([log_source] == "ospf") {
    #############################################################################################################################
    # ospf.log specific logic

    mutate { id => "mutate_split_zeek_ospf_neighbors"
             split => { "[zeek][ospf][neighbors]" => "," } }
    mutate { id => "mutate_split_zeek_ospf_routers"
             split => { "[zeek][ospf][routers]" => "," } }
    mutate { id => "mutate_split_zeek_ospf_metrics"
             split => { "[zeek][ospf][metrics]" => "," } }
    mutate { id => "mutate_split_zeek_ospf_fwd_addrs"
             split => { "[zeek][ospf][fwd_addrs]" => "," } }
    mutate { id => "mutate_split_zeek_ospf_route_tags"
             split => { "[zeek][ospf][route_tags]" => "," } }
    mutate { id => "mutate_split_zeek_link_prefixes"
             split => { "[zeek][ospf][link_prefixes]" => "," } }
    mutate { id => "mutate_split_zeek_intra_prefixes"
             split => { "[zeek][ospf][intra_prefixes]" => "," } }

  } else if ([log_source] == "pe") {
    #############################################################################################################################
    # pe.log specific logic

    mutate { id => "mutate_split_zeek_pe_section_names"
             split => { "[zeek][pe][section_names]" => "," } }

  } else if ([log_source] == "radius") {
    #############################################################################################################################
    # radius.log specific logic

    if ([related][user]) { mutate { id => "mutate_merge_zeek_radius_user"
                                    merge => { "[radius][user]" => "[related][user]" } } }

    if ([zeek][radius][framed_addr]) {
      mutate { id => "mutate_merge_zeek_radius_framed_addr"
               merge => { "[radius][framedIp]" => "[zeek][radius][framed_addr]" } }
    }

    if ([zeek][radius][tunnel_client]) {
      mutate { id => "mutate_merge_zeek_radius_tunnel_client"
               merge => { "[radius][endpointIp]" => "[zeek][radius][tunnel_client]" } }
    }

    if ([zeek][radius][mac]) {
      mutate { id => "mutate_merge_zeek_radius_mac"
               merge => { "[radius][mac]" => "[zeek][radius][mac]" } }
      if (![source][mac]) {
        mutate { id => "mutate_merge_zeek_radius_zeek_mac"
                 merge => { "[source][mac]" => "[zeek][radius][mac]" } }
      }
    }

  } else if ([log_source] == "rdp") {
    #############################################################################################################################
    # rdp.log specific logic

    mutate { id => "mutate_split_zeek_rdp_client_channels"
             split => { "[zeek][rdp][client_channels]" => "," } }


  } else if ([log_source] == "s7comm") {
    #############################################################################################################################
    # s7comm.log specific logic

    if ([zeek][s7comm][parameter]) {
      ruby {
        id => "ruby_zeek_s7comm_parse_parameter"
        code => "
          parameterHash = event.get('[zeek][s7comm][parameter]').split(',').each_with_object({}) do |a, hash|
            key,value = a.split(/\s*=\s*/)
            hash[key] = value
          end
          event.set('[zeek][s7comm][parameters]', parameterHash)"
      }
      mutate { id => "mutate_split_field_s7comm_parameter"
               split => { "[zeek][s7comm][parameter]" => "," } }
    }

    if ([zeek][s7comm][data_info] == "Null") {
      mutate { id => "mutate_remove_field_s7comm_data_info_null"
               remove_field => [ "[zeek][s7comm][data_info]" ] }
    } else if ([zeek][s7comm][data_info]) {
      mutate { id => "mutate_split_field_s7comm_data_info"
               split => { "[zeek][s7comm][data_info]" => "," } }
    }

  } else if ([log_source] == "signatures") {
    #############################################################################################################################
    # signatures.log specific logic
    #
    # this has been reworked significantly from its original form to normalize to ECS along with suricata.alert.*

    if ("_carved" in [tags]) {
      # Malcolm does some "special" stuff in zeek_carve_logger.py for file carving, sort of hijacking signatures.log for it

      # _carved signature logs' sub_message contains fuid(s) comma-separated
      if ([zeek][signatures][sub_message]) {
        mutate { id => "mutate_split_zeek_signatures_sub_message"
                 split => { "[zeek][signatures][sub_message]" => "," } }
        mutate { id => "mutate_rename_zeek_signatures_sub_message"
                 rename => { "[zeek][signatures][sub_message]" => "[zeek][fuid]" } }
      }

      if ([zeek][signatures][event_message]) {
        # sub_message contains "Signature [Engine]" list semi-colon separated
        ruby {
            id => "ruby_zeek_signatures_event_message_parse"
            code => "
                matchesHash = Hash.new
                idArray = Array.new
                event.get('[zeek][signatures][event_message]').split(';').each { |hit|
                  nameAndEngines = hit.split(/(.+?)\s*<(.+)>/)
                  nameAndEngines[2].split(',').each { |engine|
                    unless matchesHash.key?(engine)
                      matchesHash[engine] = Array.new
                    end
                    matchesHash[engine].push(nameAndEngines[1])
                    idArray.push(nameAndEngines[1])
                  }
                }
                event.set('[zeek][signatures][hits]', matchesHash)
                event.set('[event][module]', matchesHash.keys)
                event.set('[event][hits]', matchesHash.length)
                event.set('[rule][name]', idArray.uniq)
            "
        }
      }

    } else {
      # not _carved, actual zeek signatures.log entries

      if ([zeek][signatures][signature_id]) {
        if ([zeek][signatures][signature_id] =~ /^dpd_/) {
          # I don't care about DPD matching signatures
          drop { id => "drop_zeek_ignored_signatures_dpd" }
        } else {
          mutate { id => "mutate_merge_zeen_signature_id_rule_name"
                   merge => { "[rule][name]" => "[zeek][signatures][signature_id]" } }
        }
      }

      if ([zeek][signatures][event_message]) {
        mutate { id => "mutate_add_field_ecs_event_original_signature_event_message"
                 add_field => { "[event][original]" => "%{[zeek][signatures][event_message]}" } }
      }

    } # carved vs not

    if (![event][module]) {
      ruby { id => "ruby_add_field_zeek_signature_event_module"
             code => "event.set('[event][module]', [ 'zeek' ].flatten.compact)" }
    }

    # ECS - zeek.signatures.note -> rule.category
    if ([zeek][signatures][note]) {
      mutate { id => "mutate_add_field_ecs_zeek_rule_category_signatures_note"
               merge => { "[rule][category]" => "[zeek][signatures][note]" } }
    }

    if ('Capa' in [event][module]) {
      # ECS - populate threat information for MITRE ATT&CK techniques specified by capa hits
      ruby {
          id => "ruby_signatures_attack_extract"
          # matches array is like: 1) tactic name, 2) technique name, 3) sub-technique name, 4) technique number
          # <MatchData
          #  "Persistence::Create or Modify System Process::Windows Service [ATT&CK T1543.003]"
          #    1:"Persistence"
          #    2:"Create or Modify System Process"
          #    3:"Windows Service"
          #    4:"T1543.003">,
          # <MatchData
          #  "Execution::Shared Modules [ATT&CK T1129]"
          #    1:"Execution"
          #    2:"Shared Modules"
          #    3:nil
          #    4:"T1129">
          init => "
            require 'yaml'; $tacticIdMap = YAML.safe_load(File.read('/etc/mitre_attack_tactic_ids.yaml'));
          "
          code => "
            matches = Array.new
            begin
              event.get('[rule][name]').each do |signature|
                matches.push(/(.+?)::(.+?)(?:::(.+?))?\s*\[ATT&CK\s*(.+?)\]/.match(signature))
              end
            rescue Exception => e
              event.set('ruby_exception', 'ruby_signatures_attack_extract: ' + e.message)
            end
            if (matches.length > 0) then
                tacticNames = matches.map{ |x| x[1].gsub(' ', '_') }.compact
                tacticIds = tacticNames.clone.map(&:clone).map{ |x| $tacticIdMap[x] }.compact
                tacticRefs = tacticIds.clone.map(&:clone).map { |x| x.gsub(/\..*/, '').prepend('https://attack.mitre.org/tactics/') }.uniq.compact
                techniqueNames = matches.map{ |x| [x[2], x[3]].compact.join(':') }.compact
                techniqueIds = matches.map{ |x| x[4] }.compact
                techniqueRefs = techniqueIds.clone.map(&:clone).map { |x| x.gsub(/\..*/, '').prepend('https://attack.mitre.org/techniques/') }.uniq.compact
                event.set('[threat][tactic][name]', tacticNames.uniq) unless (tacticNames.length == 0)
                event.set('[threat][tactic][id]', tacticIds.uniq) unless (tacticIds.length == 0)
                event.set('[threat][tactic][reference]', tacticRefs.uniq) unless (tacticRefs.length == 0)
                event.set('[threat][technique][name]', techniqueNames.uniq) unless (techniqueNames.length == 0)
                event.set('[threat][technique][id]', techniqueIds.uniq) unless (techniqueIds.length == 0)
                event.set('[threat][technique][reference]', techniqueRefs.uniq) unless (techniqueRefs.length == 0)
                event.set('[threat][framework]', 'MITRE ATT&CK')
            end
          "
      }
    } # Capa

    # get more specific than 'Signatures::Sensitive_Signature' if we can
    if ([rule][category]) and ([rule][category][0] == 'Signatures::Sensitive_Signature') {
      if ([threat][tactic][name]) {
        mutate { id => "mutate_merge_zeek_sensitive_signature_tactic"
                 merge => { "[@metadata][zeek_sensitive_signature_replacement]" => "[threat][tactic][name]" } }
      } else if ([threat][technique][name]) {
        mutate { id => "mutate_merge_zeek_sensitive_signature_technique"
                 merge => { "[@metadata][zeek_sensitive_signature_replacement]" => "[threat][technique][name]" } }
      } else if ([threat][framework]) {
        mutate { id => "mutate_merge_zeek_sensitive_signature_framework"
                 merge => { "[@metadata][zeek_sensitive_signature_replacement]" => "[threat][framework]" } }
      }
      if ([@metadata][zeek_sensitive_signature_replacement]) {
        mutate { id => "remove_field_zeek_sensitive_signature"
                 remove_field => [ "[rule][category][0]" ] }
        mutate { id => "mutate_merge_zeek_sensitive_signature_replacement"
                 merge => { "[rule][category]" => "[@metadata][zeek_sensitive_signature_replacement]" } }
      } else if ([event][hits]) and ([event][hits] > 1) {
        mutate { id => "remove_field_zeek_sensitive_signature_multiple"
                 remove_field => [ "[rule][category][0]" ] }
        ruby { id => "ruby_add_field_zeek_multiple_signatures"
               code => "event.set('[rule][category]', [ 'Signatures::Multiple_Signatures', event.get('[rule][category]') ].flatten.compact)" }
      }
    }

    # remove signature fields that were mapped to ECS
    mutate { id => "mutate_remove_fields_zeek_signatures"
             remove_field => [
              "[zeek][signatures][event_message]",
              "[zeek][signatures][note]" ] }

  } else if ([log_source] == "sip") {
    #############################################################################################################################
    # sip.log specific logic

    ruby {
      id => "ruby_zeek_field_zeek_sip_version"
      code => '
      versions = Array.new
      paths = [event.get("[zeek][sip][request_path]"), event.get("[zeek][sip][response_path]")].compact.join(",")
      paths.scan(/\bSIP:?\/([\d\.]+)/i) { |match| versions << match[0] }
      event.set("[zeek][sip][version]", versions.uniq)'
    }

    mutate { id => "mutate_split_zeek_sip_request_path"
             split => { "[zeek][sip][request_path]" => "," } }

    mutate { id => "mutate_split_zeek_sip_response_path"
             split => { "[zeek][sip][response_path]" => "," } }

    if ([zeek][sip][request_body_len]) { mutate { id => "mutate_add_field_zeek_sip_client_bytes"
                                                 add_field => { "[client][bytes]" => "%{[zeek][sip][request_body_len]}" } } }

    if ([zeek][sip][response_body_len]) { mutate { id => "mutate_add_field_zeek_sip_server_bytes"
                                                  add_field => { "[server][bytes]" => "%{[zeek][sip][response_body_len]}" } } }

  } else if ([log_source] == "smb_cmd") or ([log_source] == "smb_files") {
    #############################################################################################################################
    # smb_cmd.log and smb_files.log specific logic
    # note that smb_cmd.referenced_file is exactly the same structure as the log line for smb_files, which is why I've combined
    # the logic here to avoid duplication

    if ([zeek][smb_cmd]) {

      if ([zeek][smb_cmd][tree]) {
         # translate Zeek's double-backslashes single backslash in filenames
         ruby {
           id => "ruby_zeek_smb_cmd_tree_dedoubleslash"
           path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
           script_params => {
             "source" => "[zeek][smb_cmd][tree]"
             "target" => "[zeek][smb_cmd][tree]"
           }
         }
         # split zeek.smb_cmd.tree to host and service
         ruby {
           id => "ruby_zeek_smb_cmd_tree_split"
           path => "/usr/share/logstash/malcolm-ruby/smbsplit.rb"
           script_params => {
             "source" => "[zeek][smb_cmd][tree]"
             "host" => "[smb][host]"
             "share" => "[smb][share]"
             "path" => "[smb][filename]"
           }
         }
         # if we didn't populate service, fall back to tree_service for share
         if (![smb][share]) and ([zeek][smb_cmd][tree_service]) {
             mutate { id => "mutate_merge_zeek_smb_cmd_tree_service_share"
                      merge => { "[smb][share]" => "[zeek][smb_cmd][tree_service]" } }
         }
      } # if [zeek][smb_cmd][tree]

      if ([zeek][smb_cmd][referenced_file]) {

        # move "up" referenced_file to its own smb_files top-level entity
        mutate {
          id => "mutate_rename_zeek_zeek_smb_cmd_referenced_file"
          rename => { "[zeek][smb_cmd][referenced_file]" => "[zeek][smb_files]" }
        }

        # remove unset (-) or "(empty)" referenced_file (now zeek_smb_files) subfield values
        ruby {
          id => "ruby_zeek_remove_empty_smb_cmd_referenced_file_values"
          path => "/usr/share/logstash/malcolm-ruby/compact_event_hash.rb"
          script_params => {
            "field" => "[zeek][smb_files]"
          }
        }

        # collect referenced file FUID(s) at parent level (here rather than in 12_zeek_normalize.conf because
        # this would have already been done as a root-level fuid array in the main "rename" above if we
        # had not had to move it up a level just now)
        if ([zeek][smb_files][fuid]) {
          mutate { id => "mutate_merge_zeek_smb_files_fuid"
                   merge => { "[zeek][fuid]" => "[zeek][smb_files][fuid]" } }
          mutate { id => "mutate_remove_zeek_smb_files_fuid"
                   remove_field => [ "[zeek][smb_files][fuid]" ] }
        }

        if ([zeek][smb_files][action]) { mutate { id => "mutate_gsub_zeek_smb_cmd_referenced_file_action"
                                                 gsub => [ "[zeek][smb_files][action]", "^SMB::", "" ] } }

      } # if ([zeek][smb_cmd][referenced_file])

    } # if ([zeek][smb_cmd])

    # this should now apply to either lines from smb_files.log or smb_cmd.referenced_file
    if ([zeek][smb_files]) {

      # translate Zeek's double-backslashes single backslash in filenames
      ruby {
        id => "ruby_zeek_smb_files_path_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_files][path]"
          "target" => "[zeek][smb_files][path]"
        }
      }
      ruby {
        id => "ruby_zeek_smb_files_name_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_files][name]"
          "target" => "[zeek][smb_files][name]"
        }
      }
      ruby {
        id => "ruby_zeek_smb_files_prev_name_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_files][prev_name]"
          "target" => "[zeek][smb_files][prev_name]"
        }
      }

      # store smb_files.name and/or smb_files.prev_name as smb.filename for Arkime
      if ([zeek][smb_files][name]) { mutate { id => "mutate_merge_zeek_smb_files_name_to_filename"
                                            merge => { "[smb][filename]" => "[zeek][smb_files][name]" } } }
      if ([zeek][smb_files][prev_name]) { mutate { id => "mutate_merge_zeek_smb_files_prev_name_to_filename"
                                                 merge => { "[smb][filename]" => "[zeek][smb_files][prev_name]" } } }

      # if we have smb_files.path, split into host/share/path
      if ([zeek][smb_files][path]) {
        ruby {
          id => "ruby_zeek_smb_files_path_split"
          path => "/usr/share/logstash/malcolm-ruby/smbsplit.rb"
          script_params => {
            "source" => "[zeek][smb_files][path]"
            "host" => "[smb][host]"
            "share" => "[smb][share]"
            "path" => "[@metadata][smb_files_path]"
          }
        }
      }

      # store appropriate filename in file.name
      if (![smb][filename]) and ([@metadata][smb_files_path]) {
        mutate { id => "mutate_merge_zeek_metadata_smb_files_path_file_name"
                  merge => { "[smb][filename]" => "[@metadata][smb_files_path]" } }
      }

    } # if ([zeek][smb_files])

  } else if ([log_source] == "smb_mapping") {
    #############################################################################################################################
    # smb_mapping.log specific logic

    if ([zeek][smb_mapping][path]) {
      # translate Zeek's double-backslashes single backslash in filenames
      ruby {
        id => "ruby_zeek_smb_mapping_path_dedoubleslash"
        path => "/usr/share/logstash/malcolm-ruby/dedoubleslash.rb"
        script_params => {
          "source" => "[zeek][smb_mapping][path]"
          "target" => "[zeek][smb_mapping][path]"
        }
      }
    }

    if ([zeek][smb_mapping][path]) {
      ruby {
        id => "ruby_zeek_smb_mapping_path_split"
        path => "/usr/share/logstash/malcolm-ruby/smbsplit.rb"
        script_params => {
          "source" => "[zeek][smb_mapping][path]"
          "host" => "[smb][host]"
          "share" => "[smb][share]"
          "path" => "[smb][filename]"
        }
      }
    }

  } else if ([log_source] == "smtp") {
    #############################################################################################################################
    # smtp.log specific logic

    mutate { id => "mutate_split_zeek_smtp_rcptto"
             split => { "[zeek][smtp][rcptto]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_to"
             split => { "[zeek][smtp][to]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_cc"
             split => { "[zeek][smtp][cc]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_path"
             split => { "[zeek][smtp][path]" => "," } }

    if ([zeek][smtp][user_agent]) {
      mutate { id => "mutate_merge_zeek_smtp_user_agent"
               merge => { "[email][useragent]" => "[zeek][smtp][user_agent]" } }
    }

    if ([zeek][smtp][from]) { mutate { id => "mutate_merge_zeek_smtp_from"
                                     merge => { "[email][src]" => "[zeek][smtp][from]" } } }
    if ([zeek][smtp][mailfrom]) { mutate { id => "mutate_merge_zeek_smtp_mailfrom"
                                         merge => { "[email][src]" => "[zeek][smtp][mailfrom]" } } }
    if ([zeek][smtp][reply_to]) { mutate { id => "mutate_merge_zeek_smtp_reply_to"
                                         merge => { "[email][src]" => "[zeek][smtp][reply_to]" } } }
    if ([zeek][smtp][to]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_to"
                                   merge => { "[email][dst]" => "[zeek][smtp][to]" } } }
    if ([zeek][smtp][cc]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_cc"
                                   merge => { "[email][dst]" => "[zeek][smtp][cc]" } } }
    if ([zeek][smtp][rcptto]) { mutate { id => "mutate_merge_zeek_dst_from_rcptto"
                                       merge => { "[email][dst]" => "[zeek][smtp][rcptto]" } } }
    if ([zeek][smtp][helo]) {
      mutate { id => "mutate_merge_zeek_smtp_helo"
               merge => { "[email][smtpHello]" => "[zeek][smtp][helo]" } }
    }
    if ([zeek][smtp][subject]) {
      mutate { id => "mutate_merge_zeek_smtp_subject"
               merge => { "[email][subject]" => "[zeek][smtp][subject]" } }
    }

    if ([zeek][smtp][msg_id]) {
      mutate { id => "mutate_gsub_zeek_smtp_msg_id"
               gsub => [ "[zeek][smtp][msg_id]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_msg_id"
               merge => { "[email][id]" => "[zeek][smtp][msg_id]" } }
    }
    if ([zeek][smtp][in_reply_to]) {
      mutate { id => "mutate_gsub_zeek_smtp_in_reply_to"
               gsub => [ "[zeek][smtp][in_reply_to]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_in_reply_to"
               merge => { "[email][id]" => "[zeek][smtp][in_reply_to]" } }
    }

    if ([zeek][smtp][last_reply]) {
      # will be mapped to a "result" later in normalization
      grok {
        id => "grok_zeek_zeek_smtp_last_reply"
        match => { "[zeek][smtp][last_reply]" => [ "^%{SPACE}%{NUMBER:[zeek][smtp][last_reply_code]}" ] }
      }
    }

  } else if ([log_source] == "ssh") {
    #############################################################################################################################
    # ssh.log specific logic

    if ([zeek][ssh][server]) { mutate { id => "mutate_merge_zeek_ssh_server_version"
                                       merge => { "[ssh][version]" => "[zeek][ssh][server]" } } }

    if ([zeek][ssh][client]) { mutate { id => "mutate_merge_zeek_client_version"
                                       merge => { "[ssh][version]" => "[zeek][ssh][client]" } } }

    if (![ssh][version]) and ([zeek][ssh][version]) { mutate { id => "mutate_merge_zeek_ssh_version"
                                                              merge => { "[ssh][version]" => "[zeek][ssh][version]" } } }

    if ([zeek][ssh][host_key] and [zeek][ssh][host_key_alg]) {
      # this is stupid, the %{} doesn't seem to be liked by mutate.merge
      mutate { id => "mutate_add_field_zeek_ssh_host_key"
               add_field => { "[@metadata][ssh_key_str]" => "%{[zeek][ssh][host_key_alg]} %{[zeek][ssh][host_key]}" } }
      mutate { id => "mutate_merge_zeek_ssh_key"
               merge => { "[ssh][key]" => "[@metadata][ssh_key_str]" } }
    }

    # HASSH stuff (see https://github.com/salesforce/hassh/tree/master/bro)

    if ([zeek][ssh][hassh]) {
      mutate { id => "mutate_merge_zeek_ssh_hassh"
               merge => { "[ssh][hassh]" => "[zeek][ssh][hassh]" } }
    }

    if ([zeek][ssh][hasshServer]) {
      mutate { id => "mutate_merge_zeek_ssh_hasshServer"
               merge => { "[ssh][hasshServer]" => "[zeek][ssh][hasshServer]" } }
    }

    if ([zeek][ssh][hasshAlgorithms]) { mutate { id => "mutate_split_zeek_ssh_hasshAlgorithms"
                                                split => { "[zeek][ssh][hasshAlgorithms]" => "," } } }

    if ([zeek][ssh][hasshServerAlgorithms]) { mutate { id => "mutate_split_zeek_ssh_hasshServerAlgorithms"
                                                      split => { "[zeek][ssh][hasshServerAlgorithms]" => "," } } }

    if ([zeek][ssh][cshka]) { mutate { id => "mutate_split_zeek_ssh_cshka"
                                      split => { "[zeek][ssh][cshka]" => "," } } }

    if ([zeek][ssh][sshka]) { mutate { id => "mutate_split_zeek_ssh_sshka"
                                      split => { "[zeek][ssh][sshka]" => "," } } }


  } else if ([log_source] == "ssl") {
    #############################################################################################################################
    # ssl.log specific logic

    # split subjects/issuers out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek][ssl][subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_subject"
               gsub => [ "[zeek][ssl][subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_subject"
               rename => { "[zeek][ssl][subject]" => "[zeek][ssl][subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_subject"
        field_split => ","
        source => "[zeek][ssl][subject_full]"
        target => "[zeek][ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject"
        field => "[zeek][ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject_full"
        field => "[zeek][ssl][subject_full]"
      }
    }

    if ([zeek][ssl][client_subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_subject"
               gsub => [ "[zeek][ssl][client_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_subject"
               rename => { "[zeek][ssl][client_subject]" => "[zeek][ssl][client_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_subject"
        field_split => ","
        source => "[zeek][ssl][client_subject_full]"
        target => "[zeek][ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject"
        field => "[zeek][ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject_full"
        field => "[zeek][ssl][client_subject_full]"
      }
    }

    if ([zeek][ssl][issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_issuer"
               gsub => [ "[zeek][ssl][issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_issuer"
               rename => { "[zeek][ssl][issuer]" => "[zeek][ssl][issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_issuer"
        field_split => ","
        source => "[zeek][ssl][issuer_full]"
        target => "[zeek][ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer"
        field => "[zeek][ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer_full"
        field => "[zeek][ssl][issuer_full]"
      }
    }

    if ([zeek][ssl][client_issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_issuer"
               gsub => [ "[zeek][ssl][client_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_issuer"
               rename => { "[zeek][ssl][client_issuer]" => "[zeek][ssl][client_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_issuer"
        field_split => ","
        source => "[zeek][ssl][client_issuer_full]"
        target => "[zeek][ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer"
        field => "[zeek][ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer_full"
        field => "[zeek][ssl][client_issuer_full]"
      }
    }

    if ([zeek][ssl][cipher]) {
      # ECS - zeek.ssl.cipher -> tls.cipher
      mutate { id => "mutate_merge_zeek_ssl_cipher"
               merge => { "[tls][cipher]" => "[zeek][ssl][cipher]" } }
    }

    if ([zeek][ssl][ja3]) {
      mutate { id => "mutate_merge_zeek_ssl_ja3"
               merge => { "[tls][ja3]" => "[zeek][ssl][ja3]" } }
    }

    if ([zeek][ssl][ja3s]) {
      mutate { id => "mutate_merge_zeek_ssl_ja3s"
               merge => { "[tls][ja3s]" => "[zeek][ssl][ja3s]" } }
    }

    if ([zeek][ssl][cert_chain_fuids]) { mutate { id => "mutate_split_zeek_ssl_cert_chain_fuids"
                                                 split => { "[zeek][ssl][cert_chain_fuids]" => "," } } }

    if ([zeek][ssl][client_cert_chain_fuids]) { mutate { id => "mutate_split_zeek_ssl_client_cert_chain_fuids"
                                                        split => { "[zeek][ssl][client_cert_chain_fuids]" => "," } } }

    if ([zeek][ssl][cert_chain_fps]) {
      mutate { id => "mutate_split_zeek_ssl_cert_chain_fps"
               split => { "[zeek][ssl][cert_chain_fps]" => "," } }
      # store certificate chain fingerprints in zeek_x509.fingerprint as well for cross-reference with x509.log
      mutate { id => "mutate_merge_zeek_ssl_cert_chain_fps"
               merge => { "[zeek][x509][fingerprint]" => "[zeek][ssl][cert_chain_fps]" } }
      # TODO: zeek.ssl.*cert_chain_fps to:
      #       https://www.elastic.co/guide/en/ecs/current/ecs-tls.html#field-tls-client-hash-md5 (or sha1, sha256, etc.)
      #       https://www.elastic.co/guide/en/ecs/current/ecs-tls.html#field-tls-server-hash-md5 (or sha1, sha256, etc.)
    }

    if ([zeek][ssl][client_cert_chain_fps]) {
      mutate { id => "mutate_split_zeek_ssl_client_cert_chain_fps"
               split => { "[zeek][ssl][client_cert_chain_fps]" => "," } }
      # store certificate chain fingerprints in zeek_x509.fingerprint as well for cross-reference with x509.log
      mutate { id => "mutate_merge_zeek_ssl_client_cert_chain_fps"
               merge => { "[zeek][x509][fingerprint]" => "[zeek][ssl][client_cert_chain_fps]" } }
    }

    # ECS - zeek.ssl.ssl_version -> tls.version and tls.version_protocol
    if ([zeek][ssl][ssl_version]) {
      # turn TLSv10, TLSv13, TSLv12, etc. to 'tls' and '1.2', etc.
      ruby {
        id => "ruby_ecs_ssl_version_parse"
        code => "
          verMatch = event.get('[zeek][ssl][ssl_version]').tr('.', '').match(/(.+)\s*[v-]\s*([\d\.]+)/i)
          verParts = verMatch.nil? ? nil : verMatch.captures
          unless verParts.nil?
            event.set('[tls][version_protocol]', verParts[0].downcase)
            event.set('[tls][version]', verParts[1].split(//).join('.'))
          end
        "
      }
    }

    # ECS - zeek.ssl.established -> tls.established
    if ([zeek][ssl][established]) {          mutate { id => "mutate_add_field_ecs_zeek_tls_established"
                                                     add_field => { "[tls][established]" => "%{[zeek][ssl][established]}" } } }

    # ECS - zeek.ssl.resumed -> tls.resumed
    if ([zeek][ssl][resumed]) {              mutate { id => "mutate_add_field_ecs_zeek_tls_resumed"
                                                     add_field => { "[tls][resumed]" => "%{[zeek][ssl][resumed]}" } } }

    # ECS - zeek.ssl.next_protocol -> tls.next_protocol
    if ([zeek][ssl][next_protocol]) {
      mutate { id => "mutate_add_field_ecs_zeek_tls_next_protocol"
                     add_field => { "[tls][next_protocol]" => "%{[zeek][ssl][next_protocol]}" } }
      mutate { id => "mutate_lowercase_field_ecs_zeek_tls_next_protocol"
               lowercase => [ "[tls][next_protocol]" ] }
    }

    # ECS - zeek.ssl.curve -> tls.curve
    if ([zeek][ssl][curve]) {                mutate { id => "mutate_add_field_ecs_zeek_tls_client_curve"
                                                     add_field => { "[tls][curve]" => "%{[zeek][ssl][curve]}" } } }

    # ECS - zeek.ssl.ja3 -> tls.client.ja3
    if ([zeek][ssl][ja3]) {                  mutate { id => "mutate_add_field_ecs_zeek_tls_client_ja3"
                                                     add_field => { "[tls][client][ja3]" => "%{[zeek][ssl][ja3]}" } } }

    # ECS - zeek.ssl.client_issuer_full -> tls.client.issuer
    if ([zeek][ssl][client_issuer_full]) {   mutate { id => "mutate_add_field_ecs_zeek_tls_client_issuer_full"
                                                     add_field => { "[tls][client][issuer]" => "%{[zeek][ssl][client_issuer_full]}" } } }

    # ECS - zeek.ssl.client_subject_full -> tls.client.subject
    if ([zeek][ssl][client_subject_full]) {  mutate { id => "mutate_add_field_ecs_zeek_tls_client_subject_full"
                                                     add_field => { "[tls][client][subject]" => "%{[zeek][ssl][client_subject_full]}" } } }

    # ECS - zeek.ssl.server_name -> tls.client.server_name and server.domain
    if ([zeek][ssl][server_name]) {
      mutate { id => "mutate_add_field_ecs_zeek_tls_client_server_name"
               add_field => { "[tls][client][server_name]" => "%{[zeek][ssl][server_name]}" } }
      mutate { id => "mutate_add_field_ecs_zeek_tls_client_server_name_destination_domain"
               add_field => { "[server][domain]" => "%{[zeek][ssl][server_name]}" } }
    }

    # ECS - zeek.ssl.issuer_full -> tls.server.issuer
    if ([zeek][ssl][issuer_full]) {          mutate { id => "mutate_add_field_ecs_zeek_tls_issuer_full"
                                                     add_field => { "[tls][server][issuer]" => "%{[zeek][ssl][issuer_full]}" } } }

    # ECS - zeek.ssl.ja3s -> tls.server.ja3s
    if ([zeek][ssl][ja3s]) {                 mutate { id => "mutate_add_field_ecs_zeek_tls_server_ja3s"
                                                     add_field => { "[tls][server][ja3s]" => "%{[zeek][ssl][ja3s]}" } } }

    # ECS - zeek.ssl.subject_full -> tls.server.subject
    if ([zeek][ssl][subject_full]) {         mutate { id => "mutate_add_field_ecs_zeek_tls_subject_full"
                                                     add_field => { "[tls][server][subject]" => "%{[zeek][ssl][subject_full]}" } } }

  } else if ([log_source] == "stun") {
    #############################################################################################################################
    # stun.log specific logic

    if ([zeek][stun][attr_type]) {
      mutate { id => "mutate_split_field_zeek_stun_attr_type"
               split => { "[zeek][stun][attr_type]" => "," } }
    }

  } else if ([log_source] == "stun_nat") {
    #############################################################################################################################
    # stun_nat.log specific logic

    # ECS - zeek.stun_nat.wan_addr -> source.nat.ip
    if ([zeek][stun_nat][wan_addr]) {    mutate { id => "mutate_add_field_ecs_zeek_stun_nat_wan_addr"
                                                  add_field => { "[source][nat][ip]" => "%{[zeek][stun_nat][wan_addr]}" } } }

    # ECS - zeek.stun_nat.wan_port -> source.nat.port
    if ([zeek][stun_nat][wan_port]) {    mutate { id => "mutate_add_field_ecs_zeek_stun_nat_wan_port"
                                                  add_field => { "[source][nat][port]" => "%{[zeek][stun_nat][wan_port]}" } } }

  } else if ([log_source] == "tds_rpc") {
    #############################################################################################################################
    # tds_rpc.log specific logic

    if ([zeek][tds_rpc][parameter]) {
      ruby {
        id => "ruby_zeek_tds_rpc_parse_parameter"
        code => "
          parameterHash = event.get('[zeek][tds_rpc][parameter]').split(',').each_with_object({}) do |a, hash|
            key,value = a.split(/\s*=\s*/)
            hash[key.delete_prefix('@')] = value
          end
          event.set('[zeek][tds_rpc][parameters]', parameterHash)"
      }

      mutate { id => "mutate_split_field_tds_rpc_parameter"
               split => { "[zeek][tds_rpc][parameter]" => "," } }
    }

  } else if ([log_source] == "weird") {
    #############################################################################################################################
    # weird.log specific logic

    if ([zeek][weird][name]) {
      # ECS - "Zeek" -> rule.author
      mutate { id => "mutate_add_field_ecs_rule_author_zeek_weird"
               add_field => { "[rule][author]" => "Zeek" } }
      # ECS - zeek weird URL -> rule.reference
      mutate { id => "mutate_add_field_ecs_rule_reference_zeek_weird"
               add_field => { "[rule][reference]" => "https://docs.zeek.org/en/current/scripts/base/frameworks/notice/weird.zeek.html" } }
      # ECS - zeek.weird.name -> rule.name
      ruby { id => "ruby_add_field_ecs_zeek_rule_name_weird_name"
             code => "event.set('[rule][name]', [ event.get('[zeek][weird][name]'), event.get('[rule][name]') ].flatten.compact)" }
    }

    ruby {
      id => "ruby_add_field_zeek_weird_event_original"
      code => " event.set('[event][original]', [event.get('[zeek][weird][name]'),
                                                event.get('[zeek][weird][addl]')].compact.join(':'))" }

    # remove signature fields that were mapped to ECS or not useful
    mutate { id => "mutate_remove_fields_zeek_weird"
             remove_field => [
              "[zeek][weird][name]",
              "[zeek][weird][peer]" ] }

  } else if ([log_source] == "x509") {
    #############################################################################################################################
    # x509.log specific logic

    # split subject/issuer out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek][x509][certificate_subject]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_subject"
               gsub => [ "[zeek][x509][certificate_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_subject"
               rename => { "[zeek][x509][certificate_subject]" => "[zeek][x509][certificate_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_subject"
        field_split => ","
        source => "[zeek][x509][certificate_subject_full]"
        target => "[zeek][x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject"
        field => "[zeek][x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject_full"
        field => "[zeek][x509][certificate_subject_full]"
      }
      if ([zeek][x509][certificate_subject][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_subject_CN"
                 merge => { "[@metadata][cert][subjectCN]" => "[zeek][x509][certificate_subject][CN]" } }
      }
      if ([zeek][x509][certificate_subject][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_subject_O"
                 add_field => { "[@metadata][cert][subjectON]" => "%{[zeek][x509][certificate_subject][O]}" } }
      }
    }

    if ([zeek][x509][certificate_issuer]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_issuer"
               gsub => [ "[zeek][x509][certificate_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_issuer"
               rename => { "[zeek][x509][certificate_issuer]" => "[zeek][x509][certificate_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_issuer"
        field_split => ","
        source => "[zeek][x509][certificate_issuer_full]"
        target => "[zeek][x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer"
        field => "[zeek][x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer_full"
        field => "[zeek][x509][certificate_issuer_full]"
      }
      if ([zeek][x509][certificate_issuer][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_issuer_CN"
                 merge => { "[@metadata][cert][issuerCN]" => "[zeek][x509][certificate_issuer][CN]" } }
      }
      if ([zeek][x509][certificate_issuer][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_issuer_O"
                 add_field => { "[@metadata][cert][issuerON]" => "%{[zeek][x509][certificate_issuer][O]}" } }
      }
    }

    if ([zeek][x509][certificate_not_valid_before]) and ([zeek][x509][certificate_not_valid_after]) {
      ruby {
        id => "ruby_zeek_x509_valid_range"
        code => "event.set('[@metadata][cert][notBefore]', (1000*event.get('[zeek][x509][certificate_not_valid_before]').to_f).round(0))
                 event.set('[@metadata][cert][notAfter]', (1000*event.get('[zeek][x509][certificate_not_valid_after]').to_f).round(0))
                 event.set('[@metadata][cert][validDays]', ((event.get('[zeek][x509][certificate_not_valid_after]').to_f - event.get('[zeek][x509][certificate_not_valid_before]').to_f)/(24.0*60.0*60.0)).round(0))"
      }
      mutate {
        id => "mutate_convert_zeek_x509_time_range"
        convert => {
          "[@metadata][cert][notBefore]" => "integer"
          "[@metadata][cert][notAfter]" => "integer"
          "[@metadata][cert][validDays]" => "float"
        }
      }
    }

    if ([zeek][x509][certificate_serial]) {
      # todo: serial not showing up right...
      # ruby {
      #  id => "ruby_zeek_x509_serial"
      #  code => "event.set('[@metadata][cert][serial]', event.get('[certificate_serial]').unpack('C*').map {|e| e.to_s 16}.join(':'))"
      # }
      mutate { id => "mutate_add_field_zeek_x509_serial"
               add_field => { "[@metadata][cert][serial]" => "%{[zeek][x509][certificate_serial]}" } }
    }

    if ([@metadata][cert]) {
      ruby {
          id => "ruby_zeek_x509_cert_array_set"
          code => "
              certArray = Array.new
              certArray.push(event.get('[@metadata][cert]'))
              event.set('[cert]', certArray)"
      }
    }

    if ([zeek][x509][san_ip]) { mutate { id => "mutate_split_zeek_x509_san_ip"
                                        split => { "[zeek][x509][san_ip]" => "," } } }

    if ([zeek][x509][fingerprint]) { mutate { id => "mutate_split_zeek_x509_fingerprint"
                                             split => { "[zeek][x509][fingerprint]" => "," } } }

    # TODO: ECS TLS/X509 nestings?
    # - https://www.elastic.co/guide/en/ecs/current/ecs-tls.html#ecs-tls-nestings
    # - https://www.elastic.co/guide/en/ecs/current/ecs-x509.html#_field_reuse_27

  } # end if/else if/else for specific log type logic
  #######################################################################################################

  # rename log_source (eg., conn, ssh, etc.) to event.dataset
  mutate { id => "mutate_rename_zeek_logType"
           rename => { "[log_source]" => "[event][dataset]" } }

  # kind of a unique case, smb_cmd can also be smb_files
  if ([zeek][smb_files]) {

    if ([event][dataset] == "smb_cmd") {
      ruby { id => "ruby_add_field_zeek_tmp_logtype_smb_cmd"
             code => "event.set('[event][dataset]', [ 'smb_files', event.get('[event][dataset]') ].flatten.compact)" }
    }

    # ECS - zeek.smb_files.times_created -> file.created
    # ECS - zeek.smb_files.times_accessed -> file.accessed
    # ECS - zeek.smb_files.times_changed -> file.ctime
    # ECS - zeek.smb_files.times_modified -> file.mtime
    # ECS - zeek.smb_files.size -> file.size
    if ([zeek][smb_files][times_created]) {   mutate { id => "mutate_add_field_ecs_smb_created"
                                                      add_field => { "[file][created]" => "%{[zeek][smb_files][times_created]}" } } }

    if ([zeek][smb_files][times_accessed]) {  mutate { id => "mutate_add_field_ecs_smb_accessed"
                                                      add_field => { "[file][accessed]" => "%{[zeek][smb_files][times_accessed]}" } } }

    if ([zeek][smb_files][times_changed]) {   mutate { id => "mutate_add_field_ecs_smb_changed"
                                                      add_field => { "[file][ctime]" => "%{[zeek][smb_files][times_changed]}" } } }

    if ([zeek][smb_files][times_modified]) {  mutate { id => "mutate_add_field_ecs_smb_modified"
                                                      add_field => { "[file][mtime]" => "%{[zeek][smb_files][times_modified]}" } } }

    if ([zeek][smb_files][size]) {            mutate { id => "mutate_add_field_ecs_smb_size"
                                                      add_field => { "[file][size]" => "%{[zeek][smb_files][size]}" } } }

  } # end if ([zeek][smb_files])

  # ECS - event.kind based on event.dataset (https://www.elastic.co/guide/en/ecs/current/ecs-allowed-values-event-kind.html)
  if ([zeek][notice]) or ([zeek][signatures]) or ([zeek][weird]) {
    mutate { id => "mutate_add_field_ecs_event_kind_alert"
             add_field => { "[event][kind]" => "alert" } }
  } else {
    mutate { id => "mutate_add_field_ecs_event_kind_event"
             add_field => { "[event][kind]" => "event" } }
  }

} # end Filter
