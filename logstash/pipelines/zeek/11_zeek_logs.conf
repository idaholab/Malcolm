########################
# zeek -> moloch session creation and enrichment
#
# see https://docs.zeek.org/en/stable/script-reference/log-files.html for Zeek logfile documentation
#
# see source.zeeklogs.js for the Arkime code that turns these into UI fields
#
# this monstrosity can be used to profile:
#   $ curl -XGET http://localhost:9600/_node/stats/pipelines | python -mjson.tool | grep -P '"(id|duration_in_millis)":' | sed "s/.*: //" | sed ':a;N;$!ba;s/",\n/ /g' | sed "s/[\",]//g" | awk -F " " '{printf("%s %s\n", $2, $1)}' | sort -n
#
# Copyright (c) 2020 Battelle Energy Alliance, LLC.  All rights reserved.
#######################

filter {

  if (([message] =~ /^\s*#/) or (![log][file][path])) {
    drop { id => "drop_zeek_invalid_logs" }
  }

  # tags may have been specified, like: conn(tagA,tagB,tagC).log, extract the log type (conn) and the tags (tagA,tagB,tagC)
  ruby {
    id => "ruby_zeek_source_extract"
                                                                  #↓Type     ↓Tags
    code => "
      if fileParts = event.get('[log][file][path]').split('/').last.match(/^(.*?)(?:\((.*)\))?\.log/i) then
        logType, tags = fileParts.captures
        event.set('[source]', logType) unless logType.nil?
        event.set('[@metadata][zeek_log_tags]', tags) unless tags.nil?
      end"
  }

  # report types we're going to ignore
  if (([source] == "bsap_ip_unknown") or
      ([source] == "bsap_serial_unknown") or
      ([source] == "reporter") or
      ([source] == "broker") or
      ([source] == "cluster") or
      ([source] == "capture_loss") or
      ([source] == "communication") or
      ([source] == "packet_filter") or
      ([source] == "stats") or
      ([source] == "stderr") or
      ([source] == "stdout") or
      ([source] == "loaded_scripts")) {
    drop { id => "drop_zeek_ignored_source" }
  }

  # remove some tags pulled from the filename we might not want
  if ([@metadata][zeek_log_tags]) {
    ruby {
      id => "ruby_zeek_prune_tags"
      code => "
        filenameTags = event.get('[@metadata][zeek_log_tags]').split(',')
        zeekFieldsTag = filenameTags.select { |str| str.start_with?('ZEEKFLDx') }
        if (zeekFieldsTag.size > 0) then
          zeekFieldsTags = zeekFieldsTag.first.split('x', 3)
          if (zeekFieldsTags.size == 3) then
            event.set('[@metadata][zeek_fields_bitmap_version]', zeekFieldsTags[1].to_i(16))
            event.set('[@metadata][zeek_fields_bitmap]', zeekFieldsTags[2].to_i(16))
          end
        end
        filenameTags.delete_if{|v| ((v == nil) or (v == '') or (v !~ /\D/) or (v =~ /\A\s*(ZEEKFLDx|autocarve)/i) or (v =~ /\A\s*(pcap|dmp|log|bro|zeek|tcpdump|netsniff|autozeek)s?\s*\z/i) or (v == event.get('[source]')))}
        event.set('[@metadata][zeek_log_tags]', filenameTags.uniq)
      "
      #
      #  ZEEKFLDx00x01FFFFFF
      #  |      |  └ bitmap of included fields within field list
      #  |      └ index into zeek-log-field-bitmap.py:ZEEK_LOG_FIELDS list indicating field configuration within differing Zeek versions
      #  └ indicates that the field list has been pre-processed by zeek-process-pcap.py
      #
      # when logstash-filter-dissect gets this implemented, we *may* not have to do this
      #   - see zeek-process-pcap.py for the format of the bitmap number
      #   - https://github.com/logstash-plugins/logstash-filter-dissect/issues/56
      #   - https://github.com/logstash-plugins/logstash-filter-dissect/issues/62
      #
      # todo: right now rather than using the bitmap intelligently to build the field list, I'm just looking for
      # known preconfigurations. look into doing it "smart".
      #
    }
    if ([@metadata][zeek_log_tags]) { mutate { id => "mutate_merge_zeek_log_tags"
                                                  merge => { "[tags]" => "[@metadata][zeek_log_tags]" } } }
  }

  # The Dissect is WAY faster than CSV, and quite a bit faster than mutate.split. However, it
  # is not as flexible when it comes to missing or extra columns
  # (See https://github.com/logstash-plugins/logstash-filter-dissect/issues/62)
  #
  # So, if the dissect filter fails, we're going to fall back to split-then-zip solution.
  # This should be a good tradeoff between performance (in the case where the Zeek logs
  # match what we think they should look like) and flexibility (when they don't).
  #
  # The one drawback is that if you make a change to the fields in dissect, make sure
  # you make the corresponding change in the ruby init code.

  if ([source] == "conn") {
    #############################################################################################################################
    # conn.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/conn/main.zeek.html#type-Conn::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap conn.log field configuration version 0
      #
      # Todo: I need to just bite the bullet and code this up in a Ruby block rather than hardcoding values.
      #
      # vlan + mac + community_id:  0x3ffffff / 67108863
      # vlan + mac:                 0x1ffffff / 33554431
      # mac + community_id:         0x39fffff / 60817407
      # mac only:                   0x19fffff / 27262975
      # vlan + community_id:        0x27fffff / 41943039
      # vlan only:                   0x7fffff /  8388607
      # community_id only:           0x1fffff /  2097151
      # no custom fields:

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 67108863) {
          # conn.log has vlans + macs + community_id
          dissect {
            id => "dissect_zeek_conn_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 33554431) {
          # conn.log has vlans + macs
          dissect {
            id => "dissect_zeek_conn_with_vlan_and_mac_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 60817407) {
          # conn.log has macs + community_id
          dissect {
            id => "dissect_zeek_conn_with_mac_and_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 27262975) {
          # conn.log has macs
          dissect {
            id => "dissect_zeek_conn_with_mac_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 41943039) {
          # conn.log has vlans + community_id
          dissect {
            id => "dissect_zeek_conn_with_vlan_and_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {
          # conn.log has vlans
          dissect {
            id => "dissect_zeek_conn_with_vlan_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {
          # conn.log has community_id
          dissect {
            id => "dissect_zeek_conn_with_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {
          # conn.log has no custom fields
          dissect {
            id => "dissect_zeek_conn_with_minimal_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}"
            }
          }

        } else {
          # who knows? the conn.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_conn_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the conn.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_conn_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the conn.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_conn_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_conn"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_conn"
        init => "$zeek_conn_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'service', 'duration', 'orig_bytes', 'resp_bytes', 'conn_state', 'local_orig', 'local_resp', 'missed_bytes', 'history', 'orig_pkts', 'orig_ip_bytes', 'resp_pkts', 'resp_ip_bytes', 'tunnel_parents', 'vlan', 'inner_vlan', 'orig_l2_addr', 'resp_l2_addr', 'community_id' ]"
        code => "event.set('[zeek_cols]', $zeek_conn_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_field_zeek_conn_segmentCnt"
             add_field => { "[segmentCnt]" => "1" } }

    if ([zeek_cols][orig_ip_bytes]) and ([zeek_cols][orig_ip_bytes] != '-') and ([zeek_cols][orig_ip_bytes] != '(empty)') and ([zeek_cols][orig_ip_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_srcBytes"
               add_field => { "[srcBytes]" => "%{[zeek_cols][orig_ip_bytes]}" } }
    }
    if ([zeek_cols][resp_ip_bytes]) and ([zeek_cols][resp_ip_bytes] != '-') and ([zeek_cols][resp_ip_bytes] != '(empty)') and ([zeek_cols][resp_ip_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_dstBytes"
               add_field => { "[dstBytes]" => "%{[zeek_cols][resp_ip_bytes]}" } }
    }
    if ([zeek_cols][orig_pkts]) and ([zeek_cols][orig_pkts] != '-') and ([zeek_cols][orig_pkts] != '(empty)') and ([zeek_cols][orig_pkts] != '') {
      mutate { id => "mutate_add_field_zeek_srcPackets"
               add_field => { "[srcPackets]" => "%{[zeek_cols][orig_pkts]}" } }
    }
    if ([zeek_cols][orig_bytes]) and ([zeek_cols][orig_bytes] != '-') and ([zeek_cols][orig_bytes] != '(empty)') and ([zeek_cols][orig_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_srcDataBytes"
               add_field => { "[srcDataBytes]" => "%{[zeek_cols][orig_bytes]}" } }
    }
    if ([zeek_cols][resp_pkts]) and ([zeek_cols][resp_pkts] != '-') and ([zeek_cols][resp_pkts] != '(empty)') and ([zeek_cols][resp_pkts] != '') {
      mutate { id => "mutate_add_field_zeek_dstPackets"
               add_field => { "[dstPackets]" => "%{[zeek_cols][resp_pkts]}" } }
    }
    if ([zeek_cols][resp_bytes]) and ([zeek_cols][resp_bytes] != '-') and ([zeek_cols][resp_bytes] != '(empty)') and ([zeek_cols][resp_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_dstDataBytes"
               add_field => { "[dstDataBytes]" => "%{[zeek_cols][resp_bytes]}" } }
    }
    if ([zeek_cols][tunnel_parents]) and ([zeek_cols][tunnel_parents] != '(empty)') and ([zeek_cols][tunnel_parents] != '-') and ([zeek_cols][tunnel_parents] != '') {
      mutate { id => "mutate_split_zeek_tunnel_parents"
               split => { "[zeek_cols][tunnel_parents]" => "," } }
      mutate { id => "mutate_add_field_zeek_conn_rootId"
               add_field => { "[rootId]" => "%{[zeek_cols][tunnel_parents][0]}" } }
    }

  } else if ([source] == "bacnet") {
    #############################################################################################################################
    # bacnet.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][bvlc_function]}	%{[zeek_cols][pdu_type]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][invoke_id]}	%{[zeek_cols][result_code]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet"
        init => "$zeek_bacnet_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'bvlc_function', 'pdu_type', 'pdu_service', 'invoke_id', 'result_code' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
    }

  } else if ([source] == "bsap_ip_header") {
    #############################################################################################################################
    # bsap_ip_header.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_ip_header"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][num_msg]}	%{[zeek_cols][type_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_ip_header"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_ip_header"
        init => "$zeek_bsap_ip_header_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'num_msg', 'type_name' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_ip_header_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_ip_header"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bsap"
      }
    }

  } else if ([source] == "bsap_ip_rdb") {
    #############################################################################################################################
    # bsap_ip_rdb.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_ip_rdb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][header_size]}	%{[zeek_cols][mes_seq]}	%{[zeek_cols][res_seq]}	%{[zeek_cols][data_len]}	%{[zeek_cols][sequence]}	%{[zeek_cols][app_func_code]}	%{[zeek_cols][node_status]}	%{[zeek_cols][func_code]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_ip_rdb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_ip_rdb"
        init => "$zeek_bsap_ip_rdb_field_names = [ 'ts', 'uid', 'header_size', 'mes_seq', 'res_seq', 'data_len', 'sequence', 'app_func_code', 'node_status', 'func_code', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_ip_rdb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_ip_rdb"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bsap"
      }
    }

    # for now, drop hex-encoded binary data for size
    if ([zeek_cols][data]) {
      mutate { id => "mutate_remove_field_zeek_bsap_ip_rdb_data"
               remove_field => [ "[zeek_cols][data]" ] }
    }

  } else if ([source] == "bsap_ip_unknown") {
    #############################################################################################################################
    # bsap_ip_unknown.log (dropped for now, see above)
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_ip_unknown"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_ip_unknown"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_ip_unknown"
        init => "$zeek_bsap_ip_unknown_field_names = [ 'ts', 'uid', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_ip_unknown_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_ip_unknown"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bsap"
      }
    }

  } else if ([source] == "bsap_serial_header") {
    #############################################################################################################################
    # bsap_serial_header.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_header"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ser]}	%{[zeek_cols][dadd]}	%{[zeek_cols][sadd]}	%{[zeek_cols][ctl]}	%{[zeek_cols][dfun]}	%{[zeek_cols][seq]}	%{[zeek_cols][sfun]}	%{[zeek_cols][nsb]}	%{[zeek_cols][type_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_header"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_header"
        init => "$zeek_bsap_serial_header_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'ser', 'dadd', 'sadd', 'ctl', 'dfun', 'seq', 'sfun', 'nsb', 'type_name' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_header_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_header"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
    }

  } else if ([source] == "bsap_serial_rdb") {
    #############################################################################################################################
    # bsap_serial_rdb.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_rdb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][func_code]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_rdb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_rdb"
        init => "$zeek_bsap_serial_rdb_field_names = [ 'ts', 'uid', 'func_code', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_rdb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_rdb"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
    }

    # for now, drop hex-encoded binary data for size
    if ([zeek_cols][data]) {
      mutate { id => "mutate_remove_field_zeek_bsap_serial_rdb_data"
               remove_field => [ "[zeek_cols][data]" ] }
    }

  } else if ([source] == "bsap_serial_rdb_ext") {
    #############################################################################################################################
    # bsap_serial_rdb_ext.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_rdb_ext"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][dfun]}	%{[zeek_cols][seq]}	%{[zeek_cols][sfun]}	%{[zeek_cols][nsb]}	%{[zeek_cols][extfun]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_rdb_ext"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_rdb_ext"
        init => "$zeek_bsap_serial_rdb_ext_field_names = [ 'ts', 'uid', 'dfun', 'seq', 'sfun', 'nsb', 'extfun', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_rdb_ext_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_rdb_ext"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
    }

    # for now, drop hex-encoded binary data for size
    if ([zeek_cols][data]) {
      mutate { id => "mutate_remove_field_zeek_bsap_serial_rdb_ext_data"
               remove_field => [ "[zeek_cols][data]" ] }
    }

  } else if ([source] == "bsap_serial_unknown") {
    #############################################################################################################################
    # bsap_serial_unknown.log (dropped for now, see above)
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bsap_serial_unknown"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bsap_serial_unknown"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bsap_serial_unknown"
        init => "$zeek_bsap_serial_unknown_field_names = [ 'ts', 'uid', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_bsap_serial_unknown_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bsap_serial_unknown"
      add_field => {
        "[zeek_cols][proto]" => "serial"
        "[zeek_cols][service]" => "bsap"
      }
    }

  } else if ([source] == "bacnet_discovery") {
    #############################################################################################################################
    # bacnet_discovery.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet_discovery"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][object_type]}	%{[zeek_cols][instance_number]}	%{[zeek_cols][vendor]}	%{[zeek_cols][range]}	%{[zeek_cols][object_name]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet_discovery"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet_discovery"
        init => "$zeek_bacnet_discovery_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'pdu_service', 'object_type', 'instance_number', 'vendor', 'range', 'object_name' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_discovery_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet_discovery"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
    }

  } else if ([source] == "bacnet_property") {
    #############################################################################################################################
    # bacnet_property.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_bacnet_property"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][pdu_service]}	%{[zeek_cols][object_type]}	%{[zeek_cols][instance_number]}	%{[zeek_cols][property]}	%{[zeek_cols][array_index]}	%{[zeek_cols][value]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet_property"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet_property"
        init => "$zeek_bacnet_property_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'pdu_service', 'object_type', 'instance_number', 'property', 'array_index', 'value' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_property_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet_property"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
    }

  } else if ([source] == "cip") {
    #############################################################################################################################
    # cip.log
    # https://github.com/idaholab/ICSNPP
    #
    # todo: class_id, instance_id is a hex integer, should it be converted to an integer?

    dissect {
      id => "dissect_zeek_cip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cip_sequence_count]}	%{[zeek_cols][direction]}	%{[zeek_cols][cip_service]}	%{[zeek_cols][cip_status]}	%{[zeek_cols][class_id]}	%{[zeek_cols][class_name]}	%{[zeek_cols][instance_id]}	%{[zeek_cols][attribute_id]}	%{[zeek_cols][data_id]}	%{[zeek_cols][other_id]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip"
        init => "$zeek_cip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cip_sequence_count', 'direction', 'cip_service', 'cip_status', 'class_id', 'class_name', 'instance_id', 'attribute_id', 'data_id', 'other_id' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip"
      add_field => { "[zeek_cols][service]" => "cip" }
    }

  } else if ([source] == "cip_identity") {
    #############################################################################################################################
    # cip_identity.log
    # https://github.com/idaholab/ICSNPP
    #
    # TODO: device_status and device_state are a hex int string, convert to int?

    dissect {
      id => "dissect_zeek_cip_identity"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][encapsulation_version]}	%{[zeek_cols][socket_address]}	%{[zeek_cols][socket_port]}	%{[zeek_cols][vendor_id]}	%{[zeek_cols][vendor_name]}	%{[zeek_cols][device_type_id]}	%{[zeek_cols][device_type_name]}	%{[zeek_cols][product_code]}	%{[zeek_cols][revision]}	%{[zeek_cols][device_status]}	%{[zeek_cols][serial_number]}	%{[zeek_cols][product_name]}	%{[zeek_cols][device_state]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip_identity"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip_identity"
        init => "$zeek_cip_identity_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'encapsulation_version', 'socket_address', 'socket_port', 'vendor_id', 'vendor_name', 'device_type_id', 'device_type_name', 'product_code', 'device_status', 'serial_number', 'product_name', 'device_state' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_identity_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip_identity"
      add_field => { "[zeek_cols][service]" => "cip" }
    }

  } else if ([source] == "cip_io") {
    #############################################################################################################################
    # cip_io.log
    # https://github.com/idaholab/ICSNPP
    #

    dissect {
      id => "dissect_zeek_cip_io"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][connection_id]}	%{[zeek_cols][sequence_number]}	%{[zeek_cols][data_length]}	%{[zeek_cols][io_data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip_io"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip_io"
        init => "$zeek_cip_io_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'connection_id', 'sequence_number', 'data_length', 'io_data' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_io_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip_io"
      add_field => { "[zeek_cols][service]" => "cip" }
    }

    # for now, drop hex-encoded binary io_data for size
    if ([zeek_cols][io_data]) {
      mutate { id => "mutate_remove_field_zeek_cip_io_io_data"
               remove_field => [ "[zeek_cols][io_data]" ] }
    }

  } else if ([source] == "dce_rpc") {
    #############################################################################################################################
    # dce_rpc.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dce-rpc/main.zeek.html#type-DCE_RPC::Info

    dissect {
      id => "dissect_zeek_dce_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][rtt]}	%{[zeek_cols][named_pipe]}	%{[zeek_cols][endpoint]}	%{[zeek_cols][operation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dce_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dce_rpc"
        init => "$zeek_dce_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'rtt', 'named_pipe', 'endpoint', 'operation' ]"
        code => "event.set('[zeek_cols]', $zeek_dce_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dce_rpc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "dce_rpc"
      }
    }

  } else if ([source] == "dhcp") {
    #############################################################################################################################
    # dhcp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dhcp/main.zeek.html#type-DHCP::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap dhcp.log field configuration version 0
      #
      # all fields: 0x000003FF / 1023
      #
      # bitmap dhcp.log field configuration version 1
      #
      # all fields               : 0x0001FFFF / 131071
      # all fields minus software: 0x00007FFF /  32767

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 1023) {
          dissect {
            id => "dissect_zeek_dhcp_0_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][assigned_ip]}	%{[zeek_cols][lease_time]}	%{[zeek_cols][trans_id]}"
            }
          }

        } else {
          # who knows? the dhcp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_dhcp_0_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else if ([@metadata][zeek_fields_bitmap_version] == 1) {

        if ([@metadata][zeek_fields_bitmap] == 131071) {
          dissect {
            id => "dissect_zeek_dhcp_1_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][host_name]}	%{[zeek_cols][client_fqdn]}	%{[zeek_cols][domain]}	%{[zeek_cols][requested_ip]}	%{[zeek_cols][assigned_ip]}	%{[zeek_cols][lease_time]}	%{[zeek_cols][client_message]}	%{[zeek_cols][server_message]}	%{[zeek_cols][msg_types]}	%{[zeek_cols][duration]}	%{[zeek_cols][client_software]}	%{[zeek_cols][server_software]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 32767) {
          dissect {
            id => "dissect_zeek_dhcp_1_with_all_fields_minus_software"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][host_name]}	%{[zeek_cols][client_fqdn]}	%{[zeek_cols][domain]}	%{[zeek_cols][requested_ip]}	%{[zeek_cols][assigned_ip]}	%{[zeek_cols][lease_time]}	%{[zeek_cols][client_message]}	%{[zeek_cols][server_message]}	%{[zeek_cols][msg_types]}	%{[zeek_cols][duration]}"
            }
          }

        } else {
          # who knows? the dhcp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_dhcp_1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the dhcp.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_dhcp_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the dhcp.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_dhcp_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dhcp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dhcp"
        init => "$zeek_dhcp_field_names = [ 'ts', 'uid', 'orig_h', 'resp_h', 'orig_l2_addr', 'host_name', 'client_fqdn', 'domain', 'requested_ip', 'assigned_ip', 'lease_time', 'client_message', 'server_message', 'msg_types', 'duration', 'client_software', 'server_software' ]"
        code => "event.set('[zeek_cols]', $zeek_dhcp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if ([zeek_cols][uid]) and ([zeek_cols][uid] != '(empty)') and ([zeek_cols][uid] != '') {
      mutate { id => "mutate_split_zeek_dhcp_uids"
               split => { "[zeek_cols][uid]" => "," } }
    }
    if ([zeek_cols][uid] and [zeek_cols][uid][0]) {
      mutate { id => "mutate_add_field_zeek_dhcp_uids"
               add_field => { "[rootId]" => "%{[zeek_cols][uid][0]}" } }
    }

    if ((![zeek_cols][orig_p]) and (![zeek_cols][resp_p])) {
      mutate {
        id => "mutate_add_field_zeek_dhcp_ports"
        add_field => {
          "[zeek_cols][orig_p]" => 68
          "[zeek_cols][resp_p]" => 67
        }
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dhcp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "dhcp"
      }
    }

  } else if ([source] == "dnp3") {
    #############################################################################################################################
    # dnp3.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dnp3/main.zeek.html#type-DNP3::Info

    dissect {
      id => "dissect_zeek_dnp3"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fc_request]}	%{[zeek_cols][fc_reply]}	%{[zeek_cols][iin]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3"
        init => "$zeek_dnp3_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fc_request', 'fc_reply', 'iin' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3"
      add_field => { "[zeek_cols][service]" => "dnp3" }
    }

  } else if ([source] == "dnp3_control") {
    #############################################################################################################################
    # dnp3_control.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_dnp3_control"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][block_type]}	%{[zeek_cols][function_code]}	%{[zeek_cols][index_number]}	%{[zeek_cols][trip_control_code]}	%{[zeek_cols][operation_type]}	%{[zeek_cols][execute_count]}	%{[zeek_cols][on_time]}	%{[zeek_cols][off_time]}	%{[zeek_cols][status_code]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3_control"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3_control"
        init => "$zeek_dnp3_control_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'block_type', 'function_code', 'index_number', 'trip_control_code', 'operation_type', 'execute_count', 'on_time', 'off_time', 'status_code' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_control_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3_control"
      add_field => { "[zeek_cols][service]" => "dnp3" }
    }

  } else if ([source] == "dnp3_objects") {
    #############################################################################################################################
    # dnp3_objects.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_dnp3_objects"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][function_code]}	%{[zeek_cols][object_type]}	%{[zeek_cols][object_count]}	%{[zeek_cols][range_low]}	%{[zeek_cols][range_high]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3_objects"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3_objects"
        init => "$zeek_dnp3_objects_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'function_code', 'object_type', 'object_count', 'range_low', 'range_high' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_objects_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3_objects"
      add_field => { "[zeek_cols][service]" => "dnp3" }
    }

  } else if ([source] == "dns") {
    #############################################################################################################################
    # dns.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/dns/main.zeek.html#type-DNS::Info

    dissect {
      id => "dissect_zeek_dns"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][trans_id]}	%{[zeek_cols][rtt]}	%{[zeek_cols][query]}	%{[zeek_cols][qclass]}	%{[zeek_cols][qclass_name]}	%{[zeek_cols][qtype]}	%{[zeek_cols][qtype_name]}	%{[zeek_cols][rcode]}	%{[zeek_cols][rcode_name]}	%{[zeek_cols][AA]}	%{[zeek_cols][TC]}	%{[zeek_cols][RD]}	%{[zeek_cols][RA]}	%{[zeek_cols][Z]}	%{[zeek_cols][answers]}	%{[zeek_cols][TTLs]}	%{[zeek_cols][rejected]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dns"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dns"
        init => "$zeek_dns_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'trans_id', 'rtt', 'query', 'qclass', 'qclass_name', 'qtype', 'qtype_name', 'rcode', 'rcode_name', 'AA', 'TC', 'RD', 'RA', 'Z', 'answers', 'TTLs', 'rejected' ]"
        code => "event.set('[zeek_cols]', $zeek_dns_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    # remove C_ prefix from qclass_name
    mutate { id => "mutate_gsub_field_zeek_dns_qclass_name"
             gsub => [ "[zeek_cols][qclass_name]", "^C_", "" ] }

    mutate {
      id => "mutate_add_fields_zeek_dns"
      add_field => { "[zeek_cols][service]" => "dns" }
    }

  } else if ([source] == "dpd") {
    #############################################################################################################################
    # dpd.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/dpd/main.zeek.html#type-DPD::Info

    dissect {
      id => "dissect_zeek_dpd"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][failure_reason]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dpd"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dpd"
        init => "$zeek_dpd_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'service', 'failure_reason' ]"
        code => "event.set('[zeek_cols]', $zeek_dpd_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_lowercase_zeek_dpd_service"
             lowercase => [ "[zeek_cols][service]" ] }

  } else if ([source] == "enip") {
    #############################################################################################################################
    # enip.log
    # https://github.com/idaholab/ICSNPP
    #

    dissect {
      id => "dissect_zeek_enip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][enip_command]}	%{[zeek_cols][length]}	%{[zeek_cols][session_handle]}	%{[zeek_cols][enip_status]}	%{[zeek_cols][sender_context]}	%{[zeek_cols][options]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_enip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_enip"
        init => "$zeek_enip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'enip_command', 'length', 'session_handle', 'enip_status', 'sender_context', 'options' ]"
        code => "event.set('[zeek_cols]', $zeek_enip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_enip"
      add_field => { "[zeek_cols][service]" => "enip" }
    }

  } else if ([source] == "files") {
    #############################################################################################################################
    # files.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/files/main.zeek.html#type-Files::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap files.log field configuration version 0
      #
      # all fields (with extracted file size info) :    0x01FFFFFF / 33554431
      # all fields (without extracted file size info) : 0x007FFFFF / 8388607

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 33554431) {

          dissect {
            id => "dissect_zeek_files_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][tx_hosts]}	%{[zeek_cols][rx_hosts]}	%{[zeek_cols][conn_uids]}	%{[zeek_cols][source]}	%{[zeek_cols][depth]}	%{[zeek_cols][analyzers]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][filename]}	%{[zeek_cols][duration]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][seen_bytes]}	%{[zeek_cols][total_bytes]}	%{[zeek_cols][missing_bytes]}	%{[zeek_cols][overflow_bytes]}	%{[zeek_cols][timedout]}	%{[zeek_cols][parent_fuid]}	%{[zeek_cols][md5]}	%{[zeek_cols][sha1]}	%{[zeek_cols][sha256]}	%{[zeek_cols][extracted]}	%{[zeek_cols][extracted_cutoff]}	%{[zeek_cols][extracted_size]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {

          dissect {
            id => "dissect_zeek_files_with_all_fields_minus_extract_size"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][tx_hosts]}	%{[zeek_cols][rx_hosts]}	%{[zeek_cols][conn_uids]}	%{[zeek_cols][source]}	%{[zeek_cols][depth]}	%{[zeek_cols][analyzers]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][filename]}	%{[zeek_cols][duration]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][seen_bytes]}	%{[zeek_cols][total_bytes]}	%{[zeek_cols][missing_bytes]}	%{[zeek_cols][overflow_bytes]}	%{[zeek_cols][timedout]}	%{[zeek_cols][parent_fuid]}	%{[zeek_cols][md5]}	%{[zeek_cols][sha1]}	%{[zeek_cols][sha256]}	%{[zeek_cols][extracted]}"
            }
          }

        } else {
          # who knows? the files.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_files_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the files.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_files_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the files.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_files_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_files"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_files"
        init => "$zeek_files_field_names = [ 'ts', 'fuid', 'tx_hosts', 'rx_hosts', 'conn_uids', 'source', 'depth', 'analyzers', 'mime_type', 'filename', 'duration', 'local_orig', 'is_orig', 'seen_bytes', 'total_bytes', 'missing_bytes', 'overflow_bytes', 'timedout', 'parent_fuid', 'md5', 'sha1', 'sha256', 'extracted', 'extracted_cutoff', 'extracted_size' ]"
        code => "event.set('[zeek_cols]', $zeek_files_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_files"
      add_field =>  { "[zeek_cols][uid]" => "%{[zeek_cols][fuid]}" }
    }

    if ([zeek_cols][conn_uids]) and ([zeek_cols][conn_uids] != '(empty)') and ([zeek_cols][conn_uids] != '') {
      mutate { id => "mutate_split_zeek_files_conn_uids"
               split => { "[zeek_cols][conn_uids]" => "," } }
    }
    if ([zeek_cols][tx_hosts]) and ([zeek_cols][tx_hosts] != '(empty)') and ([zeek_cols][tx_hosts] != '') {
      mutate { id => "mutate_split_zeek_files_tx_hosts"
               split => { "[zeek_cols][tx_hosts]" => "," } }
    }
    if ([zeek_cols][rx_hosts]) and ([zeek_cols][rx_hosts] != '(empty)') and ([zeek_cols][rx_hosts] != '') {
      mutate { id => "mutate_split_zeek_files_rx_hosts"
               split => { "[zeek_cols][rx_hosts]" => "," } }
    }

    if ([zeek_cols][conn_uids] and [zeek_cols][conn_uids][0]) {
      mutate { id => "mutate_add_field_zeek_files_conn_uids"
               add_field => { "[rootId]" => "%{[zeek_cols][conn_uids][0]}" } }
    }

    if ([zeek_cols][tx_hosts] and [zeek_cols][tx_hosts][0]) {
      mutate { id => "mutate_add_field_zeek_tx_hosts"
               add_field => { "[srcIp]" => "%{[zeek_cols][tx_hosts][0]}" } }
    }

    if ([zeek_cols][rx_hosts] and [zeek_cols][rx_hosts][0]) {
      mutate { id => "mutate_add_field_zeek_rx_hosts"
               add_field => { "[dstIp]" => "%{[zeek_cols][rx_hosts][0]}" } }
    }

  } else if ([source] == "ftp") {
    #############################################################################################################################
    # ftp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ftp/info.zeek.html#type-FTP::Info

    dissect {
      id => "dissect_zeek_ftp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][command]}	%{[zeek_cols][arg]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][file_size]}	%{[zeek_cols][reply_code]}	%{[zeek_cols][reply_msg]}	%{[zeek_cols][data_channel_passive]}	%{[zeek_cols][data_channel_orig_h]}	%{[zeek_cols][data_channel_resp_h]}	%{[zeek_cols][data_channel_resp_p]}	%{[zeek_cols][fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ftp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ftp"
        init => "$zeek_ftp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'password', 'command', 'arg', 'mime_type', 'file_size', 'reply_code', 'reply_msg', 'data_channel_passive', 'data_channel_orig_h', 'data_channel_resp_h', 'data_channel_resp_p', 'fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_ftp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ftp"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "ftp"
      }
    }

  } else if ([source] == "gquic") {
    #############################################################################################################################
    # gquic.log
    # https://github.com/salesforce/GQUIC_Protocol_Analyzer/blob/master/scripts/Salesforce/GQUIC/main.bro

    dissect {
      id => "dissect_zeek_gquic"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][server_name]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][tag_count]}	%{[zeek_cols][cyu]}	%{[zeek_cols][cyutags]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_gquic"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_gquic"
        init => "$zeek_gquic_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'server_name', 'user_agent', 'tag_count', 'cyu', 'cyutags' ]"
        code => "event.set('[zeek_cols]', $zeek_gquic_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_gquic"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "quic"
      }
    }

  } else if ([source] == "http") {
    #############################################################################################################################
    # http.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/http/main.zeek.html#type-HTTP::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap http.log field configuration version 0
      # all fields:                                       0x7FFFFFFFF / 34359738367
      # minus fields added by zeek-sniffpass:             0x03FFFFFFF /  1073741823
      # minus origin and fields added by zeek-sniffpass:  0x03FFFDFFF /  1073733631

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 34359738367) {
          dissect {
            id => "dissect_zeek_http_0_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][origin]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}	%{[zeek_cols][post_username]}	%{[zeek_cols][post_password_plain]}	%{[zeek_cols][post_password_md5]}	%{[zeek_cols][post_password_sha1]}	%{[zeek_cols][post_password_sha256]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 1073741823) {
          dissect {
            id => "dissect_zeek_http_0_with_all_fields_minus_sniffpass"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][origin]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 1073733631) {
          dissect {
            id => "dissect_zeek_http_0_with_all_fields_minus_origin"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}"
            }
          }

        } else {
          # who knows? the http.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_http_1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the http.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_http_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the http.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_http_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_http"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_http"
        init => "$zeek_http_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'method', 'host', 'uri', 'referrer', 'version', 'user_agent', 'origin', 'request_body_len', 'response_body_len', 'status_code', 'status_msg', 'info_code', 'info_msg', 'tags', 'user', 'password', 'proxied', 'orig_fuids', 'orig_filenames', 'orig_mime_types', 'resp_fuids', 'resp_filenames', 'resp_mime_types', 'post_username', 'post_password_plain', 'post_password_md5', 'post_password_sha1', 'post_password_sha256' ]"
        code => "event.set('[zeek_cols]', $zeek_http_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_http"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "http"
      }
    }

  } else if ([source] == "intel") {
    #############################################################################################################################
    # intel.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/intel/main.zeek.html#type-Intel::Info

    dissect {
      id => "dissect_zeek_intel"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][indicator]}	%{[zeek_cols][indicator_type]}	%{[zeek_cols][seen_where]}	%{[zeek_cols][seen_node]}	%{[zeek_cols][matched]}	%{[zeek_cols][sources]}	%{[zeek_cols][fuid]}	%{[zeek_cols][file_mime_type]}	%{[zeek_cols][file_desc]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_intel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_intel"
        init => "$zeek_intel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'indicator', 'indicator_type', 'seen_where', 'seen_node', 'matched', 'sources', 'fuid', 'file_mime_type', 'file_desc' ]"
        code => "event.set('[zeek_cols]', $zeek_intel_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_intel"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "intel"
      }
    }

  } else if ([source] == "irc") {
    #############################################################################################################################
    # irc.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/irc/main.zeek.html#type-IRC::Info

    dissect {
      id => "dissect_zeek_irc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][nick]}	%{[zeek_cols][user]}	%{[zeek_cols][command]}	%{[zeek_cols][value]}	%{[zeek_cols][addl]}	%{[zeek_cols][dcc_file_name]}	%{[zeek_cols][dcc_file_size]}	%{[zeek_cols][dcc_mime_type]}	%{[zeek_cols][fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_irc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_irc"
        init => "$zeek_irc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'nick', 'user', 'command', 'value', 'addl', 'dcc_file_name', 'dcc_file_size', 'dcc_mime_type', 'fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_irc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_irc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "irc"
      }
    }

  } else if ([source] == "iso_cotp") {
    #############################################################################################################################
    # iso_cotp.log
    # https://github.com/amzn/zeek-plugin-s7comm/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_iso_cotp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][pdu_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_iso_cotp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_iso_cotp"
        init => "$zeek_iso_cotp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'pdu_type' ]"
        code => "event.set('[zeek_cols]', $zeek_iso_cotp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_iso_cotp"
      add_field =>  { "[zeek_cols][service]" => "cotp" }
    }

  } else if ([source] == "kerberos") {
    #############################################################################################################################
    # kerberos.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/krb/main.zeek.html#type-KRB::Info

    dissect {
      id => "dissect_zeek_kerberos"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][request_type]}	%{[zeek_cols][cname]}	%{[zeek_cols][sname]}	%{[zeek_cols][success]}	%{[zeek_cols][error_msg]}	%{[zeek_cols][from]}	%{[zeek_cols][till]}	%{[zeek_cols][cipher]}	%{[zeek_cols][forwardable]}	%{[zeek_cols][renewable]}	%{[zeek_cols][client_cert_subject]}	%{[zeek_cols][client_cert_fuid]}	%{[zeek_cols][server_cert_subject]}	%{[zeek_cols][server_cert_fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_kerberos"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_kerberos"
        init => "$zeek_kerberos_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'request_type', 'cname', 'sname', 'success', 'error_msg', 'from', 'till', 'cipher', 'forwardable', 'renewable', 'client_cert_subject', 'client_cert_fuid', 'server_cert_subject', 'server_cert_fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_kerberos_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_krb5"
      add_field =>  { "[zeek_cols][service]" => "krb5" }
    }

  } else if ([source] == "known_certs") {
    #############################################################################################################################
    # known_certs.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/ssl/known-certs.zeek.html#type-Known::CertsInfo

    dissect {
      id => "dissect_zeek_known_certs"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][subject]}	%{[zeek_cols][issuer_subject]}	%{[zeek_cols][serial]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_certs"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_certs"
        init => "$zeek_known_certs_field_names = [ 'ts', 'orig_h', 'orig_p', 'subject', 'resp_h', 'issuer_subject', 'serial' ]"
        code => "event.set('[zeek_cols]', $zeek_known_certs_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_known_certs"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tls"
      }
    }

  } else if ([source] == "known_hosts") {
    #############################################################################################################################
    # known_hosts.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/conn/known-hosts.zeek.html#type-Known::HostsInfo

    dissect {
      id => "dissect_zeek_known_hosts"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_hosts"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_hosts"
        init => "$zeek_known_hosts_field_names = [ 'ts', 'orig_h' ]"
        code => "event.set('[zeek_cols]', $zeek_known_hosts_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "known_modbus") {
    #############################################################################################################################
    # known_modbus.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/modbus/known-masters-slaves.zeek.html#type-Known::ModbusInfo

    dissect {
      id => "dissect_zeek_known_modbus"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][device_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_modbus"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_modbus"
        init => "$zeek_known_modbus_field_names = [ 'ts', 'orig_h', 'device_type' ]"
        code => "event.set('[zeek_cols]', $zeek_known_modbus_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_gsub_zeek_known_modbus_device_type"
             gsub => [ "[zeek_cols][device_type]", "Known::", "" ] }

  } else if ([source] == "known_services") {
    #############################################################################################################################
    # known_services.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/conn/known-services.zeek.html#type-Known::ServicesInfo

    dissect {
      id => "dissect_zeek_known_services"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_services"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_services"
        init => "$zeek_known_services_field_names = [ 'ts', 'resp_h', 'resp_p', 'proto', 'service' ]"
        code => "event.set('[zeek_cols]', $zeek_known_services_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_lowercase_zeek_known_services_service"
             lowercase => [ "[zeek_cols][service]" ] }

  } else if ([source] == "ldap") {
    #############################################################################################################################
    # ldap.log
    # https://github.com/SoftwareConsultingEmporium/ldap-analyzer/blob/master/scripts/main.bro
    # todo: UID doesn't exist in this plugin?

    dissect {
      id => "dissect_zeek_ldap"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][message_id]}	%{[zeek_cols][operation]}	%{[zeek_cols][value]}	%{[zeek_cols][entry]}	%{[zeek_cols][result_code]}	%{[zeek_cols][error]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ldap"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ldap"
        init => "$zeek_ldap_field_names = [ 'ts', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'message_id', 'operation', 'value', 'entry', 'result_code', 'error' ]"
        code => "event.set('[zeek_cols]', $zeek_ldap_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ldap"
      add_field =>  { "[zeek_cols][service]" => "ldap" }
    }

  } else if ([source] == "login") {
    #############################################################################################################################
    # login.log
    # custom login.log module (rudimentary, telnet/rlogin/rsh analyzers are old and not the greatest)

    dissect {
      id => "dissect_zeek_login"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][success]}	%{[zeek_cols][confused]}	%{[zeek_cols][user]}	%{[zeek_cols][client_user]}	%{[zeek_cols][password]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_login"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_login"
        init => "$zeek_login_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'success', 'confused', 'user', 'client_user', 'password' ]"
        code => "event.set('[zeek_cols]', $zeek_login_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if ([zeek_cols][proto]) and ([zeek_cols][proto] != '-') and ([zeek_cols][proto] != '(empty)') and ([zeek_cols][proto] != '') {
      mutate { id => "mutate_add_field_zeek_login_service"
               add_field => { "[zeek_cols][service]" => "%{[zeek_cols][proto]}" } }
    }

  } else if ([source] == "modbus") {
    #############################################################################################################################
    # modbus.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/modbus/main.zeek.html#type-Modbus::Info

    dissect {
      id => "dissect_zeek_modbus"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][func]}	%{[zeek_cols][exception]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus"
        init => "$zeek_modbus_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'func', 'exception' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
    }

  } else if ([source] == "modbus_detailed") {
    #############################################################################################################################
    # modbus_detailed.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_modbus_detailed"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][unit_id]}	%{[zeek_cols][func]}	%{[zeek_cols][network_direction]}	%{[zeek_cols][address]}	%{[zeek_cols][quantity]}	%{[zeek_cols][values]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_detailed"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_detailed"
        init => "$zeek_modbus_detailed_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'unit_id', 'func', 'network_direction', 'address', 'quantity', 'values' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_detailed_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus_detailed"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
    }

  } else if ([source] == "modbus_mask_write_register") {
    #############################################################################################################################
    # modbus_mask_write_register.log
    # https://github.com/idaholab/ICSNPP

    dissect {
      id => "dissect_zeek_modbus_mask_write_register"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][unit_id]}	%{[zeek_cols][func]}	%{[zeek_cols][network_direction]}	%{[zeek_cols][address]}	%{[zeek_cols][and_mask]}	%{[zeek_cols][or_mask]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_mask_write_register"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_mask_write_register"
        init => "$zeek_modbus_mask_write_register_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'unit_id', 'func', 'network_direction', 'address', 'and_mask', 'or_mask' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_modbus_mask_write_register_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_modbus_mask_write_register"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
    }

  } else if ([source] == "modbus_read_write_multiple_registers") {
    #############################################################################################################################
    # modbus_read_write_multiple_registers.log
    # https://github.com/idaholab/ICSNPP
    dissect {
      id => "dissect_zeek_modbus_read_write_multiple_registers"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][unit_id]}	%{[zeek_cols][func]}	%{[zeek_cols][network_direction]}	%{[zeek_cols][write_start_address]}	%{[zeek_cols][write_registers]}	%{[zeek_cols][read_start_address]}	%{[zeek_cols][read_quantity]}	%{[zeek_cols][read_registers]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_read_write_multiple_registers"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_read_write_multiple_registers"
        init => "$zeek_modbus_read_write_multiple_registers_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'unit_id', 'func', 'network_direction', 'write_start_address', 'write_registers', 'read_start_address', 'read_quantity', 'read_registers' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_read_write_multiple_registers_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus_read_write_multiple_registers"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
    }

  } else if ([source] == "modbus_register_change") {
    #############################################################################################################################
    # modbus_register_change.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/modbus/track-memmap.zeek.html#type-Modbus::MemmapInfo

    dissect {
      id => "dissect_zeek_modbus_register_change"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][register]}	%{[zeek_cols][old_val]}	%{[zeek_cols][new_val]}	%{[zeek_cols][delta]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus_register_change"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus_register_change"
        init => "$zeek_modbus_register_change_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'register', 'old_val', 'new_val', 'delta' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_register_change_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus_register_change"
      add_field =>  { "[zeek_cols][service]" => "modbus" }
    }

  } else if ([source] == "mqtt_connect") {
    #############################################################################################################################
    # mqtt_connect.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/mqtt/main.zeek.html#type-MQTT::ConnectInfo

    dissect {
      id => "dissect_zeek_mqtt_connect"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto_name]}	%{[zeek_cols][proto_version]}	%{[zeek_cols][client_id]}	%{[zeek_cols][connect_status]}	%{[zeek_cols][will_topic]}	%{[zeek_cols][will_payload]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_connect"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_connect"
        init => "$zeek_mqtt_connect_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto_name', 'proto_version', 'client_id', 'connect_status', 'will_topic', 'will_payload' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_connect_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mqtt_connect"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

  } else if ([source] == "mqtt_publish") {
    #############################################################################################################################
    # mqtt_publish.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/mqtt/main.zeek.html#type-MQTT::PublishInfo

    dissect {
      id => "dissect_zeek_mqtt_publish"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][from_client]}	%{[zeek_cols][retain]}	%{[zeek_cols][qos]}	%{[zeek_cols][status]}	%{[zeek_cols][topic]}	%{[zeek_cols][payload]}	%{[zeek_cols][payload_len]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_publish"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_publish"
        init => "$zeek_mqtt_publish_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'from_client', 'retain', 'qos', 'status', 'topic', 'payload', 'payload_len' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_publish_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mqtt_publish"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

  } else if ([source] == "mqtt_subscribe") {
    #############################################################################################################################
    # mqtt_subscribe.log
    # https://docs.zeek.org/en/stable/scripts/policy/protocols/mqtt/main.zeek.html#type-MQTT::SubscribeInfo

    dissect {
      id => "dissect_zeek_mqtt_subscribe"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][action]}	%{[zeek_cols][topics]}	%{[zeek_cols][qos_levels]}	%{[zeek_cols][granted_qos_level]}	%{[zeek_cols][ack]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_subscribe"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_subscribe"
        init => "$zeek_mqtt_subscribe_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'action', 'topics', 'qos_levels', 'granted_qos_level', 'ack' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_subscribe_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mqtt_subscribe"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

    mutate { id => "mutate_gsub_zeek_mqtt_subscribe_action"
             gsub => [ "[zeek_cols][action]", "MQTT::", "" ] }

  } else if ([source] == "mysql") {
    #############################################################################################################################
    # mysql.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/mysql/main.zeek.html#type-MySQL::Info

    dissect {
      id => "dissect_zeek_mysql"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cmd]}	%{[zeek_cols][arg]}	%{[zeek_cols][success]}	%{[zeek_cols][rows]}	%{[zeek_cols][response]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mysql"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mysql"
        init => "$zeek_mysql_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cmd', 'arg', 'success', 'rows', 'response' ]"
        code => "event.set('[zeek_cols]', $zeek_mysql_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mysql"
      add_field =>  { "[zeek_cols][service]" => "mysql" }
    }

  } else if ([source] == "notice") {
    #############################################################################################################################
    # notice.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/notice/main.zeek.html#type-Notice::Info

    dissect {
      id => "dissect_zeek_notice"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][file_mime_type]}	%{[zeek_cols][file_desc]}	%{[zeek_cols][proto]}	%{[zeek_cols][note]}	%{[zeek_cols][msg]}	%{[zeek_cols][sub]}	%{[zeek_cols][src]}	%{[zeek_cols][dst]}	%{[zeek_cols][p]}	%{[zeek_cols][n]}	%{[zeek_cols][peer_descr]}	%{[zeek_cols][actions]}	%{[zeek_cols][suppress_for]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_notice"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_notice"
        init => "$zeek_notice_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fuid', 'file_mime_type', 'file_desc', 'proto', 'note', 'msg', 'sub', 'src', 'dst', 'p', 'n', 'peer_descr', 'actions', 'suppress_for', 'remote_location_country_code', 'remote_location_region', 'remote_location_city', 'remote_location_latitude', 'remote_location_longitude' ]"
        code => "event.set('[zeek_cols]', $zeek_notice_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if (![zeek_cols][orig_h])       or ([zeek_cols][orig_h] == '(empty)') or
       ([zeek_cols][orig_h] == '-') or ([zeek_cols][orig_h] == '') {
      mutate { id => "mutate_replace_zeek_notice_orig_h"
               replace => { "[zeek_cols][orig_h]" => "%{[zeek_cols][src]}" } }
    }
    if (![zeek_cols][resp_h])       or ([zeek_cols][resp_h] == '(empty)') or
       ([zeek_cols][resp_h] == '-') or ([zeek_cols][resp_h] == '') {
      mutate { id => "mutate_replace_zeek_notice_resp_h"
               replace => { "[zeek_cols][resp_h]" => "%{[zeek_cols][dst]}" } }
    }
    if (![zeek_cols][resp_p])       or ([zeek_cols][resp_p] == '(empty)') or
       ([zeek_cols][resp_p] == '-') or ([zeek_cols][resp_p] == '') {
      mutate { id => "mutate_replace_zeek_resp_p"
               replace => { "[zeek_cols][resp_p]" => "%{[zeek_cols][p]}" } }
    }

  } else if ([source] == "ntlm") {
    #############################################################################################################################
    # ntlm.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ntlm/main.zeek.html#type-NTLM::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ntlm.log field configuration version 0
      #
      # all fields: 0x000007FF / 2047
      #
      # bitmap ntlm.log field configuration version 1
      #
      # all fields: 0x00001FFF / 8191

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 2047) {
          dissect {
            id => "dissect_zeek_ntlm_0_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][host]}	%{[zeek_cols][domain]}	%{[zeek_cols][success]}	%{[zeek_cols][status]}"
            }
          }

        } else {
          # who knows? the ntlm.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ntlm_0_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else if ([@metadata][zeek_fields_bitmap_version] == 1) {

        if ([@metadata][zeek_fields_bitmap] == 8191) {
          dissect {
            id => "dissect_zeek_ntlm_1_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][host]}	%{[zeek_cols][domain]}	%{[zeek_cols][server_nb_computer]}	%{[zeek_cols][server_dns_computer]}	%{[zeek_cols][server_tree]}	%{[zeek_cols][success]}"
            }
          }

        } else {
          # who knows? the ntlm.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ntlm_1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ntlm.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ntlm_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ntlm.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ntlm_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ntlm"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ntlm"
        init => "$zeek_ntlm_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'host', 'domain', 'server_nb_computer', 'server_dns_computer', 'server_tree', 'success' ]"
        code => "event.set('[zeek_cols]', $zeek_ntlm_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ntlm"
      add_field =>  { "[zeek_cols][service]" => "ntlm" }
    }

  } else if ([source] == "ntp") {
    #############################################################################################################################
    # ntp.log
    # https://docs.zeek.org/en/latest/scripts/base/protocols/ntp/main.zeek.html#type-NTP::Info

    dissect {
      id => "dissect_zeek_ntp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][mode]}	%{[zeek_cols][stratum]}	%{[zeek_cols][poll]}	%{[zeek_cols][precision]}	%{[zeek_cols][root_delay]}	%{[zeek_cols][root_disp]}	%{[zeek_cols][ref_id]}	%{[zeek_cols][ref_time]}	%{[zeek_cols][org_time]}	%{[zeek_cols][rec_time]}	%{[zeek_cols][xmt_time]}	%{[zeek_cols][num_exts]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ntp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ntp"
        init => "$zeek_ntp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'mode', 'stratum', 'poll', 'precision', 'root_delay', 'root_disp', 'ref_id', 'ref_time', 'org_time', 'rec_time', 'xmt_time', 'num_exts' ]"
        code => "event.set('[zeek_cols]', $zeek_ntp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ntp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "ntp"
      }
    }

  } else if ([source] == "pe") {
    #############################################################################################################################
    # pe.log
    # https://docs.zeek.org/en/stable/scripts/base/files/pe/main.zeek.html#type-PE::Info

    dissect {
      id => "dissect_zeek_pe"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][machine]}	%{[zeek_cols][compile_ts]}	%{[zeek_cols][os]}	%{[zeek_cols][subsystem]}	%{[zeek_cols][is_exe]}	%{[zeek_cols][is_64bit]}	%{[zeek_cols][uses_aslr]}	%{[zeek_cols][uses_dep]}	%{[zeek_cols][uses_code_integrity]}	%{[zeek_cols][uses_seh]}	%{[zeek_cols][has_import_table]}	%{[zeek_cols][has_export_table]}	%{[zeek_cols][has_cert_table]}	%{[zeek_cols][has_debug_data]}	%{[zeek_cols][section_names]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_pe"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_pe"
        init => "$zeek_pe_field_names = [ 'ts', 'fuid', 'machine', 'compile_ts', 'os', 'subsystem', 'is_exe', 'is_64bit', 'uses_aslr', 'uses_dep', 'uses_code_integrity', 'uses_seh', 'has_import_table', 'has_export_table', 'has_cert_table', 'has_debug_data', 'section_names' ]"
        code => "event.set('[zeek_cols]', $zeek_pe_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "profinet") {
    #############################################################################################################################
    # profinet.log
    # https://github.com/amzn/zeek-plugin-profinet/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_profinet"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][operation_type]}	%{[zeek_cols][block_version]}	%{[zeek_cols][slot_number]}	%{[zeek_cols][subslot_number]}	%{[zeek_cols][index]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_profinet"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_profinet"
        init => "$zeek_profinet_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'operation_type', 'block_version', 'slot_number', 'subslot_number', 'index' ]"
        code => "event.set('[zeek_cols]', $zeek_profinet_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_profinet"
      add_field =>  { "[zeek_cols][service]" => "profinet" }
    }

  } else if ([source] == "profinet_dce_rpc") {
    #############################################################################################################################
    # profinet_dce_rpc.log
    # https://github.com/amzn/zeek-plugin-profinet/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_profinet_dce_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][packet_type]}	%{[zeek_cols][object_uuid]}	%{[zeek_cols][interface_uuid]}	%{[zeek_cols][activity_uuid]}	%{[zeek_cols][server_boot_time]}	%{[zeek_cols][operation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_profinet_dce_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_profinet_dce_rpc"
        init => "$zeek_profinet_dce_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'packet_type', 'object_uuid', 'interface_uuid', 'activity_uuid', 'server_boot_time', 'operation' ]"
        code => "event.set('[zeek_cols]', $zeek_profinet_dce_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_profinet_dce_rpc"
      add_field =>  { "[zeek_cols][service]" => "profinet_dce_rpc" }
    }

  } else if ([source] == "radius") {
    #############################################################################################################################
    # radius.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/radius/main.zeek.html#type-RADIUS::Info

    dissect {
      id => "dissect_zeek_radius"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][mac]}	%{[zeek_cols][framed_addr]}	%{[zeek_cols][tunnel_client]}	%{[zeek_cols][connect_info]}	%{[zeek_cols][reply_msg]}	%{[zeek_cols][result]}	%{[zeek_cols][ttl]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_radius"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_radius"
        init => "$zeek_radius_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'mac', 'framed_addr', 'tunnel_client', 'connect_info', 'reply_msg', 'result', 'ttl' ]"
        code => "event.set('[zeek_cols]', $zeek_radius_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_radius"
      add_field =>  { "[zeek_cols][service]" => "radius" }
    }

  } else if ([source] == "rdp") {
    #############################################################################################################################
    # rdp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/rdp/main.zeek.html#type-RDP::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap rdp.log field configuration version 0
      # all fields:             0x03FFFFF / 4194303
      # minus client_channels:  0x03FFDFF / 4193791

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 4194303) {
          dissect {
            id => "dissect_zeek_rdp_0_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cookie]}	%{[zeek_cols][result]}	%{[zeek_cols][security_protocol]}	%{[zeek_cols][client_channels]}	%{[zeek_cols][keyboard_layout]}	%{[zeek_cols][client_build]}	%{[zeek_cols][client_name]}	%{[zeek_cols][client_dig_product_id]}	%{[zeek_cols][desktop_width]}	%{[zeek_cols][desktop_height]}	%{[zeek_cols][requested_color_depth]}	%{[zeek_cols][cert_type]}	%{[zeek_cols][cert_count]}	%{[zeek_cols][cert_permanent]}	%{[zeek_cols][encryption_level]}	%{[zeek_cols][encryption_method]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 4193791) {
          dissect {
            id => "dissect_zeek_rdp_0_with_all_fields_minus_client_channels"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cookie]}	%{[zeek_cols][result]}	%{[zeek_cols][security_protocol]}	%{[zeek_cols][keyboard_layout]}	%{[zeek_cols][client_build]}	%{[zeek_cols][client_name]}	%{[zeek_cols][client_dig_product_id]}	%{[zeek_cols][desktop_width]}	%{[zeek_cols][desktop_height]}	%{[zeek_cols][requested_color_depth]}	%{[zeek_cols][cert_type]}	%{[zeek_cols][cert_count]}	%{[zeek_cols][cert_permanent]}	%{[zeek_cols][encryption_level]}	%{[zeek_cols][encryption_method]}"
            }
          }

        } else {
          # who knows? the rdp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_rdp_1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the rdp.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_rdp_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the rdp.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_rdp_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_rdp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_rdp"
        init => "$zeek_rdp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cookie', 'result', 'security_protocol', 'client_channels', 'keyboard_layout', 'client_build', 'client_name', 'client_dig_product_id', 'desktop_width', 'desktop_height', 'requested_color_depth', 'cert_type', 'cert_count', 'cert_permanent', 'encryption_level', 'encryption_method' ]"
        code => "event.set('[zeek_cols]', $zeek_rdp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_rdp"
      add_field =>  { "[zeek_cols][service]" => "rdp" }
    }

    # remove RDP prefix from client_build (version)
    mutate { id => "mutate_gsub_field_zeek_rdp_client_build"
             gsub => [ "[zeek_cols][client_build]", "^RDP ", "" ] }

  } else if ([source] == "rfb") {
    #############################################################################################################################
    # rfb.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/rfb/main.zeek.html#type-RFB::Info

    dissect {
      id => "dissect_zeek_rfb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][client_major_version]}	%{[zeek_cols][client_minor_version]}	%{[zeek_cols][server_major_version]}	%{[zeek_cols][server_minor_version]}	%{[zeek_cols][authentication_method]}	%{[zeek_cols][auth]}	%{[zeek_cols][share_flag]}	%{[zeek_cols][desktop_name]}	%{[zeek_cols][width]}	%{[zeek_cols][height]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_rfb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_rfb"
        init => "$zeek_rfb_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'client_major_version', 'client_minor_version', 'server_major_version', 'server_minor_version', 'authentication_method', 'auth', 'share_flag', 'desktop_name', 'width', 'height' ]"
        code => "event.set('[zeek_cols]', $zeek_rfb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_rfb"
      add_field =>  { "[zeek_cols][service]" => "rfb" }
    }

  } else if ([source] == "s7comm") {
    #############################################################################################################################
    # s7comm.log
    # https://github.com/amzn/zeek-plugin-s7comm/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_s7comm"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][rosctr]}	%{[zeek_cols][parameter]}	%{[zeek_cols][item_count]}	%{[zeek_cols][data_info]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_s7comm"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_s7comm"
        init => "$zeek_s7comm_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'rosctr', 'parameter', 'item_count', 'data_info' ]"
        code => "event.set('[zeek_cols]', $zeek_s7comm_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_s7comm"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "s7comm"
      }
    }

  } else if ([source] == "signatures") {
    #############################################################################################################################
    # signatures.log

    dissect {
      id => "dissect_zeek_signatures"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][note]}	%{[zeek_cols][signature_id]}	%{[zeek_cols][event_message]}	%{[zeek_cols][sub_message]}	%{[zeek_cols][signature_count]}	%{[zeek_cols][host_count]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_signatures"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_signatures"
        init => "$zeek_signatures_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'note', 'signature_id', 'event_message', 'sub_message', 'signature_count', 'host_count' ]"
        code => "event.set('[zeek_cols]', $zeek_signatures_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "sip") {
    #############################################################################################################################
    # sip.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/sip/main.zeek.html#type-SIP::Info

    dissect {
      id => "dissect_zeek_sip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][uri]}	%{[zeek_cols][date]}	%{[zeek_cols][request_from]}	%{[zeek_cols][request_to]}	%{[zeek_cols][response_from]}	%{[zeek_cols][response_to]}	%{[zeek_cols][reply_to]}	%{[zeek_cols][call_id]}	%{[zeek_cols][seq]}	%{[zeek_cols][subject]}	%{[zeek_cols][request_path]}	%{[zeek_cols][response_path]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][warning]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][content_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_sip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_sip"
        init => "$zeek_sip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'method', 'uri', 'date', 'request_from', 'request_to', 'response_from', 'response_to', 'reply_to', 'call_id', 'seq', 'subject', 'request_path', 'response_path', 'user_agent', 'status_code', 'status_msg', 'warning', 'request_body_len', 'response_body_len', 'content_type' ]"
        code => "event.set('[zeek_cols]', $zeek_sip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_sip"
      add_field =>  { "[zeek_cols][service]" => "sip" }
    }

  } else if ([source] == "smb_cmd") {
    #############################################################################################################################
    # smb_cmd.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smb/main.zeek.html#type-SMB::CmdInfo
    #
    # note that smb_cmd.referenced_file is exactly the same structure as the log line for smb_files. later on it will be
    # merged up as its own top-level entity so I don't have to duplicate the parsing effort below

    dissect {
      id => "dissect_zeek_smb_cmd"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][command]}	%{[zeek_cols][sub_command]}	%{[zeek_cols][argument]}	%{[zeek_cols][status]}	%{[zeek_cols][rtt]}	%{[zeek_cols][version]}	%{[zeek_cols][user]}	%{[zeek_cols][tree]}	%{[zeek_cols][tree_service]}	%{[zeek_cols][referenced_file][ts]}	%{[zeek_cols][referenced_file][uid]}	%{[zeek_cols][referenced_file][orig_h]}	%{[zeek_cols][referenced_file][orig_p]}	%{[zeek_cols][referenced_file][resp_h]}	%{[zeek_cols][referenced_file][resp_p]}	%{[zeek_cols][referenced_file][fuid]}	%{[zeek_cols][referenced_file][action]}	%{[zeek_cols][referenced_file][path]}	%{[zeek_cols][referenced_file][name]}	%{[zeek_cols][referenced_file][size]}	%{[zeek_cols][referenced_file][prev_name]}	%{[zeek_cols][referenced_file][times_modified]}	%{[zeek_cols][referenced_file][times_accessed]}	%{[zeek_cols][referenced_file][times_created]}	%{[zeek_cols][referenced_file][times_changed]}	%{[zeek_cols][referenced_file][data_offset_req]}	%{[zeek_cols][referenced_file][data_len_req]}	%{[zeek_cols][referenced_file][data_len_rsp]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_cmd"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_cmd"
        init => "$zeek_smb_cmd_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'command', 'sub_command', 'argument', 'status', 'rtt', 'version', 'user', 'tree', 'tree_service', 'referenced_file.ts', 'referenced_file.uid', 'referenced_file.orig_h', 'referenced_file.orig_p', 'referenced_file.resp_h', 'referenced_file.resp_p', 'referenced_file.fuid', 'referenced_file.action', 'referenced_file.path', 'referenced_file.name', 'referenced_file.size', 'referenced_file.prev_name', 'referenced_file.times_modified', 'referenced_file.times_accessed', 'referenced_file.times_created', 'referenced_file.times_changed', 'referenced_file.data_offset_req', 'referenced_file.data_len_req', 'referenced_file.data_len_rsp' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_cmd_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_cmd"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

    # remove SMB prefix from version
    mutate { id => "mutate_gsub_field_zeek_smb_cmd_version"
             gsub => [ "[zeek_cols][version]", "^SMB", "" ] }

    mutate { id => "mutate_gsub_zeek_smb_cmd_command"
             gsub => [ "[zeek_cols][command]", "^SMB::", "" ] }

  } else if ([source] == "smb_files") {
    #############################################################################################################################
    # smb_files.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smb/main.zeek.html#type-SMB::FileInfo

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap smb_files.log field configuration version 0
      #
      # smb_files.log without data_offset_req, data_len_req, data_len_rsp : 0x0000FFFF / 65535
      # smb_files.log with data_offset_req, data_len_req, data_len_rsp :    0x0007FFFF / 524287

      # smb_files.log with data_offset_req, data_len_req, data_len_rsp

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 524287) {

          dissect {
            id => "dissect_zeek_smb_files_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][action]}	%{[zeek_cols][path]}	%{[zeek_cols][name]}	%{[zeek_cols][size]}	%{[zeek_cols][prev_name]}	%{[zeek_cols][times_modified]}	%{[zeek_cols][times_accessed]}	%{[zeek_cols][times_created]}	%{[zeek_cols][times_changed]}	%{[zeek_cols][data_offset_req]}	%{[zeek_cols][data_len_req]}	%{[zeek_cols][data_len_rsp]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 65535) {

          dissect {
            id => "dissect_zeek_smb_files_without_data_lens"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][action]}	%{[zeek_cols][path]}	%{[zeek_cols][name]}	%{[zeek_cols][size]}	%{[zeek_cols][prev_name]}	%{[zeek_cols][times_modified]}	%{[zeek_cols][times_accessed]}	%{[zeek_cols][times_created]}	%{[zeek_cols][times_changed]}"
            }
          }

        } else {
          # who knows? the smb_files.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_smb_files_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the smb_files.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_smb_files_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the smb_files.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_smb_files_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_files"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_files"
        init => "$zeek_smb_files_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fuid', 'action', 'path', 'name', 'size', 'prev_name', 'times_modified', 'times_accessed', 'times_created', 'times_changed', 'data_offset_req', 'data_len_req', 'data_len_rsp' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_files_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_files"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

    mutate { id => "mutate_gsub_zeek_smb_files_action"
             gsub => [ "[zeek_cols][action]", "^SMB::", "" ] }

  } else if ([source] == "smb_mapping") {
    #############################################################################################################################
    # smb_mapping.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smb/main.zeek.html#type-SMB::TreeInfo

    dissect {
      id => "dissect_zeek_smb_mapping"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][path]}	%{[zeek_cols][resource_type]}	%{[zeek_cols][native_file_system]}	%{[zeek_cols][share_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_mapping"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_mapping"
        init => "$zeek_smb_mapping_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'path', 'resource_type', 'native_file_system', 'share_type' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_mapping_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_mapping"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

  } else if ([source] == "smtp") {
    #############################################################################################################################
    # smtp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/smtp/main.zeek.html#type-SMTP::Info

    dissect {
      id => "dissect_zeek_smtp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][helo]}	%{[zeek_cols][mailfrom]}	%{[zeek_cols][rcptto]}	%{[zeek_cols][date]}	%{[zeek_cols][from]}	%{[zeek_cols][to]}	%{[zeek_cols][cc]}	%{[zeek_cols][reply_to]}	%{[zeek_cols][msg_id]}	%{[zeek_cols][in_reply_to]}	%{[zeek_cols][subject]}	%{[zeek_cols][x_originating_ip]}	%{[zeek_cols][first_received]}	%{[zeek_cols][second_received]}	%{[zeek_cols][last_reply]}	%{[zeek_cols][path]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][tls]}	%{[zeek_cols][fuid]}	%{[zeek_cols][is_webmail]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smtp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smtp"
        init => "$zeek_smtp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'helo', 'mailfrom', 'rcptto', 'date', 'from', 'to', 'cc', 'reply_to', 'msg_id', 'in_reply_to', 'subject', 'x_originating_ip', 'first_received', 'second_received', 'last_reply', 'path', 'user_agent', 'tls', 'fuid', 'is_webmail' ]"
        code => "event.set('[zeek_cols]', $zeek_smtp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smtp"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smtp"
      }
    }

  } else if ([source] == "snmp") {
    #############################################################################################################################
    # snmp.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/snmp/main.zeek.html#type-SNMP::Info

    dissect {
      id => "dissect_zeek_snmp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][duration]}	%{[zeek_cols][version]}	%{[zeek_cols][community]}	%{[zeek_cols][get_requests]}	%{[zeek_cols][get_bulk_requests]}	%{[zeek_cols][get_responses]}	%{[zeek_cols][set_requests]}	%{[zeek_cols][display_string]}	%{[zeek_cols][up_since]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_snmp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_snmp"
        init => "$zeek_snmp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'duration', 'version', 'community', 'get_requests', 'get_bulk_requests', 'get_responses', 'set_requests', 'display_string', 'up_since' ]"
        code => "event.set('[zeek_cols]', $zeek_snmp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_snmp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "snmp"
      }
    }

  } else if ([source] == "socks") {
    #############################################################################################################################
    # socks.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/socks/main.zeek.html#type-SOCKS::Info

    dissect {
      id => "dissect_zeek_socks"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][server_status]}	%{[zeek_cols][request_host]}	%{[zeek_cols][request_name]}	%{[zeek_cols][request_port]}	%{[zeek_cols][bound_host]}	%{[zeek_cols][bound_name]}	%{[zeek_cols][bound_port]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_socks"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_socks"
        init => "$zeek_socks_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'user', 'password', 'server_status', 'request_host', 'request_name', 'request_port', 'bound_host', 'bound_name', 'bound_port' ]"
        code => "event.set('[zeek_cols]', $zeek_socks_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_socks"
      add_field =>  { "[zeek_cols][service]" => "socks" }
    }

  } else if ([source] == "software") {
    #############################################################################################################################
    # software.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/software/main.zeek.html#type-Software::Info

    dissect {
      id => "dissect_zeek_software"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][software_type]}	%{[zeek_cols][name]}	%{[zeek_cols][version_major]}	%{[zeek_cols][version_minor]}	%{[zeek_cols][version_minor2]}	%{[zeek_cols][version_minor3]}	%{[zeek_cols][version_addl]}	%{[zeek_cols][unparsed_version]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_software"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_software"
        init => "$zeek_software_field_names = [ 'ts', 'orig_h', 'orig_p', 'software_type', 'name', 'version_major', 'version_minor', 'version_minor2', 'version_minor3', 'version_addl', 'unparsed_version' ]"
        code => "event.set('[zeek_cols]', $zeek_software_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "spicy-noise") {
    #############################################################################################################################
    # spicy-noise.log
    # https://github.com/theparanoids/spicy-noise/blob/master/zeek/spicy-noise.zeek

    # rename spicy-noise to noise
    mutate { id => "mutate_replace_zeek_source_spicy_noise"
             replace => { "[source]" => "noise" } }

    dissect {
      id => "dissect_zeek_noise"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][msg_type]}	%{[zeek_cols][sender]}	%{[zeek_cols][receiver]}	%{[zeek_cols][unenc_ephemeral]}	%{[zeek_cols][enc_static]}	%{[zeek_cols][enc_timestamp]}	%{[zeek_cols][enc_nothing]}	%{[zeek_cols][nonce]}	%{[zeek_cols][enc_cookie]}	%{[zeek_cols][mac1]}	%{[zeek_cols][mac2]}	%{[zeek_cols][enc_payload_len]}	%{[zeek_cols][enc_payload]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_noise"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_noise"
        init => "$zeek_noise_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'msg_type', 'sender', 'receiver', 'unenc_ephemeral', 'enc_static', 'enc_timestamp', 'enc_nothing', 'nonce', 'enc_cookie', 'mac1', 'mac2', 'enc_payload_len', 'enc_payload' ]"
        code => "event.set('[zeek_cols]', $zeek_noise_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    # for now, drop enc_payload for size
    if ([zeek_cols][enc_payload]) {
      mutate { id => "mutate_remove_field_zeek_noise_enc_payload"
               remove_field => [ "[zeek_cols][enc_payload]" ] }
    }

    mutate {
      # TODO: is this technically accurate? should it be "noise" instead/as well?
      id => "mutate_add_field_zeek_service_wireguard"
      add_field =>  {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "wireguard"
      }
    }

  } else if ([source] == "ssh") {
    #############################################################################################################################
    # ssh.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ssh/main.zeek.html#type-SSH::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ssh.log field configuration version 0
      #
      # standard ssh.log without HASSH fingerprinting add-on script : 0x007FFFFF / 8388607
      # ssh.log with HASSH fingerprinting add-on script :             0x3FFFFFFF / 1073741823

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 1073741823) {

          dissect {
            id => "dissect_zeek_ssh_with_all_fields_with_hassh"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][auth_success]}	%{[zeek_cols][auth_attempts]}	%{[zeek_cols][direction]}	%{[zeek_cols][client]}	%{[zeek_cols][server]}	%{[zeek_cols][cipher_alg]}	%{[zeek_cols][mac_alg]}	%{[zeek_cols][compression_alg]}	%{[zeek_cols][kex_alg]}	%{[zeek_cols][host_key_alg]}	%{[zeek_cols][host_key]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}	%{[zeek_cols][hasshVersion]}	%{[zeek_cols][hassh]}	%{[zeek_cols][hasshServer]}	%{[zeek_cols][cshka]}	%{[zeek_cols][hasshAlgorithms]}	%{[zeek_cols][sshka]}	%{[zeek_cols][hasshServerAlgorithms]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {

          dissect {
            id => "dissect_zeek_ssh_with_all_fields_no_hassh"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][auth_success]}	%{[zeek_cols][auth_attempts]}	%{[zeek_cols][direction]}	%{[zeek_cols][client]}	%{[zeek_cols][server]}	%{[zeek_cols][cipher_alg]}	%{[zeek_cols][mac_alg]}	%{[zeek_cols][compression_alg]}	%{[zeek_cols][kex_alg]}	%{[zeek_cols][host_key_alg]}	%{[zeek_cols][host_key]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}"
            }
          }

        } else {
          # who knows? the ssh.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ssh_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ssh.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ssh_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ssh.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ssh_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ssh"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ssh"
        init => "$zeek_ssh_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'auth_success', 'auth_attempts', 'direction', 'client', 'server', 'cipher_alg', 'mac_alg', 'compression_alg', 'kex_alg', 'host_key_alg', 'host_key', 'remote_location_country_code', 'remote_location_region', 'remote_location_city', 'remote_location_latitude', 'remote_location_longitude', 'hasshVersion', 'hassh', 'hasshServer', 'cshka', 'hasshAlgorithms', 'sshka', 'hasshServerAlgorithms' ]"
        code => "event.set('[zeek_cols]', $zeek_ssh_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ssh"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "ssh"
      }
    }

  } else if ([source] == "ssl") {
    #############################################################################################################################
    # ssl.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/ssl/main.zeek.html#type-SSL::Info

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ssl.log field configuration version 0
      #
      # standard ssl.log fields without add-on JA3 fingerprinting script :  0x001FFFFF / 2097151
      # ssl.log fields with add-on JA3 fingerprinting script :              0x007FFFFF / 8388607

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 8388607) {

          dissect {
            id => "dissect_zeek_ssl_with_ja3"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ssl_version]}	%{[zeek_cols][cipher]}	%{[zeek_cols][curve]}	%{[zeek_cols][server_name]}	%{[zeek_cols][resumed]}	%{[zeek_cols][last_alert]}	%{[zeek_cols][next_protocol]}	%{[zeek_cols][established]}	%{[zeek_cols][cert_chain_fuids]}	%{[zeek_cols][client_cert_chain_fuids]}	%{[zeek_cols][subject]}	%{[zeek_cols][issuer]}	%{[zeek_cols][client_subject]}	%{[zeek_cols][client_issuer]}	%{[zeek_cols][validation_status]}	%{[zeek_cols][ja3]}	%{[zeek_cols][ja3s]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {

          dissect {
            id => "dissect_zeek_ssl_without_ja3"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ssl_version]}	%{[zeek_cols][cipher]}	%{[zeek_cols][curve]}	%{[zeek_cols][server_name]}	%{[zeek_cols][resumed]}	%{[zeek_cols][last_alert]}	%{[zeek_cols][next_protocol]}	%{[zeek_cols][established]}	%{[zeek_cols][cert_chain_fuids]}	%{[zeek_cols][client_cert_chain_fuids]}	%{[zeek_cols][subject]}	%{[zeek_cols][issuer]}	%{[zeek_cols][client_subject]}	%{[zeek_cols][client_issuer]}	%{[zeek_cols][validation_status]}"
            }
          }

        } else {
          # who knows? the ssl.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ssl_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ssl.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ssl_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ssl.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ssl_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ssl"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ssl"
        init => "$zeek_ssl_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'ssl_version', 'cipher', 'curve', 'server_name', 'resumed', 'last_alert', 'next_protocol', 'established', 'cert_chain_fuids', 'client_cert_chain_fuids', 'subject', 'issuer', 'client_subject', 'client_issuer', 'validation_status', 'ja3', 'ja3s' ]"
        code => "event.set('[zeek_cols]', $zeek_ssl_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ssl"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tls"
      }
    }

  } else if ([source] == "syslog") {
    #############################################################################################################################
    # syslog.log
    # https://docs.zeek.org/en/stable/scripts/base/protocols/syslog/main.zeek.html#type-Syslog::Info

    dissect {
      id => "dissect_zeek_syslog"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][facility]}	%{[zeek_cols][severity]}	%{[zeek_cols][message]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_syslog"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_syslog"
        init => "$zeek_syslog_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'facility', 'severity', 'message' ]"
        code => "event.set('[zeek_cols]', $zeek_syslog_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_syslog"
      add_field =>  { "[zeek_cols][service]" => "syslog" }
    }

  } else if ([source] == "tds") {
    #############################################################################################################################
    # tds.log
    # https://github.com/amzn/zeek-plugin-tds/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_tds"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][command]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds"
        init => "$zeek_tds_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'command' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([source] == "tds_rpc") {
    #############################################################################################################################
    # tds_rpc.log
    # https://github.com/amzn/zeek-plugin-tds/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_tds_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][procedure_name]}	%{[zeek_cols][parameter]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds_rpc"
        init => "$zeek_tds_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'procedure_name', 'parameter' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds_rpc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([source] == "tds_sql_batch") {
    #############################################################################################################################
    # tds_sql_batch.log
    # https://github.com/amzn/zeek-plugin-tds/blob/master/scripts/main.zeek

    dissect {
      id => "dissect_zeek_tds_sql_batch"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][header_type]}	%{[zeek_cols][query]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds_sql_batch"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds_sql_batch"
        init => "$zeek_tds_sql_batch_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'header_type', 'query' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_sql_batch_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds_sql_batch"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([source] == "tunnel") {
    #############################################################################################################################
    # tunnel.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/tunnels/main.zeek.html#type-Tunnel::Info

    dissect {
      id => "dissect_zeek_tunnel"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][tunnel_type]}	%{[zeek_cols][action]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tunnel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tunnel"
        init => "$zeek_tunnel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'tunnel_type', 'action' ]"
        code => "event.set('[zeek_cols]', $zeek_tunnel_field_names.zip(event.get('[message]')).to_h)"
      }
    }


    mutate { id => "mutate_gsub_zeek_tunnel_action"
             gsub => [ "[zeek_cols][action]", "Tunnel::", "" ] }

    mutate { id => "mutate_gsub_zeek_tunnel_type"
             gsub => [ "[zeek_cols][tunnel_type]", "Tunnel::", "" ] }

    mutate {
      id => "mutate_add_fields_zeek_tunnel"
      add_field =>  { "[zeek_cols][service]" => "%{[zeek_cols][tunnel_type]}" }
    }

    mutate { id => "mutate_lowercase_zeek_tunnel_service"
             lowercase => [ "[zeek_cols][service]" ] }

  } else if ([source] == "weird") {
    #############################################################################################################################
    # weird.log
    # https://docs.zeek.org/en/stable/scripts/base/frameworks/notice/weird.zeek.html#type-Weird::Info

    dissect {
      id => "dissect_zeek_weird"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][name]}	%{[zeek_cols][addl]}	%{[zeek_cols][notice]}	%{[zeek_cols][peer]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_weird"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_weird"
        init => "$zeek_weird_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'name', 'addl', 'notice', 'peer' ]"
        code => "event.set('[zeek_cols]', $zeek_weird_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "x509") {
    #############################################################################################################################
    # x509.log
    # https://docs.zeek.org/en/stable/scripts/base/files/x509/main.zeek.html#type-X509::Info

    dissect {
      id => "dissect_zeek_x509"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][certificate_version]}	%{[zeek_cols][certificate_serial]}	%{[zeek_cols][certificate_subject]}	%{[zeek_cols][certificate_issuer]}	%{[zeek_cols][certificate_not_valid_before]}	%{[zeek_cols][certificate_not_valid_after]}	%{[zeek_cols][certificate_key_alg]}	%{[zeek_cols][certificate_sig_alg]}	%{[zeek_cols][certificate_key_type]}	%{[zeek_cols][certificate_key_length]}	%{[zeek_cols][certificate_exponent]}	%{[zeek_cols][certificate_curve]}	%{[zeek_cols][san_dns]}	%{[zeek_cols][san_uri]}	%{[zeek_cols][san_email]}	%{[zeek_cols][san_ip]}	%{[zeek_cols][basic_constraints_ca]}	%{[zeek_cols][basic_constraints_path_len]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_x509"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_x509"
        init => "$zeek_x509_field_names = [ 'ts', 'fuid', 'certificate_version', 'certificate_serial', 'certificate_subject', 'certificate_issuer', 'certificate_not_valid_before', 'certificate_not_valid_after', 'certificate_key_alg', 'certificate_sig_alg', 'certificate_key_type', 'certificate_key_length', 'certificate_exponent', 'certificate_curve', 'san_dns', 'san_uri', 'san_email', 'san_ip', 'basic_constraints_ca', 'basic_constraints_path_len' ]"
        code => "event.set('[zeek_cols]', $zeek_x509_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_add_fields_zeek_x509"
             add_field => { "[zeek_cols][service]" => "X.509"
                            "[certCnt]" => "1" } }

  } else {

    if ([source] =~ /\.\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2}$/) {
      # filebeat caught a file right in the middle of being renamed/moved (ie., renamed from conn.log to
      # conn.2020-01-16-14-00-00.log). this has actually already been processed, so ignore this event.
      drop { id => "drop_renamed_logfile" }

    } else {
      # some other unknown zeek log file. should start with ts at least!
      csv {
        id => "csv_zeek_unknown"
        columns => [
          "ts"]

        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        separator => "	"
        # there's no way to *disable* the csv quote char, so set it to something we'll never see
        quote_char => ""

        target => "[zeek_cols]"
      }

      mutate { id => "mutate_add_tag_zeek_unknown"
               add_tag => [ "_unknown_log_type" ] }
    }

  } # if / else if for source type (conn.log, dns.log, etc.)

  if ([zeek_cols]) {
    # remove unset (-) or "(empty)" top-level field values
    ruby {
      id => "ruby_zeek_remove_empty_values"
      code => "
        fieldsHash = event.get('[zeek_cols]').to_hash
        fieldsHash.delete_if{|_,v| ((v == nil) or (v == '') or (v == '-') or (v == '(empty)'))}
        event.set('[zeek_cols]', fieldsHash)
      "
    }
  } else {
    drop { id => "drop_dissect_error" }
  }

  # rename the zeek child array to match the log type
  mutate { id => "mutate_rename_zeek_log_type"
           rename => { "[zeek_cols]" => "[zeek_%{[source]}]" } }

  # move "up" some fields that are considered to be "multi-log" fields (eg., they
  # show up in many types of logs)
  mutate {
    id => "mutate_rename_zeek_common_fields"
    rename => { "[zeek_%{[source]}][ts]"              => "[zeek][ts]" }
    rename => { "[zeek_%{[source]}][uid]"             => "[zeek][uid]" }
    rename => { "[zeek_%{[source]}][fuid]"            => "[zeek][fuid]" }
    rename => { "[zeek_%{[source]}][orig_h]"          => "[zeek][orig_h]" }
    rename => { "[zeek_%{[source]}][orig_p]"          => "[zeek][orig_p]" }
    rename => { "[zeek_%{[source]}][orig_l2_addr]"    => "[zeek][orig_l2_addr]" }
    rename => { "[zeek_%{[source]}][resp_h]"          => "[zeek][resp_h]" }
    rename => { "[zeek_%{[source]}][resp_p]"          => "[zeek][resp_p]" }
    rename => { "[zeek_%{[source]}][resp_l2_addr]"    => "[zeek][resp_l2_addr]" }
    rename => { "[zeek_%{[source]}][proto]"           => "[zeek][proto]" }
    rename => { "[zeek_%{[source]}][service]"         => "[zeek][service]" }
    rename => { "[zeek_%{[source]}][user]"            => "[zeek][user]" }
    rename => { "[zeek_%{[source]}][password]"        => "[zeek][password]" }
    rename => { "[zeek_%{[source]}][community_id]"    => "[zeek][community_id]" }
  }

  if ([zeek][orig_h]) { mutate { id => "mutate_add_field_zeek_srcIp"
                                 add_field => { "[srcIp]"   => "%{[zeek][orig_h]}" } } }
  if ([zeek][orig_p]) { mutate { id => "mutate_add_field_zeek_srcPort"
                                 add_field => { "[srcPort]" => "%{[zeek][orig_p]}" } } }
  if ([zeek][resp_h]) { mutate { id => "mutate_add_field_zeek_dstIp"
                                 add_field => { "[dstIp]"   => "%{[zeek][resp_h]}" } } }
  if ([zeek][resp_p]) { mutate { id => "mutate_add_field_zeek_dstPort"
                                 add_field => { "[dstPort]" => "%{[zeek][resp_p]}" } } }
  if ([zeek][community_id]) { mutate { id => "mutate_add_field_zeek_communityId"
                                       add_field => { "[communityId]" => "%{[zeek][community_id]}" } } }

  if ([zeek][orig_l2_addr]) {
    # copy orig_l2_addr into srcMac array (with a count of 1)
    mutate { id => "mutate_merge_field_zeek_srcMac"
             merge => { "[srcMac]" => "[zeek][orig_l2_addr]" } }
    mutate { id => "mutate_add_field_zeek_srcMacCnt"
             add_field => { "[srcMacCnt]" => "1" } }
  }

  if ([zeek][resp_l2_addr]) {
    # copy resp_l2_addr into dstMac array (with a count of 1)
    mutate { id => "mutate_merge_field_zeek_dstMac"
             merge => { "[dstMac]" => "[zeek][resp_l2_addr]" } }
    mutate { id => "mutate_add_field_zeek_dstMacCnt"
             add_field => { "[dstMacCnt]" => "1" } }
  }

  if ([zeek][uid]) {
    # set zeek connection UID as "rootId" (see logstash.conf output section)
    if (![rootId]) { mutate { id => "mutate_add_field_zeek_rootId"
                              add_field => { "[rootId]" => "%{[zeek][uid]}" } } }

  } else {
    # create something random for zeek connection UID
    uuid {
      id => "uuid_zeek_random_conn"
      target    => "[@metadata][uuid]"
      overwrite => true
    }
    mutate { id => "mutate_add_field_zeek_uid"
             add_field => { "[zeek][uid]" => "%{[@metadata][uuid]}" } }
  }

  # if present, FUIDs are always a vector (comma-separated)
  if ([zeek][fuid]) { mutate { id => "mutate_split_zeek_fuids"
                               split => { "[zeek][fuid]" => "," } } }

  if ([source] == "conn") {
    mutate { id => "mutate_add_field_zeek_conn_zeekLogDocId"
             add_field => { "[zeekLogDocId]" => "%{[zeek][uid]}" } }

  } else {
    if ([log][offset]) {
      mutate { id => "mutate_add_field_zeek_not_conn_offset_zeekLogDocId"
               add_field => { "[zeekLogDocId]" => "%{[zeek][uid]}-%{source}-%{[log][offset]}" } }
    } else {
      uuid {
        id => "uuid_zeek_random_not_conn"
        target    => "[@metadata][uuid]"
        overwrite => true
      }
      mutate { id => "mutate_add_field_zeek_not_conn_zeekLogDocId"
               add_field => { "[zeekLogDocId]" => "%{[zeek][uid]}-%{source}:%{[@metadata][uuid]}" } }
    }
  } # if/else for defining logOffset field used in document ID for elasticsearch

  if ([zeek][ts]) {

    if ([zeek][ts] == "0.000000") {
      # missing packet timestamp, set to "now." not sure what a better option would be
      ruby {
        id => "ruby_zeek_empty_timestamp_set"
        init => "require 'time'"
        code => "event.set('[zeek][ts]', Time.now.to_f)"
      }
      mutate { id => "tag_zeek_empty_timestamp_set"
               add_tag => [ "_missing_timestamp" ] }
    }

    # convert @timestamp to UNIX to use native kibana features
    date {
      id => "date_zeek_ts"
      match => [ "[zeek][ts]", "UNIX" ]
      target => "[@timestamp]"
    }

    # set firstPacket to timestamp, lastPacket to timestamp + duration
    # @timestamp is date type,
    # timestamp, firstPacket, lastPacket are UNIX epoch milliseconds
    ruby {
      id => "ruby_zeek_timestamp_calc"
      code => "event.set('[timestamp]', (1000*event.get('[zeek][ts]').to_f).round(0))
               event.set('[firstPacket]', event.get('[timestamp]'))"
    }
    if ([zeek_conn]) and ([zeek_conn][duration]) {
      # convert duration (floating-point seconds) to milliseconds
      ruby {
        id => "ruby_zeek_duration_calc"
        code => "event.set('[length]', (1000*event.get('[zeek_conn][duration]').to_f).round(0))
                 event.set('[lastPacket]', event.get('[timestamp]').to_i + event.get('[length]').to_i)"
      }
    } else {
      mutate { id => "mutate_add_field_zeek_lastPacket"
               add_field => { "[lastPacket]" => "%{timestamp}" } }
      mutate { id => "mutate_add_field_zeek_length"
               add_field => { "[length]" => "0" } }
    }

    # set the ts back as something more readable
    mutate { id => "mutate_replace_zeek_ts"
             replace => { "[zeek][ts]" => "%{[@timestamp]}" } }
  } # if ([zeek][ts])

  # set user and transport- and application-level protocols if specified
  if ([zeek][user]) {
    mutate { id => "mutate_split_zeek_user"
             split => { "[zeek][user]" => "," } }
    mutate { id => "mutate_merge_zeek_user"
             merge => { "[user]" => "[zeek][user]" } }
  }
  if ([zeek][proto]) {
    translate {
      id => "translate_zeek_proto"
      field => "[zeek][proto]"
      destination => "[ipProtocol]"
      dictionary_path => "/etc/ip_protocol_numbers.yaml"
    }
    mutate { id => "mutate_split_zeek_proto"
             split => { "[zeek][proto]" => "," } }
    mutate { id => "mutate_merge_zeek_proto"
             merge => { "[protocol]" => "[zeek][proto]" } }
  }
  if ([zeek][service]) {
    mutate { id => "mutate_split_zeek_service"
             split => { "[zeek][service]" => "," } }
    mutate { id => "mutate_merge_zeek_service"
             merge => { "[protocol]" => "[zeek][service]" } }
  }

  if ([source] == "conn") {
    #############################################################################################################################
    # conn.log specific logic

    translate {
      id => "translate_zeek_conn_state"
      field => "[zeek_conn][conn_state]"
      destination => "[zeek_conn][conn_state_description]"
      dictionary_path => "/etc/conn_states.yaml"
    }

    mutate { id => "mutate_split_zeek_conn_tunnel_parents"
             split => { "[zeek_conn][tunnel_parents]" => "," } }

    if ([zeek_conn][vlan] or [zeek_conn][vlan]) {
      if ([zeek_conn][vlan]) {
        mutate { id => "mutate_merge_zeek_conn_vlan"
                 merge => { "[vlan]" => "[zeek_conn][vlan]" } }
      }
      if ([zeek_conn][inner_vlan]) {
        mutate { id => "mutate_merge_zeek_conn_inner_vlan"
                 merge => { "[vlan]" => "[zeek_conn][inner_vlan]" } }
      }
      ruby {
        id => "ruby_zeek_conn_vlanCnt"
        code => "event.set('[vlanCnt]', event.get('[vlan]').length)"
      }
    }

    # aggregate total bytes and packets
    ruby {
      id => "ruby_zeek_bytes_and_packets_calc"
      code => "event.set('[totDataBytes]', event.get('[srcDataBytes]').to_i + event.get('[dstDataBytes]').to_i)
               event.set('[totBytes]', event.get('[srcBytes]').to_i + event.get('[dstBytes]').to_i)
               event.set('[totPackets]', event.get('[srcPackets]').to_i + event.get('[dstPackets]').to_i)"
    }

    if ([zeek_conn][history]) {
      ruby {
        id => "ruby_zeek_conn_history"
        # see https://www.zeek.org/sphinx/scripts/base/protocols/conn/main.bro.html#type-Conn::Info
        code => "historyStr = event.get('[zeek_conn][history]').upcase
                 sCnt = historyStr.count('S')
                 hCnt = historyStr.count('H')
                 aCnt = historyStr.count('A')
                 fCnt = historyStr.count('F')
                 rCnt = historyStr.count('R')
                 event.set('[tcpflags][syn]',     10**(sCnt-1)) if sCnt > 0
                 event.set('[tcpflags][syn-ack]', 10**(hCnt-1)) if hCnt > 0
                 event.set('[tcpflags][ack]',     10**(aCnt-1)) if aCnt > 0
                 event.set('[tcpflags][fin]',     10**(fCnt-1)) if fCnt > 0
                 event.set('[tcpflags][rst]',     10**(rCnt-1)) if rCnt > 0"
      }
    }

  } else if ([source] == "bacnet_discovery") {
    #############################################################################################################################
    # bacnet_discovery.log specific logic

    # bacnet_discovery.range ccan be split into a min/max (All, 12345-12350, etc.)
    if ([zeek_bacnet_discovery][range]) {
      if ([zeek_bacnet_discovery][range] == "All") {
        mutate { id => "mutate_add_field_zeek_bacnet_discovery_range_low"
                 add_field => { "[zeek_bacnet_discovery][range_low]" => "0" } }
        mutate { id => "mutate_add_field_zeek_bacnet_discovery_range_high"
                 add_field => { "[zeek_bacnet_discovery][range_high]" => "4194300" } }
      } else if ([zeek_bacnet_discovery][range] =~ "^\d+-\d+$") {
        ruby {
          id => "ruby_bacnet_discovery_range_split"
          code => "
            if (bacnetRange = event.get('[zeek_bacnet_discovery][range]').split('-')) and (bacnetRange.length == 2) then
              event.set('[zeek_bacnet_discovery][range_low]', bacnetRange[0])
              event.set('[zeek_bacnet_discovery][range_high]', bacnetRange[1])
            end"
        }
      }
    }

  } else if ([source] == "dhcp") {
    #############################################################################################################################
    # dhcp.log specific logic

    if ([zeek][orig_l2_addr]) {
      mutate {
        id => "mutate_add_fields_zeek_dhcp_mac"
        add_field =>  { "[zeek_dhcp][mac]" => "%{[zeek][orig_l2_addr]}" }
      }
      mutate { id => "mutate_merge_zeek_dhcp_mac"
               merge => { "[dhcp][mac]" => "[zeek][orig_l2_addr]" } }
      mutate { id => "mutate_add_field_dhcp_macCnt"
               add_field => { "[dhcp][macCnt]" => "1" } }
    }

    if ([zeek_dhcp][msg_types]) {
      mutate { id => "mutate_split_zeek_dhcp_msg_types"
                 split => { "[zeek_dhcp][msg_types]" => "," } }
      ruby {
        id => "ruby_zeek_dhcp_msg_types"
        code => "event.set('[zeek_dhcp][msg_types]', event.get('[zeek_dhcp][msg_types]').uniq)"
      }
      mutate { id => "mutate_split_zeek_dhcp_type"
               merge => { "[dhcp][type]" => "[zeek_dhcp][msg_types]" } }
    }

    if ([zeek_dhcp][trans_id]) {
      mutate { id => "mutate_merge_zeek_dhcp_id"
               merge => { "[dhcp][id]" => "[zeek_dhcp][trans_id]" } }
      mutate { id => "mutate_add_field_dhcp_idCnt"
               add_field => { "[dhcp][idCnt]" => "1" } }
    }

    if ([zeek_dhcp][host_name]) {
      mutate { id => "mutate_merge_zeek_dhcp_host_name"
               merge => { "[dhcp][host]" => "[zeek_dhcp][host_name]" } }
    }

    if ([zeek_dhcp][assigned_ip]) {
      mutate { id => "mutate_merge_zeek_dhcp_host"
               merge => { "[dhcp][host]" => "[zeek_dhcp][assigned_ip]" } }
    }

    if ([dhcp][host]) {
      ruby {
        id => "ruby_zeek_dhcp_hostCnt"
        code => "event.set('[dhcp][hostCnt]', event.get('[dhcp][host]').length)"
      }
    }

  } else if ([source] == "dnp3") {
    #############################################################################################################################
    # dnp3.log specific logic

    # translate IIN bitmap (least significant bit = zeek_dnp3_iin_flags[0], etc.)
    # reference: https://raw.githubusercontent.com/wireshark/wireshark/master/epan/dissectors/packet-dnp.c (search IIN)
    ruby {
      id => "ruby_parse_dnp3_iin"
      init => "$zeek_dnp3_iin_flags = [ 'Function Code not Implemented', 'Requested Objects Unknown', 'Parameters Invalid or Out of Range', 'Event Buffer Overflow', 'Operation Already Executing', 'Configuration Corrupt', 'Reserved', 'Reserved', 'Broadcast Msg Rx', 'Class 1 Data Available', 'Class 2 Data Available', 'Class 3 Data Available', 'Time Sync Required', 'Digital Outputs in Local', 'Device Trouble', 'Device Restart' ]"
      code => "
        iinNum = event.get('[zeek_dnp3][iin]').to_i
        if (iinNum > 0) then
          iinFlags = Array.new
          $zeek_dnp3_iin_flags.each_with_index do |val, idx|
            iinFlags.push(val) if (iinNum[idx] == 1)
          end
          event.set('[zeek_dnp3][iin_flags]', iinFlags)
        end"
    }

  } else if ([source] == "dns") {
    #############################################################################################################################
    # dns.log specific logic

    # this must be done because [dns][ip] only handles IPv4 or IPv6 addresses
    # but [answers] can contain hostnames as well
    if ([zeek_dns][answers]) {
      ruby {
        id => "ruby_zeek_dns_answers_ip_extract"
        # todo: adjust this regex so it at least sort of catches IPv6 as well
        code => "event.set('[@metadata][answers_ip]', event.get('[zeek_dns][answers]').scan(/\d+\.\d+\.\d+\.\d+/).join(','))"
      }
      mutate { id => "mutate_split_zeek_dns_answers"
               split => { "[zeek_dns][answers]" => "," } }
      mutate { id => "mutate_split_zeek_dns_answers_ip"
               split => { "[@metadata][answers_ip]" => "," } }
    }
    mutate { id => "mutate_split_zeek_dns_TTLs"
               split => { "[zeek_dns][TTLs]" => "," } }

    if ([zeek_dns][query]) {
      mutate { id => "mutate_merge_zeek_query"
               merge => { "[dns][host]" => "[zeek_dns][query]" } }
      # seriously I do not get how merge works
      mutate { id => "mutate_add_field_zeek_opcode"
               add_field => { "[@metadata][opcode]" => "QUERY" } }
      mutate { id => "mutate_merge_zeek_opcode"
               merge => { "[dns][opcode]" => "[@metadata][opcode]" } }
      mutate { id => "mutate_add_field_dns_hostCnt"
               add_field => { "[dns][hostCnt]" => "1" } }
      mutate { id => "mutate_add_field_dns_opcodeCnt"
               add_field => { "[dns][opcodeCnt]" => "1" } }
    }

    if ([@metadata][answers_ip]) {
      mutate { id => "mutate_merge_zeek_dns_ip"
               merge => { "[dns][ip]" => "[@metadata][answers_ip]" } }
      ruby {
        id => "ruby_zeek_dns_ipCnt"
        code => "event.set('[dns][ipCnt]', event.get('[dns][ip]').length)"
      }
    }

    if ([zeek_dns][qclass_name]) {
      mutate { id => "mutate_merge_zeek_dns_qc"
               merge => { "[dns][qc]" => "[zeek_dns][qclass_name]" } }
      mutate { id => "mutate_add_field_dns_qcCnt"
               add_field => { "[dns][qcCnt]" => "1" } }
    }

    if ([zeek_dns][qtype_name]) {
      mutate { id => "mutate_merge_zeek_dns_qt"
               merge => { "[dns][qt]" => "[zeek_dns][qtype_name]" } }
      mutate { id => "mutate_add_field_dns_qtCnt"
               add_field => { "[dns][qtCnt]" => "1" } }
    }

  } else if ([source] == "files") {
    #############################################################################################################################
    # files.log specific logic

    if ([zeek_files][total_bytes]) {
      ruby {
        id => "ruby_zeek_files_totBytes"
        code => "event.set('[totBytes]', event.get('[zeek_files][total_bytes]').to_i)"
      }
    }
    if ([zeek_files][seen_bytes]) {
      ruby {
        id => "ruby_zeek_files_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek_files][seen_bytes]').to_i)"
      }
    }

    if ([zeek_files][parent_fuid]) { mutate { id => "mutate_split_zeek_files_parent_fuid"
                                              split => { "[zeek_files][parent_fuid]" => "," } } }

    if ([zeek_files][analyzers]) { mutate { id => "mutate_split_zeek_files_analyzers"
                                            split => { "[zeek_files][analyzers]" => "," } } }

    if ([zeek_files][source]) and ([zeek_files][source] =~ /^XOR decrypted from /) {
      # PE_XOR plugin writes source as "XOR decrypted from FM7Tr545kxt3ofR7x2-"..., let's
      # standardize that to just "XOR decrypted" and put the source fuid in parent_fuid
      grok {
        id => "grok_zeek_files_source_xor"
        match => { "[zeek_files][source]" => [ "decrypted%{SPACE}from%{SPACE}%{WORD:[@metadata][source_xor_fuid]}" ] }
      }
      if ([@metadata][source_xor_fuid]) { mutate { id => "mutate_merge_zeek_files_source_xor_parent_fuid"
                                                   merge => { "[zeek_files][parent_fuid]" => "[@metadata][source_xor_fuid]" } } }
      mutate { id => "mutate_replace_zeek_files_source_xor"
               replace => { "[zeek_files][source]" => "XOR decrypted" } }
    }

  } else if ([source] == "ftp") {
    #############################################################################################################################
    # ftp.log specific logic

    if ([zeek_ftp][file_size]) {
      ruby {
        id => "ruby_zeek_ftp_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek_ftp][file_size]').to_i)"
      }
    }

  } else if ([source] == "gquic") {
    #############################################################################################################################
    # gquic.log specific logic

    if ([zeek_gquic][user_agent]) {
      mutate { id => "mutate_merge_zeek_quic_useragent"
               merge => { "[quic][useragent]" => "[zeek_gquic][user_agent]" } }
      mutate { id => "mutate_add_field_zeek_quic_useragentCnt"
               add_field =>  { "[quic][useragentCnt]" => "1" } }
    }

    if ([zeek_gquic][server_name]) {
      mutate { id => "mutate_merge_zeek_quic_host"
               merge => { "[quic][host]" => "[zeek_gquic][server_name]" } }
      mutate { id => "mutate_add_field_zeek_quic_hostCnt"
               add_field =>  { "[quic][hostCnt]" => "1" } }
    }

    if ([zeek_gquic][version]) {
      ruby {
        id => "ruby_zeek_set_quic_version"
        code => "event.set('[quic][version]', 'Q' + event.get('[zeek_gquic][version]').rjust(3, '0'))"
      }
      mutate { id => "mutate_add_field_zeek_quic_versionCnt"
               add_field =>  { "[quic][versionCnt]" => "1" } }
    }


  } else if ([source] == "http") {
    #############################################################################################################################
    # http.log specific logic

    mutate { id => "mutate_split_zeek_http_orig_fuids"
             split => { "[zeek_http][orig_fuids]" => "," } }
    mutate { id => "mutate_split_zeek_http_orig_filenames"
             split => { "[zeek_http][orig_filenames]" => "," } }
    mutate { id => "mutate_split_zeek_http_orig_mime_types"
             split => { "[zeek_http][orig_mime_types]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_fuids"
             split => { "[zeek_http][resp_fuids]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_filenames"
             split => { "[zeek_http][resp_filenames]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_mime_types"
             split => { "[zeek_http][resp_mime_types]" => "," } }
    mutate { id => "mutate_split_zeek_http_tags"
             split => { "[zeek_http][tags]" => "," } }
    mutate { id => "mutate_split_zeek_http_proxied"
             split => { "[zeek_http][proxied]" => "," } }

    if ([zeek_http][host]) {
      mutate { id => "mutate_merge_zeek_http_host"
               merge => { "[http][host]" => "[zeek_http][host]" } }
      mutate { id => "mutate_add_field_http_hostCnt"
               add_field => { "[http][hostCnt]" => "1" } }
    }

    if ([zeek_http][uri]) {
      if ([zeek_http][host]) {
        mutate { id => "mutate_add_field_metadata_http_host_and_uri"
                 add_field => { "[@metadata][http_uri]" => "%{[zeek_http][host]}%{[zeek_http][uri]}" } }
        mutate { id => "mutate_merge_zeek_http_host_and_uri"
                 merge => { "[http][uri]" => "[@metadata][http_uri]" } }
      } else {
        mutate { id => "mutate_merge_zeek_http_uri"
                 merge => { "[http][uri]" => "[zeek_http][uri]" } }
      }
    } else if ([zeek_http][referrer]) {
      mutate { id => "mutate_merge_zeek_http_referrer"
      merge => { "[http][uri]" => "[zeek_http][referrer]" } }
    }

    if ([http][uri]) { mutate { id => "mutate_add_field_http_uriCnt"
                                add_field => { "[http][uriCnt]" => "1" } } }

    if ([zeek_http][user_agent]) {
      mutate { id => "mutate_merge_zeek_http_user_agent"
               merge => { "[http][useragent]" => "[zeek_http][user_agent]" } }
      mutate { id => "mutate_add_field_http_useragentCnt"
               add_field => { "[http][useragentCnt]" => "1" } }
    }

    if ([zeek_http][orig_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_orig_mime_types"
               merge => { "[http][bodyMagic]" => "[zeek_http][orig_mime_types]" } }
    }

    if ([zeek_http][resp_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_resp_mime_types"
               merge => { "[http][bodyMagic]" => "[zeek_http][resp_mime_types]" } }
    }

    if ([http][bodyMagic]) {
      ruby {
        id => "ruby_zeek_http_bodyMagicCnt"
        code => "event.set('[http][bodyMagicCnt]', event.get('[http][bodyMagic]').length)"
      }
    }

    if ([zeek_http][version]) {
      mutate { id => "mutate_merge_zeek_http_clientVersion"
               merge => { "[http][clientVersion]" => "[zeek_http][version]" } }
      mutate { id => "mutate_add_field_http_clientVersion"
               add_field => { "[http][clientVersionCnt]" => "1" } }
    }

    if ([zeek_http][status_code]) {
      mutate { id => "mutate_merge_zeek_http_statuscode"
               merge => { "[http][statuscode]" => "[zeek_http][status_code]" } }
      mutate { id => "mutate_add_field_http_statuscodeCnt"
               add_field => { "[http][statuscodeCnt]" => "1" } }
    }

    if ([zeek_http][method]) {
      mutate { id => "mutate_merge_zeek_http_method"
               merge => { "[http][method]" => "[zeek_http][method]" } }
      mutate { id => "mutate_add_field_http_methodCnt"
               add_field => { "[http][methodCnt]" => "1" } }
    }

    if ([zeek_http][post_username]) {
      mutate { id => "mutate_merge_zeek_http_post_username_1"
               merge => { "[zeek][user]" => "[zeek_http][post_username]" } }
      mutate { id => "mutate_merge_zeek_http_post_username_2"
               merge => { "[user]" => "[zeek_http][post_username]" } }
    }
    if (![zeek][password]) and ([zeek_http][post_password_plain]) {
      mutate { id => "mutate_add_field_zeek_http_post_password_plain"
               add_field =>  { "[zeek][password]" => "%{[zeek_http][post_password_plain]}" } }
    }

    ruby {
      id => "ruby_zeek_http_totDataBytes"
      code => "event.set('[totDataBytes]', event.get('[zeek_http][response_body_len]').to_i + event.get('[zeek_http][request_body_len]').to_i)"
    }


  } else if ([source] == "irc") {
    #############################################################################################################################
    # irc.log specific logic

    if ([zeek_irc][nick]) {
      mutate { id => "mutate_merge_zeek_irc_nick"
               merge => { "[irc][nick]" => "[zeek_irc][nick]" } }
      mutate { id => "mutate_add_field_irc_nickCnt"
               add_field => { "[irc][nickCnt]" => "1" } }
      # store "nick" alongside "user"
      mutate { id => "mutate_merge_irc_nick_user_1"
               merge => { "[zeek][user]" => "[zeek_irc][nick]" } }
      mutate { id => "mutate_merge_irc_nick_user_2"
               merge => { "[user]" => "[zeek_irc][nick]" } }
    }

    if ([zeek_irc][command]) and ([zeek_irc][value]) and (([zeek_irc][command] == "JOIN") or ([zeek_irc][command] == "PART")) {
      mutate { id => "mutate_merge_zeek_irc_channel"
               merge => { "[irc][channel]" => "[zeek_irc][value]" } }
      mutate { id => "mutate_add_field_irc_channelCnt"
               add_field => { "[irc][channelCnt]" => "1" } }
    }

  } else if ([source] == "intel") {
    #############################################################################################################################
    # intel.log specific logic

    if ([zeek_intel][sources]) { mutate { id => "mutate_split_zeek_intel_sources"
                                          split => { "[zeek_intel][sources]" => "," } } }


  } else if ([source] == "kerberos") {
    #############################################################################################################################
    # kerberos.log specific logic

    if ([zeek_kerberos][cname]) {
      mutate { id => "mutate_merge_zeek_kerberos_cname"
               merge => { "[krb5][cname]" => "[zeek_kerberos][cname]" } }
      mutate { id => "mutate_add_field_kerberos_cnameCnt"
               add_field => { "[krb5][cnameCnt]" => "1" } }
    }

    if ([zeek_kerberos][sname]) {
      mutate { id => "mutate_merge_zeek_kerberos_sname"
               merge => { "[krb5][sname]" => "[zeek_kerberos][sname]" } }
      mutate { id => "mutate_add_field_kerberos_snameCnt"
               add_field => { "[krb5][snameCnt]" => "1" } }
    }

    if ([zeek_kerberos][client_cert_fuid]) { mutate { id => "mutate_split_zeek_kerberos_client_cert_fuid"
                                                      split => { "[zeek_kerberos][client_cert_fuid]" => "," } } }

    if ([zeek_kerberos][server_cert_fuid]) { mutate { id => "mutate_split_zeek_kerberos_server_cert_fuid"
                                                      split => { "[zeek_kerberos][server_cert_fuid]" => "," } } }

  } else if ([source] == "ldap") {
    #############################################################################################################################
    # ldap.log specific logic
    # todo: ldap.authtype, ldap.authtypeCnt, ldap.bindname, ldap.bindnameCnt

  } else if ([source] == "modbus_detailed") {
    #############################################################################################################################
    # modbus_detailed.log specific logic

    if ([zeek_modbus_detailed][values]) {
      mutate { id => "mutate_split_zeek_modbus_detailed_values"
               split => { "[zeek_modbus_detailed][values]" => "," } }
    }

  } else if ([source] == "modbus_read_write_multiple_registers") {
    #############################################################################################################################
    # modbus_read_write_multiple_registers.log specific logic

    if ([zeek_modbus_read_write_multiple_registers][read_registers]) {
      mutate { id => "mutate_split_zeek_modbus_read_write_multiple_registers_read_registers"
               split => { "[zeek_modbus_read_write_multiple_registers][read_registers]" => "," } }
    }

    if ([zeek_modbus_read_write_multiple_registers][write_registers]) {
      mutate { id => "mutate_split_zeek_modbus_read_write_multiple_registers_write_registers"
               split => { "[zeek_modbus_read_write_multiple_registers][write_registers]" => "," } }
    }

  } else if ([source] == "mqtt_publish") {
    #############################################################################################################################
    # mqtt_publish.log specific logic

    # MQTT payload *may* be JSON, or it may not
    json {
      skip_on_invalid_json => true
      source => "[zeek_mqtt_publish][payload]"
      target => "[zeek_mqtt_publish][payload_dict]"
    }


  } else if ([source] == "mqtt_subscribe") {
    #############################################################################################################################
    # mqtt_subscribe.log specific logic

    mutate { id => "mutate_split_zeek_mqtt_subscribe_fields"
             split => { "[zeek_mqtt_subscribe][topics]" => ","
                        "[zeek_mqtt_subscribe][qos_levels]" => "," } }

  } else if ([source] == "mysql") {
    #############################################################################################################################
    # mysql.log specific logic

    if ([zeek_mysql][rows] == 0) {
      mutate { id => "mutate_remove_field_zeek_mysql_zero_rows"
               remove_field => [ "[zeek_mysql][rows]" ] }
    }

  } else if ([source] == "notice") {
    #############################################################################################################################
    # notice.log specific logic

    mutate { id => "mutate_split_zeek_notice_actions"
             split => { "[zeek_notice][actions]" => "," } }

    # split "Category::Subcategory" into two different fields
    ruby {
      id => "ruby_zeek_notice_category_extract"
      code => "
        if (noticeNote = event.get('[zeek_notice][note]')) and (noticeParts = noticeNote.split('::')) then
          if (noticeParts.length >= 2) then
            event.set('[zeek_notice][category]', noticeParts[0])
            event.set('[zeek_notice][sub_category]', noticeParts[1])
          elsif (noticeParts.length == 1) then
            event.set('[zeek_notice][category]', noticeParts[0])
          end
        end"
    }

    if ([zeek_notice][category] == "ATTACK") and ([zeek_notice][msg] =~ /(from|against|to)\s+host/) {
      # ATTACK::Discovery - Detected activity from host 192.168.199.133, total attempts 5 within timeframe 5.0 mins
      # but no IP addresses set :(
      if (![srcIp]) {
        grok {
          id => "grok_zeek_notice_attack_src_hosts"
          match => { "[zeek_notice][msg]" => [ "from%{SPACE}host%{SPACE}%{DATA:[srcIp]}%{SPACE}($|[^\d:\.\w-]+)" ] }
        }
        if ([srcIp]) { mutate { id => "mutate_add_field_zeek_orig_h_attack"
                                add_field => { "[zeek][orig_h]"   => "%{[srcIp]}" } } }
      }
      if (![dstIp]) {
        grok {
          id => "grok_zeek_notice_attack_dst_hosts"
          match => { "[zeek_notice][msg]" => [ "(against|to)%{SPACE}host%{SPACE}%{DATA:[dstIp]}%{SPACE}($|[^\d:\.\w-]+)" ] }
        }
        if ([dstIp]) { mutate { id => "mutate_add_field_zeek_resp_h_attack"
                                add_field => { "[zeek][resp_h]"   => "%{[dstIp]}" } } }
      }
    }

    if ([zeek_notice][note] == "Corelight::XOR_Encrypted_PE_File_Seen") and ([zeek_notice][sub] =~ /Decrypted File ID/) {
      # zeek_notice.note  Corelight::XOR_Encrypted_PE_File_Seen
      #
      #         zeek.fuid   F7QoY740DvrZF2lrsa
      # + zeek_notice.sub   Decrypted File ID: FqNQ8i3LbG2ZY5EO3k
      # -----------------
      # =       zeek.fuid   F7QoY740DvrZF2lrsa, FqNQ8i3LbG2ZY5EO3k
      grok {
        id => "grok_zeek_notice_xor_fuid"
        match => { "[zeek_notice][sub]" => [ "Decrypted%{SPACE}File%{SPACE}ID:%{SPACE}%{WORD:[@metadata][decrypted_xor_fuid]}" ] }
      }
      if ([@metadata][decrypted_xor_fuid]) { mutate { id => "mutate_merge_zeek_notice_decrypted_xor_fuid"
                                                      merge => { "[zeek][fuid]" => "[@metadata][decrypted_xor_fuid]" } } }
    }

    if ([zeek_notice][note] == "Signatures::Sensitive_Signature") and ([zeek_notice][msg] =~ /WireGuard Handshake/) {
      # I don't want a signature for wireguard handshake initiation
      drop { id => "drop_zeek_ignored_notice_wg" }
    }

  } else if ([source] == "ntp") {
    #############################################################################################################################
    # ntp.log specific logic

    # map mode to string for readability
    if ([zeek_ntp][mode]) {
      translate {
        id => "translate_zeek_ntp_mode_str"
        field => "[zeek_ntp][mode]"
        destination => "[zeek_ntp][mode_str]"
        dictionary_path => "/etc/ntp_modes.yaml"
      }
    }

  } else if ([source] == "pe") {
    #############################################################################################################################
    # pe.log specific logic

    mutate { id => "mutate_split_zeek_pe_section_names"
             split => { "[zeek_pe][section_names]" => "," } }

  } else if ([source] == "radius") {
    #############################################################################################################################
    # radius.log specific logic

    if ([zeek][user]) { mutate { id => "mutate_merge_zeek_radius_user"
                                merge => { "[radius][user]" => "[zeek][user]" } } }

    if ([zeek_radius][framed_addr]) {
      mutate { id => "mutate_merge_zeek_radius_framed_addr"
               merge => { "[radius][framedIp]" => "[zeek_radius][framed_addr]" } }
      mutate { id => "mutate_add_field_radius_framedIpCnt"
               add_field => { "[radius][framedIpCnt]" => "1" } }
    }

    if ([zeek_radius][tunnel_client]) {
      mutate { id => "mutate_merge_zeek_radius_tunnel_client"
               merge => { "[radius][endpointIp]" => "[zeek_radius][tunnel_client]" } }
      mutate { id => "mutate_add_field_radius_endpointIpCnt"
               add_field => { "[radius][endpointIpCnt]" => "1" } }
    }

    if ([zeek_radius][mac]) {
      mutate { id => "mutate_merge_zeek_radius_mac"
               merge => { "[radius][mac]" => "[zeek_radius][mac]" } }
      mutate { id => "mutate_add_field_radius_macCnt"
               add_field => { "[radius][macCnt]" => "1" } }
      if (![zeek][orig_l2_addr]) {
        mutate { id => "mutate_merge_zeek_radius_zeek_mac"
                 merge => { "[zeek][orig_l2_addr]" => "[zeek_radius][mac]" } }
      }
    }

  } else if ([source] == "rdp") {
    #############################################################################################################################
    # rdp.log specific logic

    mutate { id => "mutate_split_zeek_rdp_client_channels"
             split => { "[zeek_rdp][client_channels]" => "," } }


  } else if ([source] == "s7comm") {
    #############################################################################################################################
    # s7comm.log specific logic

    if ([zeek_s7comm][parameter]) {
      ruby {
        id => "ruby_zeek_s7comm_parse_parameter"
        code => "
          parameterHash = event.get('[zeek_s7comm][parameter]').split(',').each_with_object({}) do |a, hash|
            key,value = a.split(/\s*=\s*/)
            hash[key] = value
          end
          event.set('[zeek_s7comm][parameters]', parameterHash)"
      }
      mutate { id => "mutate_split_field_s7comm_parameter"
               split => { "[zeek_s7comm][parameter]" => "," } }
    }

    if ([zeek_s7comm][data_info] == "Null") {
      mutate { id => "mutate_remove_field_s7comm_data_info_null"
               remove_field => [ "[zeek_s7comm][data_info]" ] }
    } else if ([zeek_s7comm][data_info]) {
      mutate { id => "mutate_split_field_s7comm_data_info"
               split => { "[zeek_s7comm][data_info]" => "," } }
    }

  } else if ([source] == "signatures") {
    #############################################################################################################################
    # signatures.log specific logic

    if ("_carved" in [tags]) {
      # Malcolm does some "special" stuff in zeek_carve_logger.py for file carving, sort of hijacking signatures.log for it

      # sub_message contains fuid(s) comma-separated
      if ([zeek_signatures][sub_message]) {
        mutate { id => "mutate_split_zeek_signatures_sub_message"
                 split => { "[zeek_signatures][sub_message]" => "," } }
        mutate { id => "mutate_rename_zeek_signatures_sub_message"
                 rename => { "[zeek_signatures][sub_message]" => "[zeek][fuid]" } }
      }

      if ([zeek_signatures][event_message]) {
        # sub_message contains "Signature [Engine]" list semi-colon separated
        ruby {
            id => "ruby_zeek_signatures_event_message_parse"
            code => "
                matchesHash = Hash.new
                idArray = Array.new
                event.get('[zeek_signatures][event_message]').split(';').each { |hit|
                  nameAndEngines = hit.split(/(.+?)\s*<(.+)>/)
                  nameAndEngines[2].split(',').each { |engine|
                    unless matchesHash.key?(engine)
                      matchesHash[engine] = Array.new
                    end
                    matchesHash[engine].push(nameAndEngines[1])
                    idArray.push(nameAndEngines[1])
                  }
                }
                event.set('[zeek_signatures][signature_id]', idArray.uniq)
                event.set('[zeek_signatures][engine]', matchesHash.keys)
                event.set('[zeek_signatures][hits]', matchesHash)"
        }
        mutate {
          id => "mutate_remove_field_zeek_signatures_event_message"
          remove_field => [ "[zeek_signatures][event_message]" ]
        }
      }

    } else {
      if ([zeek_signatures][signature_id] =~ /^dpd_/) {
        # I don't care about DPD matching signatures
        drop { id => "drop_zeek_ignored_signatures_dpd" }
      }
    }

  } else if ([source] == "sip") {
    #############################################################################################################################
    # sip.log specific logic

    ruby {
      id => "ruby_zeek_field_zeek_sip_version"
      code => '
      versions = Array.new
      paths = [event.get("[zeek_sip][request_path]"), event.get("[zeek_sip][response_path]")].compact.join(",")
      paths.scan(/\bSIP:?\/([\d\.]+)/i) { |match| versions << match[0] }
      event.set("[zeek_sip][version]", versions.uniq)'
    }

    mutate { id => "mutate_split_zeek_sip_request_path"
             split => { "[zeek_sip][request_path]" => "," } }

    mutate { id => "mutate_split_zeek_sip_response_path"
             split => { "[zeek_sip][response_path]" => "," } }


  } else if ([source] == "smb_cmd") or ([source] == "smb_files") {
    #############################################################################################################################
    # smb_cmd.log and smb_files.log specific logic
    # note that smb_cmd.referenced_file is exactly the same structure as the log line for smb_files, which is why I've combined
    # the logic here to avoid duplication

    if ([zeek_smb_cmd]) {

      if ([zeek_smb_cmd][referenced_file]) {

        # move "up" referenced_file to its own smb_files top-level entity
        mutate {
          id => "mutate_rename_zeek_zeek_smb_cmd_referenced_file"
          rename => { "[zeek_smb_cmd][referenced_file]" => "[zeek_smb_files]" }
        }

        # remove unset (-) or "(empty)" referenced_file (now zeek_smb_files) subfield values
        ruby {
          id => "ruby_zeek_remove_empty_smb_cmd_referenced_file_values"
          code => "
            fieldsHash = event.get('[zeek_smb_files]').to_hash
            fieldsHash.delete_if{|_,v| ((v == nil) or (v == '') or (v == '-') or (v == '(empty)'))}
            event.set('[zeek_smb_files]', fieldsHash)
          "
        }

        # collect referenced file FUID(s) at parent level (here rather than in 12_zeek_normalize.conf because
        # this would have already been done as a root-level fuid array in the main "rename" above if we
        # had not had to move it up a level just now)
        if ([zeek_smb_files][fuid]) {
          mutate { id => "mutate_merge_zeek_smb_files_fuid"
                   merge => { "[zeek][fuid]" => "[zeek_smb_files][fuid]" } }
          mutate { id => "mutate_remove_zeek_smb_files_fuid"
                   remove_field => [ "[zeek_smb_files][fuid]" ] }
        }

        if ([zeek_smb_files][action]) { mutate { id => "mutate_gsub_zeek_smb_cmd_referenced_file_action"
                                                 gsub => [ "[zeek_smb_files][action]", "^SMB::", "" ] } }

      } # if ([zeek_smb_cmd][referenced_file])

    } # if ([zeek_smb_cmd])

    # this should now apply to either lines from smb_files.log or smb_cmd.referenced_file
    if ([zeek_smb_files]) {

      if ([zeek_smb_files][name]) { mutate { id => "mutate_merge_zeek_smb_files_name_to_filename"
                                            merge => { "[smb][filename]" => "[zeek_smb_files][name]" } } }
      if ([zeek_smb_files][prev_name]) { mutate { id => "mutate_merge_zeek_smb_files_prev_name_to_filename"
                                                 merge => { "[smb][filename]" => "[zeek_smb_files][prev_name]" } } }
      if ([smb][filename]) {
        ruby {
          id => "ruby_zeek_smb_files_filenameCnt"
          code => "event.set('[smb][filenameCnt]', event.get('[smb][filename]').length)"
        }
      }

      if ([zeek_smb_files][path]) {
        grok {
          id => "grok_zeek_smb_files_path"
          match => { "[zeek_smb_files][path]" => [ "^%{SPACE}[\\\/]+%{DATA:[@metadata][smb_host]}[\\\/]+%{DATA:[@metadata][smb_share]}(?:[\\\/]+%{GREEDYDATA:[@metadata][smb_path]})?$" ] }
        }
        if ([@metadata][smb_host]) {
          mutate { id => "mutate_merge_zeek_smb_files_host"
                   merge => { "[smb][host]" => "[@metadata][smb_host]" } }
          mutate { id => "mutate_add_field_smb_hostCnt"
                   add_field => { "[smb][hostCnt]" => "1" } }
        }
        if ([@metadata][smb_share]) {
          mutate { id => "mutate_merge_zeek_smb_files_share"
                   merge => { "[smb][share]" => "[@metadata][smb_share]" } }
          ruby {
            id => "ruby_zeek_smb_files_shareCnt"
            code => "event.set('[smb][shareCnt]', event.get('[smb][share]').length)"
          }
        }
      }

    } # if ([zeek_smb_files])

  } else if ([source] == "smb_mapping") {
    #############################################################################################################################
    # smb_mapping.log specific logic

    if ([zeek_smb_mapping][path]) {
      # todo: figure out how to replace \\ -> \
      mutate { id => "mutate_merge_zeek_smb_mapping_share"
               merge => { "[smb][share]" => "[zeek_smb_mapping][path]" } }
    }

    if ([zeek_smb_mapping][path]) {
      grok {
        id => "grok_zeek_smb_mapping_path"
        match => { "[zeek_smb_mapping][path]" => [ "^%{SPACE}[\\\/]+%{DATA:[@metadata][smb_host]}[\\\/]+%{DATA:[@metadata][smb_share]}(?:[\\\/]+%{GREEDYDATA:[@metadata][smb_path]})?$" ] }
      }
      if ([@metadata][smb_host]) {
        mutate { id => "mutate_merge_zeek_smb_mapping_host"
                 merge => { "[smb][host]" => "[@metadata][smb_host]" } }
        mutate { id => "mutate_add_field_smb_mapping_hostCnt"
                 add_field => { "[smb][hostCnt]" => "1" } }
      }
      if ([@metadata][smb_share]) {
        mutate { id => "mutate_merge_zeek_smb_mapping_share_from_path"
                 merge => { "[smb][share]" => "[@metadata][smb_share]" } }
      }
    }

    if ([smb][share]) {
      ruby {
        id => "ruby_zeek_smb_mapping_shareCnt"
        code => "event.set('[smb][shareCnt]', event.get('[smb][share]').length)"
      }
    }

  } else if ([source] == "smtp") {
    #############################################################################################################################
    # smtp.log specific logic

    mutate { id => "mutate_split_zeek_smtp_rcptto"
             split => { "[zeek_smtp][rcptto]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_to"
             split => { "[zeek_smtp][to]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_cc"
             split => { "[zeek_smtp][cc]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_path"
             split => { "[zeek_smtp][path]" => "," } }

    if ([zeek_smtp][user_agent]) {
      mutate { id => "mutate_merge_zeek_smtp_user_agent"
               merge => { "[email][useragent]" => "[zeek_smtp][user_agent]" } }
      mutate { id => "mutate_add_field_email_useragentCnt"
               add_field => { "[email][useragentCnt]" => "1" } }
    }

    if ([zeek_smtp][from]) { mutate { id => "mutate_merge_zeek_smtp_from"
                                     merge => { "[email][src]" => "[zeek_smtp][from]" } } }
    if ([zeek_smtp][mailfrom]) { mutate { id => "mutate_merge_zeek_smtp_mailfrom"
                                         merge => { "[email][src]" => "[zeek_smtp][mailfrom]" } } }
    if ([zeek_smtp][reply_to]) { mutate { id => "mutate_merge_zeek_smtp_reply_to"
                                         merge => { "[email][src]" => "[zeek_smtp][reply_to]" } } }
    if ([email][src]) {
      ruby {
        id => "ruby_zeek_smtp_src"
        code => "event.set('[email][src]', event.get('[email][src]').uniq)
                 event.set('[email][srcCnt]', event.get('[email][src]').length)"
      }
    }

    if ([zeek_smtp][to]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_to"
                                   merge => { "[email][dst]" => "[zeek_smtp][to]" } } }
    if ([zeek_smtp][cc]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_cc"
                                   merge => { "[email][dst]" => "[zeek_smtp][cc]" } } }
    if ([zeek_smtp][rcptto]) { mutate { id => "mutate_merge_zeek_dst_from_rcptto"
                                       merge => { "[email][dst]" => "[zeek_smtp][rcptto]" } } }
    if ([zeek_smtp][helo]) {
      mutate { id => "mutate_merge_zeek_smtp_helo"
               merge => { "[email][smtpHello]" => "[zeek_smtp][helo]" } }
      mutate { id => "mutate_merge_add_field_zeek_smtp_helo_cnt"
               add_field => { "[email][smtpHelloCnt]" => "1" } }
    }
    if ([email][dst]) {
      ruby {
        id => "ruby_zeek_smtp_dst"
        code => "event.set('[email][dst]', event.get('[email][dst]').uniq)
                 event.set('[email][dstCnt]', event.get('[email][dst]').length)"
      }
    }

    if ([zeek_smtp][subject]) {
      mutate { id => "mutate_merge_zeek_smtp_subject"
               merge => { "[email][subject]" => "[zeek_smtp][subject]" } }
      mutate { id => "mutate_add_field_email_subjectCnt"
               add_field => { "[email][subjectCnt]" => "1" } }
    }

    if ([zeek_smtp][msg_id]) {
      mutate { id => "mutate_gsub_zeek_smtp_msg_id"
               gsub => [ "[zeek_smtp][msg_id]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_msg_id"
               merge => { "[email][id]" => "[zeek_smtp][msg_id]" } }
    }
    if ([zeek_smtp][in_reply_to]) {
      mutate { id => "mutate_gsub_zeek_smtp_in_reply_to"
               gsub => [ "[zeek_smtp][in_reply_to]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_in_reply_to"
               merge => { "[email][id]" => "[zeek_smtp][in_reply_to]" } }
    }
    if ([zeek_smtp][id]) {
      ruby {
        id => "ruby_zeek_smtp_idCnt"
        code => "event.set('[email][idCnt]', event.get('[email][id]').length)"
      }
    }

    if ([zeek_smtp][last_reply]) {
      # will be mapped to a "result" later in normalization
      grok {
        id => "grok_zeek_zeek_smtp_last_reply"
        match => { "[zeek_smtp][last_reply]" => [ "^%{SPACE}%{NUMBER:[zeek_smtp][last_reply_code]}" ] }
      }
    }

  } else if ([source] == "ssh") {
    #############################################################################################################################
    # ssh.log specific logic

    if ([zeek_ssh][server]) { mutate { id => "mutate_merge_zeek_ssh_server_version"
                                       merge => { "[ssh][version]" => "[zeek_ssh][server]" } } }

    if ([zeek_ssh][client]) { mutate { id => "mutate_merge_zeek_client_version"
                                       merge => { "[ssh][version]" => "[zeek_ssh][client]" } } }

    if (![ssh][version]) and ([zeek_ssh][version]) { mutate { id => "mutate_merge_zeek_ssh_version"
                                                              merge => { "[ssh][version]" => "[zeek_ssh][version]" } } }

    if ([ssh][version]) { mutate { id => "mutate_add_field_ssh_versionCnt"
                                   add_field => { "[ssh][versionCnt]" => "1" } } }

    if ([zeek_ssh][host_key] and [zeek_ssh][host_key_alg]) {
      # this is stupid, the %{} doesn't seem to be liked by mutate.merge
      mutate { id => "mutate_add_field_zeek_ssh_host_key"
               add_field => { "[@metadata][ssh_key_str]" => "%{[zeek_ssh][host_key_alg]} %{[zeek_ssh][host_key]}" } }
      mutate { id => "mutate_merge_zeek_ssh_key"
               merge => { "[ssh][key]" => "[@metadata][ssh_key_str]" } }
      mutate { id => "mutate_add_field_ssh_keyCnt"
               add_field => { "[ssh][keyCnt]" => "1" } }
    }

    # HASSH stuff (see https://github.com/salesforce/hassh/tree/master/bro)

    if ([zeek_ssh][hassh]) {
      mutate { id => "mutate_merge_zeek_ssh_hassh"
               merge => { "[ssh][hassh]" => "[zeek_ssh][hassh]" } }
      mutate { id => "mutate_add_field_zeek_ssh_hasshCnt"
               add_field =>  { "[ssh][hasshCnt]" => "1" } }
    }

    if ([zeek_ssh][hasshServer]) {
      mutate { id => "mutate_merge_zeek_ssh_hasshServer"
               merge => { "[ssh][hasshServer]" => "[zeek_ssh][hasshServer]" } }
      mutate { id => "mutate_add_field_zeek_ssh_hasshServerCnt"
               add_field =>  { "[ssh][hasshServerCnt]" => "1" } }
    }

    if ([zeek_ssh][hasshAlgorithms]) { mutate { id => "mutate_split_zeek_ssh_hasshAlgorithms"
                                                split => { "[zeek_ssh][hasshAlgorithms]" => "," } } }

    if ([zeek_ssh][hasshServerAlgorithms]) { mutate { id => "mutate_split_zeek_ssh_hasshServerAlgorithms"
                                                      split => { "[zeek_ssh][hasshServerAlgorithms]" => "," } } }

    if ([zeek_ssh][cshka]) { mutate { id => "mutate_split_zeek_ssh_cshka"
                                      split => { "[zeek_ssh][cshka]" => "," } } }

    if ([zeek_ssh][sshka]) { mutate { id => "mutate_split_zeek_ssh_sshka"
                                      split => { "[zeek_ssh][sshka]" => "," } } }


  } else if ([source] == "ssl") {
    #############################################################################################################################
    # ssl.log specific logic

    # split subjects/issuers out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek_ssl][subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_subject"
               gsub => [ "[zeek_ssl][subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_subject"
               rename => { "[zeek_ssl][subject]" => "[zeek_ssl][subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_subject"
        field_split => ","
        source => "[zeek_ssl][subject_full]"
        target => "[zeek_ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject"
        field => "[zeek_ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject_full"
        field => "[zeek_ssl][subject_full]"
      }
    }

    if ([zeek_ssl][client_subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_subject"
               gsub => [ "[zeek_ssl][client_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_subject"
               rename => { "[zeek_ssl][client_subject]" => "[zeek_ssl][client_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_subject"
        field_split => ","
        source => "[zeek_ssl][client_subject_full]"
        target => "[zeek_ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject"
        field => "[zeek_ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject_full"
        field => "[zeek_ssl][client_subject_full]"
      }
    }

    if ([zeek_ssl][issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_issuer"
               gsub => [ "[zeek_ssl][issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_issuer"
               rename => { "[zeek_ssl][issuer]" => "[zeek_ssl][issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_issuer"
        field_split => ","
        source => "[zeek_ssl][issuer_full]"
        target => "[zeek_ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer"
        field => "[zeek_ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer_full"
        field => "[zeek_ssl][issuer_full]"
      }
    }

    if ([zeek_ssl][client_issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_issuer"
               gsub => [ "[zeek_ssl][client_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_issuer"
               rename => { "[zeek_ssl][client_issuer]" => "[zeek_ssl][client_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_issuer"
        field_split => ","
        source => "[zeek_ssl][client_issuer_full]"
        target => "[zeek_ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer"
        field => "[zeek_ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer_full"
        field => "[zeek_ssl][client_issuer_full]"
      }
    }

    if ([zeek_ssl][ssl_version]) {
      mutate { id => "mutate_merge_zeek_ssl_version"
               merge => { "[tls][version]" => "[zeek_ssl][ssl_version]" } }
      mutate { id => "mutate_add_field_ssl_versionCnt"
               add_field => { "[tls][versionCnt]" => "1" } }
    }

    if ([zeek_ssl][cipher]) {
      mutate { id => "mutate_merge_zeek_ssl_cipher"
               merge => { "[tls][cipher]" => "[zeek_ssl][cipher]" } }
      mutate { id => "mutate_add_field_ssl_cipherCnt"
               add_field => { "[tls][cipherCnt]" => "1" } }
    }

    if ([zeek_ssl][ja3]) {
      mutate { id => "mutate_merge_zeek_ssl_ja3"
               merge => { "[tls][ja3]" => "[zeek_ssl][ja3]" } }
      mutate { id => "mutate_add_field_zeek_ssl_ja3Cnt"
               add_field => { "[tls][ja3Cnt]" => "1" } }
    }

    if ([zeek_ssl][ja3s]) {
      mutate { id => "mutate_merge_zeek_ssl_ja3s"
               merge => { "[tls][ja3s]" => "[zeek_ssl][ja3s]" } }
      mutate { id => "mutate_add_field_zeek_ssl_ja3sCnt"
               add_field => { "[tls][ja3sCnt]" => "1" } }
    }

    if ([zeek_ssl][cert_chain_fuids]) { mutate { id => "mutate_split_zeek_ssl_cert_chain_fuids"
                                                 split => { "[zeek_ssl][cert_chain_fuids]" => "," } } }

    if ([zeek_ssl][client_cert_chain_fuids]) { mutate { id => "mutate_split_zeek_ssl_client_cert_chain_fuids"
                                                        split => { "[zeek_ssl][client_cert_chain_fuids]" => "," } } }

  } else if ([source] == "tds_rpc") {
    #############################################################################################################################
    # tds_rpc.log specific logic

    if ([zeek_tds_rpc][parameter]) {
      ruby {
        id => "ruby_zeek_tds_rpc_parse_parameter"
        code => "
          parameterHash = event.get('[zeek_tds_rpc][parameter]').split(',').each_with_object({}) do |a, hash|
            key,value = a.split(/\s*=\s*/)
            hash[key.delete_prefix('@')] = value
          end
          event.set('[zeek_tds_rpc][parameters]', parameterHash)"
      }

      mutate { id => "mutate_split_field_tds_rpc_parameter"
               split => { "[zeek_tds_rpc][parameter]" => "," } }
    }

  } else if ([source] == "x509") {
    #############################################################################################################################
    # x509.log specific logic

    # split subject/issuer out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek_x509][certificate_subject]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_subject"
               gsub => [ "[zeek_x509][certificate_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_subject"
               rename => { "[zeek_x509][certificate_subject]" => "[zeek_x509][certificate_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_subject"
        field_split => ","
        source => "[zeek_x509][certificate_subject_full]"
        target => "[zeek_x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject"
        field => "[zeek_x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject_full"
        field => "[zeek_x509][certificate_subject_full]"
      }
      if ([zeek_x509][certificate_subject][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_subject_CN"
                 merge => { "[@metadata][cert][subjectCN]" => "[zeek_x509][certificate_subject][CN]" } }
      }
      if ([zeek_x509][certificate_subject][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_subject_O"
                 add_field => { "[@metadata][cert][subjectON]" => "%{[zeek_x509][certificate_subject][O]}" } }
      }
    }

    if ([zeek_x509][certificate_issuer]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_issuer"
               gsub => [ "[zeek_x509][certificate_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_issuer"
               rename => { "[zeek_x509][certificate_issuer]" => "[zeek_x509][certificate_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_issuer"
        field_split => ","
        source => "[zeek_x509][certificate_issuer_full]"
        target => "[zeek_x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer"
        field => "[zeek_x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer_full"
        field => "[zeek_x509][certificate_issuer_full]"
      }
      if ([zeek_x509][certificate_issuer][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_issuer_CN"
                 merge => { "[@metadata][cert][issuerCN]" => "[zeek_x509][certificate_issuer][CN]" } }
      }
      if ([zeek_x509][certificate_issuer][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_issuer_O"
                 add_field => { "[@metadata][cert][issuerON]" => "%{[zeek_x509][certificate_issuer][O]}" } }
      }
    }

    if ([zeek_x509][certificate_not_valid_before]) and ([zeek_x509][certificate_not_valid_after]) {
      ruby {
        id => "ruby_zeek_x509_valid_range"
        code => "event.set('[@metadata][cert][notBefore]', (1000*event.get('[zeek_x509][certificate_not_valid_before]').to_f).round(0))
                 event.set('[@metadata][cert][notAfter]', (1000*event.get('[zeek_x509][certificate_not_valid_after]').to_f).round(0))
                 event.set('[@metadata][cert][validDays]', ((event.get('[zeek_x509][certificate_not_valid_after]').to_f - event.get('[zeek_x509][certificate_not_valid_before]').to_f)/(24.0*60.0*60.0)).round(0))"
      }
      mutate {
        id => "mutate_convert_zeek_x509_time_range"
        convert => {
          "[@metadata][cert][notBefore]" => "integer"
          "[@metadata][cert][notAfter]" => "integer"
          "[@metadata][cert][validDays]" => "float"
        }
      }
    }

    if ([zeek_x509][certificate_serial]) {
      # todo: serial not showing up right...
      # ruby {
      #  id => "ruby_zeek_x509_serial"
      #  code => "event.set('[@metadata][cert][serial]', event.get('[certificate_serial]').unpack('C*').map {|e| e.to_s 16}.join(':'))"
      # }
      mutate { id => "mutate_add_field_zeek_x509_serial"
               add_field => { "[@metadata][cert][serial]" => "%{[zeek_x509][certificate_serial]}" } }
    }

    if ([@metadata][cert]) {
      ruby {
          id => "ruby_zeek_x509_cert_array_set"
          code => "
              certArray = Array.new
              certArray.push(event.get('[@metadata][cert]'))
              event.set('[cert]', certArray)"
      }
    }


  } # end if/else if/else for specific log type logic
  #######################################################################################################

  # rename source (eg., conn, ssh, etc.) to zeek.logType
  mutate { id => "mutate_rename_zeek_logType"
           rename => { "[source]" => "[zeek][logType]" } }

  # kind of a unique case, smb_cmd can also be smb_files
  if ([zeek][logType] == "smb_cmd") and ([zeek_smb_files]) {
    # seriously I do not get how merge works, why can't I just merge the string literal?
    mutate { id => "mutate_add_field_zeek_tmp_logtype"
             add_field => { "[@metadata][tmpLogType]" => "smb_files" } }
    mutate { id => "mutate_merge_zeek_smb_cmd_and_smb_files_logType"
             merge => { "[zeek][logType]" => "[@metadata][tmpLogType]" } }
  }

  # get counts for some arrays that each log type may contribute to individually
  if ([protocol]) {
    ruby {
      id => "ruby_zeek_protocolCnt"
      code => "event.set('[protocolCnt]', event.get('[protocol]').length)"
    }
  }
  if ([user]) {
    ruby {
      id => "ruby_zeek_userCnt"
      code => "event.set('[userCnt]', event.get('[user]').length)"
    }
  }

} # end Filter
