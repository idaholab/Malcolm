filter {

  # Protocol/service version ##########################################################################################
  # collect protocol version under the parent zeek.service_version array

  if ([zeek_gquic][version])                    { mutate { id => "mutate_merge_normalize_zeek_gquic_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_gquic][version]" } } }

  if ([zeek_http][version])                     { mutate { id => "mutate_merge_normalize_zeek_http_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_http][version]" } } }

  if ([zeek_ntp][version])                      { mutate { id => "mutate_merge_normalize_zeek_ntp_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_ntp][version]" } } }

  if ([zeek_profinet][block_version])           { mutate { id => "mutate_merge_normalize_zeek_profinet_block_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_profinet][block_version]" } } }

  if ([zeek_profinet_dce_rpc][version])         { mutate { id => "mutate_merge_normalize_zeek_profinet_dce_rpc_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_profinet_dce_rpc][version]" } } }

  if ([zeek_rfb]) {
    ruby {
      id => "ruby_zeek_field_zeek_service_version_rfb"
      code => '
        versions = Array.new
        clientMajorVersion = event.get("[zeek_rfb][client_major_version]").sub!(/^0*/, "")
        clientMinorVersion = event.get("[zeek_rfb][client_minor_version]").sub!(/^0*/, "")
        serverMajorVersion = event.get("[zeek_rfb][server_major_version]").sub!(/^0*/, "")
        serverMinorVersion = event.get("[zeek_rfb][server_minor_version]").sub!(/^0*/, "")
        if clientMajorVersion then
          versions << [clientMajorVersion, clientMinorVersion].join(".")
        end
        if serverMajorVersion then
          versions << [serverMajorVersion, serverMinorVersion].join(".")
        end
        event.set("[zeek][service_version]", versions.uniq)'
    }
  }

  if ([zeek_rdp][client_build])                 { mutate { id => "mutate_merge_normalize_zeek_rdp_client_build"
                                                           merge => { "[zeek][service_version]" => "[zeek_rdp][client_build]" } } }

  if ([zeek_smtp][version])                      { mutate { id => "mutate_merge_normalize_zeek_smtp_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_smtp][version]" } } }

  if ([zeek_smb_cmd][version])                  { mutate { id => "mutate_merge_normalize_zeek_smb_cmd_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_smb_cmd][version]" } } }

  if ([zeek_snmp][version])                     { mutate { id => "mutate_merge_normalize_zeek_snmp_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_snmp][version]" } } }

  if ([zeek_socks][version])                    { mutate { id => "mutate_merge_normalize_zeek_socks_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_socks][version]" } } }

  if ([zeek_ssh][version])                      { mutate { id => "mutate_merge_normalize_zeek_ssh_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_ssh][version]" } } }

  if ([zeek_ssl][ssl_version])                  { mutate { id => "mutate_merge_normalize_zeek_ssl_ssl_version"
                                                           merge => { "[zeek][service_version]" => "[zeek_ssl][ssl_version]" } } }

  if ([zeek][service_version]) {
    ruby {
      id => "ruby_zeek_service_version_uniq"
      code => "event.set('[zeek][service_version]', event.get('[zeek][service_version]').uniq)"
    }
  }

  # Action ############################################################################################################
  # collect all actions/operations/commands under the parent [zeek][action] array

  if ([zeek_bacnet][pdu_service])               { mutate { id => "mutate_merge_normalize_zeek_bacnet_pdu_service"
                                                           merge => { "[zeek][action]" => "[zeek_bacnet][pdu_service]" } } }

  if ([zeek_bacnet_discovery][pdu_service])     { mutate { id => "mutate_merge_normalize_zeek_bacnet_discovery_pdu_service"
                                                           merge => { "[zeek][action]" => "[zeek_bacnet_discovery][pdu_service]" } } }

  if ([zeek_bacnet_property][pdu_service])      { mutate { id => "mutate_merge_normalize_zeek_bacnet_property_pdu_service"
                                                           merge => { "[zeek][action]" => "[zeek_bacnet_property][pdu_service]" } } }

  if ([zeek_bsap_ip_rdb]) {
    ruby {
      # action = zeek_bsap_ip_rdb.app_func_code:zeek_bsap_ip_rdb.func_code
      id => "ruby_zeek_bsap_ip_rdb_generate_action"
      code => "
        actions = Array.new unless (actions = event.get('[zeek][action]'))
        actions.append([event.get('[zeek_bsap_ip_rdb][app_func_code]'),
                        event.get('[zeek_bsap_ip_rdb][func_code]')].compact.join(':'))
        event.set('[zeek][action]', actions)"
    }
  }

  if ([zeek_bsap_serial_header][sfun])          { mutate { id => "mutate_merge_normalize_zeek_bsap_serial_header_sfun"
                                                           merge => { "[zeek][action]" => "[zeek_bsap_serial_header][sfun]" } } }

  if ([zeek_bsap_serial_header][dfun])          { mutate { id => "mutate_merge_normalize_zeek_bsap_serial_header_dfun"
                                                           merge => { "[zeek][action]" => "[zeek_bsap_serial_header][dfun]" } } }

  if ([zeek_bsap_serial_rdb][func_code])        { mutate { id => "mutate_merge_normalize_zeek_bsap_serial_rdb_func_code"
                                                           merge => { "[zeek][action]" => "[zeek_bsap_serial_rdb][func_code]" } } }

  if ([zeek_bsap_serial_rdb_ext][sfun])         { mutate { id => "mutate_merge_normalize_zeek_bsap_serial_rdb_ext_sfun"
                                                           merge => { "[zeek][action]" => "[zeek_bsap_serial_rdb_ext][sfun]" } } }

  if ([zeek_bsap_serial_rdb_ext][dfun])         { mutate { id => "mutate_merge_normalize_zeek_bsap_serial_rdb_ext_dfun"
                                                           merge => { "[zeek][action]" => "[zeek_bsap_serial_rdb_ext][dfun]" } } }

  if ([zeek_bsap_serial_rdb_ext][extfun])       { mutate { id => "mutate_merge_normalize_zeek_bsap_serial_rdb_ext_extfun"
                                                           merge => { "[zeek][action]" => "[zeek_bsap_serial_rdb_ext][extfun]" } } }

  if ([zeek_cip][cip_service])                  { mutate { id => "mutate_merge_normalize_zeek_cip_cip_service"
                                                           merge => { "[zeek][action]" => "[zeek_cip][cip_service]" } } }

  if ([zeek_dce_rpc][operation])                { mutate { id => "mutate_merge_normalize_zeek_dce_rpc_operation"
                                                           merge => { "[zeek][action]" => "[zeek_dce_rpc][operation]" } } }

  if ([zeek_dhcp][msg_types])                   { mutate { id => "mutate_merge_normalize_zeek_dhcp_msg_types"
                                                           merge => { "[zeek][action]" => "[zeek_dhcp][msg_types]" } } }

  if ([zeek_dnp3][fc_request])                  { mutate { id => "mutate_merge_normalize_zeek_dnp3_fc_request"
                                                           merge => { "[zeek][action]" => "[zeek_dnp3][fc_request]" } } }

  if ([zeek_dnp3_control]) {
    ruby {
      # action = function_code:operation_type:trip_control_code
      id => "ruby_zeek_dnp3_control_generate_action"
      code => "
        actions = Array.new unless (actions = event.get('[zeek][action]'))
        actions.append([event.get('[zeek_dnp3_control][function_code]'),
                        event.get('[zeek_dnp3_control][operation_type]'),
                        event.get('[zeek_dnp3_control][trip_control_code]')].compact.join(':'))
        event.set('[zeek][action]', actions)"
    }
  }

  if ([zeek_dnp3_read_objects][function_code])  { mutate { id => "mutate_merge_normalize_zeek_dnp3_read_objects"
                                                           merge => { "[zeek][action]" => "[zeek_dnp3_read_objects][function_code]" } } }

  if ([zeek_dns]) {
    # action: query class and type
    if ([zeek_dns][qclass_name]) and ([zeek_dns][qtype_name]) {
      mutate { id => "mutate_add_field_metadata_dns_class_and_type"
               add_field => { "[@metadata][dns_action]" => "%{[zeek_dns][qclass_name]} %{[zeek_dns][qtype_name]}" } }
    } else if ([zeek_dns][qclass_name]) {
      mutate { id => "mutate_add_field_metadata_dns_class"
               add_field => { "[@metadata][dns_action]" => "%{[zeek_dns][qclass_name]}" } }
    } else if ([zeek_dns][qtype_name]) {
      mutate { id => "mutate_add_field_metadata_dns_type"
               add_field => { "[@metadata][dns_action]" => "%{[zeek_dns][qtype_name]}" } }
    } else {
      mutate { id => "mutate_add_field_metadata_dns_query"
               add_field => { "[@metadata][dns_action]" => "Query" } }
    }
    mutate { id => "mutate_merge_zeek_dns_action"
             merge => { "[zeek][action]" => "[@metadata][dns_action]" } }
  }

  if ([zeek_enip][enip_command])                { mutate { id => "mutate_merge_normalize_zeek_enip_enip_command"
                                                           merge => { "[zeek][action]" => "[zeek_enip][enip_command]" } } }

  if ([zeek_ftp][command])                      { mutate { id => "mutate_merge_normalize_zeek_ftp_command"
                                                           merge => { "[zeek][action]" => "[zeek_ftp][command]" } } }

  if ([zeek_http]) {
    if ([zeek_http][method])  {
      mutate { id => "mutate_merge_normalize_zeek_http_method"
               merge => { "[zeek][action]" => "[zeek_http][method]" } }
    } else {
      mutate { id => "mutate_add_field_zeek_http_request_action"
               add_field => { "[@metadata][http_request_action]" => "Request" } }
      mutate { id => "mutate_merge_field_zeek_http_request_action"
               merge => { "[zeek][action]" => "[@metadata][http_request_action]" } }
    }
  }

  if ([zeek_irc][command])                      { mutate { id => "mutate_merge_normalize_zeek_irc_command"
                                                           merge => { "[zeek][action]" => "[zeek_irc][command]" } } }

  if ([zeek_iso_cotp][pdu_type])                { mutate { id => "mutate_merge_normalize_zeek_iso_cotp_pdu_type"
                                                           merge => { "[zeek][action]" => "[zeek_iso_cotp][pdu_type]" } } }

  if ([zeek_kerberos][request_type])            { mutate { id => "mutate_merge_normalize_zeek_kerberos_request_type"
                                                           merge => { "[zeek][action]" => "[zeek_kerberos][request_type]" } } }

  if ([zeek_ldap][operation])                   { mutate { id => "mutate_merge_normalize_zeek_ldap_operation"
                                                           merge => { "[zeek][action]" => "[zeek_ldap][operation]" } } }

  if ([zeek_modbus][func])                      { mutate { id => "mutate_merge_normalize_zeek_modbus_func"
                                                           merge => { "[zeek][action]" => "[zeek_modbus][func]" } } }

  if ([zeek_modbus_mask_write_register][func])  { mutate { id => "mutate_merge_normalize_zeek_modbus_mask_write_register_func"
                                                           merge => { "[zeek][action]" => "[zeek_modbus_mask_write_register][func]" } } }

  if ([zeek_modbus_read_write_multiple_registers][func])  { mutate { id => "mutate_merge_normalize_zeek_modbus_read_write_multiple_registers"
                                                            merge => { "[zeek][action]" => "[zeek_modbus_read_write_multiple_registers][func]" } } }

  if ([zeek_mqtt_connect][connect_status]) {
    # this log entry implicitly means "connect"
    mutate { id => "mutate_add_field_zeek_mqtt_connect_action"
             add_field => { "[@metadata][zeek_mqtt_connect_action]" => "Connect" } }
    mutate { id => "mutate_merge_zeek_mqtt_connect_action"
             merge => { "[zeek][action]" => "[@metadata][zeek_mqtt_connect_action]" } }
  }

  if ([zeek_mqtt_publish]) {
    if ([zeek_mqtt_publish][payload_dict][messageType]) {
      # not sure if this is a standard or just the PCAPs I found :/
      mutate { id => "mutate_merge_normalize_zeek_mqtt_publish_payload_dict_messageType"
      merge => { "[zeek][action]" => "[zeek_mqtt_publish][payload_dict][messageType]" } }
    } else {
      mutate { id => "mutate_add_field_zeek_mqtt_publish_action"
               add_field => { "[@metadata][zeek_mqtt_publish_action]" => "Publish" } }
      mutate { id => "mutate_merge_zeek_mqtt_publish_action"
               merge => { "[zeek][action]" => "[@metadata][zeek_mqtt_publish_action]" } }
    }
  }

  if ([zeek_mqtt_subscribe][action])            { mutate { id => "mutate_merge_normalize_zeek_mqtt_subscribe_action"
                                                           merge => { "[zeek][action]" => "[zeek_mqtt_subscribe][action]" } } }

  if ([zeek_mysql][cmd])                        { mutate { id => "mutate_merge_normalize_zeek_mysql_cmd"
                                                           merge => { "[zeek][action]" => "[zeek_mysql][cmd]" } } }

  if ([zeek_noise][msg_type])                   { mutate { id => "mutate_merge_normalize_zeek_noise_msg_type"
                                                           merge => { "[zeek][action]" => "[zeek_noise][msg_type]" } } }

  if ([zeek_ntlm][success]) {
    # this log entry implicitly means a login attempt
    mutate { id => "mutate_add_field_zeek_ntlm_action"
             add_field => { "[@metadata][zeek_ntlm_action]" => "Authenticate" } }
    mutate { id => "mutate_merge_zeek_ntlm_action"
             merge => { "[zeek][action]" => "[@metadata][zeek_ntlm_action]" } }
  }

  if ([zeek_ntp][mode_str])                     { mutate { id => "mutate_merge_normalize_zeek_ntp_mode_str"
                                                           merge => { "[zeek][action]" => "[zeek_ntp][mode_str]" } } }

  if ([zeek_profinet][operation_type])          { mutate { id => "mutate_merge_normalize_zeek_profinet_operation_type"
                                                           merge => { "[zeek][action]" => "[zeek_profinet][operation_type]" } } }

  if ([zeek_profinet_dce_rpc][operation])       { mutate { id => "mutate_merge_normalize_zeek_profinet_dce_rpc_operation"
                                                           merge => { "[zeek][action]" => "[zeek_profinet_dce_rpc][operation]" } } }

  if ([zeek_rfb][auth]) and ([zeek_rfb][authentication_method]) {
    # if authentication was attempted, assign an "authenticate" action
    mutate { id => "mutate_add_field_zeek_rfb_auth_action"
             add_field => { "[@metadata][zeek_rfb_auth_action]" => "Authenticate" } }
    mutate { id => "mutate_merge_zeek_rfb_auth_action"
             merge => { "[zeek][action]" => "[@metadata][zeek_rfb_auth_action]" } }
  }

  if ([zeek_s7comm]) {
    ruby {
      # action = rosctr:mode:type:sub
      id => "ruby_zeek_s7comm_generate_action"
      code => "
        actions = Array.new unless (actions = event.get('[zeek][action]'))
        actions.append([event.get('[zeek_s7comm][rosctr]'),
                        event.get('[zeek_s7comm][parameters][mode]'),
                        event.get('[zeek_s7comm][parameters][type]'),
                        event.get('[zeek_s7comm][parameters][sub]')].compact.join(':'))
        event.set('[zeek][action]', actions)"
    }
  }

  if ([zeek_sip][method]) { mutate { id => "mutate_merge_normalize_zeek_sip_method"
                                     merge => { "[zeek][action]" => "[zeek_sip][method]" } } }

  if ([zeek_smtp]) {
    # action depends on varios smtp headers' presence
    if ([zeek_smtp][last_reply]) {
      if ([zeek_smtp][msg_id]) {
        mutate { id => "mutate_add_field_zeek_smtp_action_deliver"
                 add_field => { "[@metadata][zeek_smtp_action]" => "Deliver message" } }
      } else if ([zeek_smtp][mailfrom]) {
        mutate { id => "mutate_add_field_zeek_smtp_action_queue"
                 add_field => { "[@metadata][zeek_smtp_action]" => "Queue message" } }
      } else {
        mutate { id => "mutate_add_field_zeek_smtp_action_connect_reply"
                 add_field => { "[@metadata][zeek_smtp_action]" => "Connect" } }
      }
    } else {
      mutate { id => "mutate_add_field_zeek_smtp_action_connect_no_reply"
               add_field => { "[@metadata][zeek_smtp_action]" => "Connect" } }
    }
    if ([@metadata][zeek_smtp_action]) {
      mutate { id => "mutate_merge_zeek_smtp_action"
               merge => { "[zeek][action]" => "[@metadata][zeek_smtp_action]" } }
    }
  }

  if ([zeek_socks]) {
    # socks action is "Authenticate" or "Connect" based on user/password or not
    if ([zeek_socks][user]) or ([zeek_socks][password]) {
      mutate { id => "mutate_add_field_zeek_socks_action_authenticate"
               add_field => { "[@metadata][zeek_socks_action]" => "Authenticate" } }
    } else {
      mutate { id => "mutate_add_field_zeek_socks_action_connect"
               add_field => { "[@metadata][zeek_socks_action]" => "Connect" } }
    }
    if ([@metadata][zeek_socks_action]) {
      mutate { id => "mutate_merge_zeek_socks_action"
               merge => { "[zeek][action]" => "[@metadata][zeek_socks_action]" } }
    }
  }

  if ([zeek_smb_cmd]) {
    ruby {
      # action = command:sub_command
      id => "ruby_zeek_smb_cmd_generate_action"
      code => "
        cmd = event.get('[zeek_smb_cmd][command]')
        subCmd = event.get('[zeek_smb_cmd][sub_command]')
        actions = Array.new unless (actions = event.get('[zeek][action]'))
        actions.append((cmd =~ /^\s*transaction\d*\s*$/i) ? subCmd : [cmd, subCmd].compact.join(':'))
        event.set('[zeek][action]', actions)"
    }
  }

  if ([zeek_smb_files][action])   { mutate { id => "mutate_merge_normalize_zeek_smb_files_action"
                                             merge => { "[zeek][action]" => "[zeek_smb_files][action]" } } }

  if ([zeek_smtp][method])         { mutate { id => "mutate_merge_normalize_zeek_smtp_method"
                                             merge => { "[zeek][action]" => "[zeek_smtp][method]" } } }

  if ([zeek_snmp]) {
    # action based on > 0 values for variou get/set PDUs
    if ([zeek_snmp][get_bulk_requests]) and ([zeek_snmp][get_bulk_requests] != "0") {
      mutate { id => "mutate_add_field_zeek_snmp_get_bulk_requests_action"
               add_field => { "[@metadata][snmp_get_bulk_requests_action]" => "GetBulkRequest" } }
      mutate { id => "mutate_merge_zeek_snmp_action_get_bulk_requests"
               merge => { "[zeek][action]" => "[@metadata][snmp_get_bulk_requests_action]" } }
    }
    if ([zeek_snmp][get_requests]) and ([zeek_snmp][get_requests] != "0") {
      mutate { id => "mutate_add_field_zeek_snmp_get_requests_action"
               add_field => { "[@metadata][snmp_get_requests_action]" => "GetRequest" } }
      mutate { id => "mutate_merge_zeek_snmp_action_get_requests"
               merge => { "[zeek][action]" => "[@metadata][snmp_get_requests_action]" } }
    }
    if ([zeek_snmp][get_responses]) and ([zeek_snmp][get_responses] != "0") {
      mutate { id => "mutate_add_field_zeek_snmp_get_responses_action"
               add_field => { "[@metadata][snmp_get_responses_action]" => "GetResponse" } }
      mutate { id => "mutate_merge_zeek_snmp_action_get_responses"
               merge => { "[zeek][action]" => "[@metadata][snmp_get_responses_action]" } }
    }
    if ([zeek_snmp][set_requests]) and ([zeek_snmp][set_requests] != "0") {
      mutate { id => "mutate_add_field_zeek_snmp_set_requests_action"
               add_field => { "[@metadata][snmp_set_requests_action]" => "SetRequest" } }
      mutate { id => "mutate_merge_zeek_snmp_action_set_requests"
               merge => { "[zeek][action]" => "[@metadata][snmp_set_requests_action]" } }
    }
  }

  if ([zeek_ssh]) {
    # ssh action is "Authenticate" or "Connect" based on auth_attempts
    if ([zeek_ssh][auth_attempts]) {
      mutate { id => "mutate_add_field_zeek_ssh_action_authenticate"
               add_field => { "[@metadata][zeek_ssh_action]" => "Authenticate" } }
    } else {
      mutate { id => "mutate_add_field_zeek_ssh_action_connect"
               add_field => { "[@metadata][zeek_ssh_action]" => "Connect" } }
    }
    if ([@metadata][zeek_ssh_action]) {
      mutate { id => "mutate_merge_zeek_ssh_action"
               merge => { "[zeek][action]" => "[@metadata][zeek_ssh_action]" } }
    }
  }

  if ([zeek_ssl]) {
    # SSL action will be either "connect", "validate", "resume"
    if ([zeek_ssl][resumed] == "T") {
      mutate { id => "mutate_add_field_zeek_ssl_resume"
               add_field => { "[@metadata][zeek_ssl_action]" => "Resume" } }
    } else if ([zeek_ssl][established] != "T") and ([zeek_ssl][validation_status]) and ([zeek_ssl][validation_status] != "ok") {
      mutate { id => "mutate_add_field_zeek_ssl_validate"
               add_field => { "[@metadata][zeek_ssl_action]" => "Validate Certificate" } }
    } else {
      mutate { id => "mutate_add_field_zeek_ssl_connect"
               add_field => { "[@metadata][zeek_ssl_action]" => "Connect" } }
    }
    mutate { id => "mutate_merge_zeek_ssl_action"
             merge => { "[zeek][action]" => "[@metadata][zeek_ssl_action]" } }
  }

  if ([zeek_tds][command]) { mutate { id => "mutate_merge_normalize_zeek_tds_command"
                             merge => { "[zeek][action]" => "[zeek_tds][command]" } } }

  if ([zeek_tds_rpc][procedure_name]) {
    mutate { id => "mutate_add_field_zeek_tds_rpc_procedure_name_tmp"
             add_field => { "[@metadata][zeek_tds_rpc_procedure_name_tmp]" => "%{[zeek_tds_rpc][procedure_name]}" } }

    # remove everything after the first $
    mutate { id => "mutate_gsub_field_zeek_tds_rpc_procedure_name_tmp"
             gsub => [ "[@metadata][zeek_tds_rpc_procedure_name_tmp]", "\$.*", "" ] }

    mutate { id => "mutate_merge_normalize_zeek_tds_rpc_procedure_name"
             merge => { "[zeek][action]" => "[@metadata][zeek_tds_rpc_procedure_name_tmp]" } }
  }

  if ([zeek_tunnel][action])  { mutate { id => "mutate_merge_normalize_zeek_tunnel_action"
                                         merge => { "[zeek][action]" => "[zeek_tunnel][action]" } } }

  # Result ############################################################################################################
  # collect all result/status/response/errors under the parent [zeek][result] array

  if ([zeek_bacnet]) {
    if ([zeek_bacnet][result_code]) {
      mutate { id => "mutate_merge_normalize_zeek_bacnet_result_code"
      merge => { "[zeek][result]" => "[zeek_bacnet][result_code]" } }
    } else if ([zeek_bacnet][pdu_service]) {
      mutate { id => "mutate_add_field_zeek_bacnet_success"
               add_field => { "[@metadata][zeek_bacnet_result]" => "Success" } }
      mutate { id => "mutate_merge_field_zeek_bacnet_success"
               merge => { "[zeek][result]" => "[@metadata][zeek_bacnet_result]" } }
    }
  }

  if ([zeek_cip][cip_status]) { mutate { id => "mutate_merge_normalize_zeek_cip_status_result"
                                         merge => { "[zeek][result]" => "[zeek_cip][cip_status]" } } }

  if ([zeek_dhcp]) {
    # dhcp server_message and client_message populate result, as do ACK and NAK message types
    if ([zeek_dhcp][server_message])  { mutate { id => "mutate_merge_normalize_zeek_dhcp_server_message"
                                                 merge => { "[zeek][result]" => "[zeek_dhcp][server_message]" } } }
    if ([zeek_dhcp][client_message])  { mutate { id => "mutate_merge_normalize_zeek_dhcp_client_message"
                                                 merge => { "[zeek][result]" => "[zeek_dhcp][client_message]" } } }
    if ("ACK" in [zeek_dhcp][msg_types]) {
      mutate { id => "mutate_add_field_zeek_dhcp_ack_result"
               add_field => { "[@metadata][zeek_dhcp_result]" => "Success" } }
    } else if ("NAK" in [zeek_dhcp][msg_types]) {
      mutate { id => "mutate_add_field_zeek_dhcp_nak_result"
               add_field => { "[@metadata][zeek_dhcp_result]" => "Failure" } }
    }
    if ([@metadata][zeek_dhcp_result]) {
      mutate { id => "mutate_merge_zeek_dhcp_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_dhcp_result]" } }
    }
  }

  # dnp3: fc_reply and iin_flags
  if ([zeek_dnp3][fc_reply])  { mutate { id => "mutate_merge_zeek_dnp3_fc_reply"
                                         merge => { "[zeek][result]" => "[zeek_dnp3][fc_reply]" } } }
  if ([zeek_dnp3][iin_flags]) { mutate { id => "mutate_merge_zeek_dnp3_iin_flags"
                                         merge => { "[zeek][result]" => "[zeek_dnp3][iin_flags]" } } }

  # dnp3_control.status_code
  if ([zeek_dnp3_control][status_code]) { mutate { id => "mutate_merge_zeek_dnp3_control_status_code"
                                                   merge => { "[zeek][result]" => "[zeek_dnp3_control][status_code]" } } }

  if ([zeek_dns]) {
    # DNS result is populated by rcode_name (with NOERROR being translated to Success), and rejected
    if ([zeek_dns][rcode_name]) {
      if ([zeek_dns][rcode_name] == 'NOERROR') {
        mutate { id => "mutate_add_field_zeek_dns_noerror"
                 add_field => { "[@metadata][zeek_dns_result]" => "Success" } }
        mutate { id => "mutate_merge_field_zeek_dns_noerror"
                 merge => { "[zeek][result]" => "[@metadata][zeek_dns_result]" } }
      } else {
        mutate { id => "mutate_merge_normalize_zeek_dns_rcode_name"
                 merge => { "[zeek][result]" => "[zeek_dns][rcode_name]" } }
      }
    }
    if ([zeek_dns][rejected] == 'T') {
      mutate { id => "mutate_add_field_zeek_dns_rejected"
               add_field => { "[@metadata][zeek_dns_rejected_result]" => "Rejected" } }
      mutate { id => "mutate_merge_field_zeek_dns_rejected"
               merge => { "[zeek][result]" => "[@metadata][zeek_dns_rejected_result]" } }
    }
  }

  # zeek_enip.enip_status
  if ([zeek_enip][enip_status])         { mutate { id => "mutate_merge_normalize_zeek_enip_enip_status"
                                                   merge => { "[zeek][result]" => "[zeek_enip][enip_status]" } } }

  if ([zeek_ftp][reply_code]) {
    # normalized version of reply code (reply_msg is too unpredictable)
    translate {
      id => "translate_zeek_ftp_reply_code"
      field => "[zeek_ftp][reply_code]"
      destination => "[@metadata][zeek_ftp_mapped_result]"
      dictionary_path => "/etc/ftp_result_codes.yaml"
    }
    if ([@metadata][zeek_ftp_mapped_result]) {
      mutate { id => "mutate_merge_zeek_ftp_mapped_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_ftp_mapped_result]" } }
    } else if ([zeek_ftp][reply_msg]) {
      mutate { id => "mutate_merge_zeek_ftp_reply_msg_result"
               merge => { "[zeek][result]" => "[zeek_ftp][reply_msg]" } }
    } else {
      mutate { id => "mutate_merge_zeek_ftp_reply_code_result"
               merge => { "[zeek][result]" => "[zeek_ftp][reply_code]" } }
    }
  }

  if ([zeek_http][status_code]) {
    # normalized version of http reply code (status_msg is too unpredictable)
    translate {
      id => "translate_zeek_http_reply_code"
      field => "[zeek_http][status_code]"
      destination => "[@metadata][zeek_http_mapped_result]"
      dictionary_path => "/etc/http_result_codes.yaml"
    }
    if ([@metadata][zeek_http_mapped_result]) {
      mutate { id => "mutate_merge_zeek_http_mapped_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_http_mapped_result]" } }
    } else if ([zeek_http][status_msg]) {
      mutate { id => "mutate_merge_zeek_http_status_msg_result"
               merge => { "[zeek][result]" => "[zeek_http][status_msg]" } }
    } else {
      mutate { id => "mutate_merge_zeek_http_status_code_result"
               merge => { "[zeek][result]" => "[zeek_http][status_code]" } }
    }
  }

  if ([zeek_kerberos]) {
    # result populated from success and error_msg
    if ([zeek_kerberos][success] == 'T') {
      mutate { id => "mutate_add_field_zeek_zeek_kerberos_success"
               add_field => { "[@metadata][zeek_kerberos_result]" => "Success" } }
    } else if ([zeek_kerberos][error_msg]) {
      mutate { id => "mutate_add_field_zeek_zeek_kerberos_error_msg"
               add_field => { "[@metadata][zeek_kerberos_result]" => "%{[zeek_kerberos][error_msg]}" } }
    } else {
      mutate { id => "mutate_add_field_zeek_zeek_kerberos_failure"
               add_field => { "[@metadata][zeek_kerberos_result]" => "Failure" } }
    }
    mutate { id => "mutate_merge_zeek_kerberos_result"
             merge => { "[zeek][result]" => "[@metadata][zeek_kerberos_result]" } }
  }

  if ([zeek_ldap][result_code]) {
    # normalized version of ldap result code
    translate {
      id => "translate_zeek_ldap_result_code"
      field => "[zeek_ldap][result_code]"
      destination => "[@metadata][zeek_ldap_mapped_result]"
      dictionary_path => "/etc/ldap_result_codes.yaml"
      fallback => "%{[zeek_ldap][result_code]}"
    }
    if ([@metadata][zeek_ldap_mapped_result]) {
      mutate { id => "mutate_merge_zeek_ldap_mapped_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_ldap_mapped_result]" } }
    }
  }

  if ([zeek_modbus]) {
    # result comes from exception, but if exception is missing and we have a func, then assume success
    if ([zeek_modbus][exception]) {
      mutate { id => "mutate_merge_normalize_zeek_modbus_exception"
      merge => { "[zeek][result]" => "[zeek_modbus][exception]" } }
    } else if ([zeek_modbus][func]) {
      mutate { id => "mutate_add_field_zeek_modbus_success"
               add_field => { "[@metadata][zeek_modbus_result]" => "Success" } }
      mutate { id => "mutate_merge_field_zeek_modbus_success"
               merge => { "[zeek][result]" => "[@metadata][zeek_modbus_result]" } }
    }
  }

  # result for zeek_mqtt_connect: connect_status.'Connection Accepted' -> 'Success', else connect_status
  if ([zeek_mqtt_connect][connect_status] == 'Connection Accepted') {
    mutate { id => "mutate_add_field_zeek_mqtt_connect_success"
             add_field => { "[@metadata][zeek_mqtt_connect_success]" => "Success" } }
    mutate { id => "mutate_merge_field_zeek_mqtt_connect_success"
             merge => { "[zeek][result]" => "[@metadata][zeek_mqtt_connect_success]" } }
  } else if ([zeek_mqtt_connect][connect_status]) {
    mutate { id => "mutate_merge_zeek_mqtt_connect_connect_status"
             merge => { "[zeek][result]" => "[zeek_mqtt_connect][connect_status]" } }
  }

  # result for zeek_mqtt_publish: status.'ok' -> 'Success', else status
  if ([zeek_mqtt_publish][status] == 'ok') {
    mutate { id => "mutate_add_field_zeek_mqtt_publish_success"
             add_field => { "[@metadata][zeek_mqtt_publish_success]" => "Success" } }
    mutate { id => "mutate_merge_field_zeek_mqtt_publish_success"
             merge => { "[zeek][result]" => "[@metadata][zeek_mqtt_publish_success]" } }
  } else if ([zeek_mqtt_publish][status]) {
    mutate { id => "mutate_merge_zeek_mqtt_publish_publish_status"
             merge => { "[zeek][result]" => "[zeek_mqtt_publish][status]" } }
  }

  # zeek_mqtt_subscribe.ack.'T' -> 'Acknowledged'
  if ([zeek_mqtt_subscribe][ack] == 'T') {
    mutate { id => "mutate_add_field_zeek_mqtt_subscribe_ack"
             add_field => { "[@metadata][zeek_mqtt_subscribe_acknowledged]" => "Acknowledged" } }
    mutate { id => "mutate_merge_field_zeek_mqtt_subscribe_ack"
             merge => { "[zeek][result]" => "[@metadata][zeek_mqtt_subscribe_acknowledged]" } }
  }

  if ([zeek_mysql]) {
    # mysql result comes from success and response
    if ([zeek_mysql][success] == "T") {
      mutate { id => "mutate_add_field_zeek_mysql_success"
               add_field => { "[@metadata][zeek_mysql_result]" => "Success" } }
    } else if ([zeek_mysql][response] =~ /^Access denied/) {
      mutate { id => "mutate_add_field_zeek_mysql_access"
               add_field => { "[@metadata][zeek_mysql_result]" => "Access denied" } }
    } else {
      mutate { id => "mutate_add_field_zeek_mysql_failure"
               add_field => { "[@metadata][zeek_mysql_result]" => "Failure" } }
    }
    mutate { id => "mutate_merge_zeek_mysql_result"
             merge => { "[zeek][result]" => "[@metadata][zeek_mysql_result]" } }
  }

  if ([zeek_ntlm]) {
    # ntlm result comes from .success
    if ([zeek_ntlm][success] == "T") {
      mutate { id => "mutate_add_field_zeek_ntlm_success"
               add_field => { "[@metadata][zeek_ntlm_result]" => "Success" } }
    } else {
      mutate { id => "mutate_add_field_zeek_ntlm_failure"
               add_field => { "[@metadata][zeek_ntlm_result]" => "Failure" } }
    }
    mutate { id => "mutate_merge_zeek_ntlm_result"
             merge => { "[zeek][result]" => "[@metadata][zeek_ntlm_result]" } }
  }

  if ([zeek_radius][result]) {
    if ([zeek_radius][result] =~ /^(?i)succ/) {
      mutate { id => "mutate_add_field_zeek_radius_success"
               add_field => { "[@metadata][zeek_radius_result]" => "Success" } }
    } else if ([zeek_radius][result] =~ /^(?i)fail/) {
      mutate { id => "mutate_add_field_zeek_radius_failure"
               add_field => { "[@metadata][zeek_radius_result]" => "Failure" } }
    } else {
      mutate { id => "mutate_add_field_zeek_radius_result_fallback"
               add_field => { "[@metadata][zeek_radius_result]" => "%{[zeek_radius][result]}" } }
    }
    mutate { id => "mutate_merge_zeek_radius_result"
             merge => { "[zeek][result]" => "[@metadata][zeek_radius_result]" } }
    # if authentication was attempted, also assign an "authenticate" action
    mutate { id => "mutate_add_field_zeek_radius_auth_action"
             add_field => { "[@metadata][zeek_radius_auth_action]" => "Authenticate" } }
    mutate { id => "mutate_merge_zeek_radius_auth_action"
             merge => { "[zeek][action]" => "[@metadata][zeek_radius_auth_action]" } }
  }

  if ([zeek_rdp][result]) { mutate { id => "mutate_merge_normalize_zeek_rdp_result"
                                            merge => { "[zeek][result]" => "[zeek_rdp][result]" } } }

  if ([zeek_s7comm][parameters][code]) {
    # reference: https://github.com/wireshark/wireshark/blob/master/epan/dissectors/packet-s7comm.c
    translate {
      id => "translate_zeek_s7comm_parameters_code"
      field => "[zeek_s7comm][parameters][code]"
      destination => "[@metadata][zeek_s7comm_mapped_result]"
      dictionary_path => "/etc/s7comm_result_codes.yaml"
      fallback => "%{[zeek_s7comm][parameters][code]}"
    }
    if ([@metadata][zeek_s7comm_mapped_result]) {
      mutate { id => "mutate_merge_zeek_s7comm_mapped_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_s7comm_mapped_result]" } }
    }
  }

  if ([zeek_sip][status_code]) {
    # normalized version of sip reply code (status_msg may be unpredictable)
    translate {
      id => "translate_zeek_sip_reply_code"
      field => "[zeek_sip][status_code]"
      destination => "[@metadata][zeek_sip_mapped_result]"
      dictionary_path => "/etc/sip_result_codes.yaml"
    }
    if ([@metadata][zeek_sip_mapped_result]) {
      mutate { id => "mutate_merge_zeek_sip_mapped_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_sip_mapped_result]" } }
    } else if ([zeek_sip][status_msg]) {
      mutate { id => "mutate_merge_zeek_sip_status_msg_result"
               merge => { "[zeek][result]" => "[zeek_sip][status_msg]" } }
    } else {
      mutate { id => "mutate_merge_zeek_sip_status_code_result"
               merge => { "[zeek][result]" => "[zeek_sip][status_code]" } }
    }
  }

  if ([zeek_smb_cmd][status]) {
    # zeek_smb_cmd.status (SUCCESS, NO_SUCH_FILE, ACCESS_DENIED, OBJECT_NAME_COLLISION, etc.)
    translate {
      id => "translate_zeek_smb_cmd_status"
      field => "[zeek_smb_cmd][status]"
      destination => "[@metadata][zeek_smb_cmd_mapped_result]"
      dictionary => {
        "SUCCESS" => "Success"
        # TODO... normalize other codes? or maybe just case-normalize and remove underscores/dashes?
        # e.g., "ACCESS_DENIED".split(/[_-]/).collect(&:capitalize).join(' ')
      }
      fallback => "%{[zeek_smb_cmd][status]}"
    }
    if ([@metadata][zeek_smb_cmd_mapped_result]) {
      mutate { id => "mutate_merge_zeek_smb_cmd_mapped_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_smb_cmd_mapped_result]" } }
    }
  }

  if ([zeek_smtp]) {
    if ([zeek_smtp][last_reply_code]) {
      # normalized version of smtp reply code (last_reply may be unpredictable)
      translate {
        id => "translate_zeek_smtp_last_reply_code"
        field => "[zeek_smtp][last_reply_code]"
        destination => "[@metadata][zeek_smtp_mapped_result]"
        dictionary_path => "/etc/smtp_result_codes.yaml"
      }
    }
    if ([@metadata][zeek_smtp_mapped_result]) {
      mutate { id => "mutate_merge_zeek_smtp_mapped_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_smtp_mapped_result]" } }
    } else if ([zeek_smtp][last_reply]) {
      mutate { id => "mutate_merge_zeek_smtp_last_reply_result"
               merge => { "[zeek][result]" => "[zeek_smtp][last_reply]" } }
    }
  }

  if ([zeek_socks][server_status]) {
    translate {
      id => "translate_zeek_socks_server_status"
      field => "[zeek_socks][server_status]"
      destination => "[@metadata][zeek_socks_mapped_result]"
      dictionary => {
        "succeeded" => "Success"
        # TODO... normalize other codes (figure out what they are)
      }
    }
    if ([@metadata][zeek_socks_mapped_result]) {
      mutate { id => "mutate_merge_zeek_socks_mapped_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_socks_mapped_result]" } }
    } else if ([zeek_socks][server_status]) {
      mutate { id => "mutate_merge_zeek_socks_server_status_result"
               merge => { "[zeek][result]" => "[zeek_socks][server_status]" } }
    }
  }

  if ([zeek_ssh][auth_success]) {
    translate {
      id => "translate_zeek_ssh_auth_success"
      field => "[zeek_ssh][auth_success]"
      destination => "[@metadata][zeek_ssh_mapped_result]"
      dictionary => {
        "T" => "Success"
        "F" => "Failure"
      }
    }
    if ([@metadata][zeek_ssh_mapped_result]) {
      mutate { id => "mutate_merge_zeek_ssh_mapped_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_ssh_mapped_result]" } }
    }
  }

  if ([zeek_ssl]) {
    if ([zeek_ssl][established] == "T") {
      mutate { id => "mutate_add_field_zeek_ssl_result_success"
               add_field => { "[@metadata][zeek_ssl_mapped_success_result]" => "Success" } }
    } else if (![zeek_ssl][last_alert]) {
      mutate { id => "mutate_add_field_zeek_ssl_result_failure"
               add_field => { "[@metadata][zeek_ssl_mapped_success_result]" => "Failure" } }
    }
    if ([@metadata][zeek_ssl_mapped_success_result]) {
      mutate { id => "mutate_merge_zeek_ssl_mapped_success_result"
               merge => { "[zeek][result]" => "[@metadata][zeek_ssl_mapped_success_result]" } }
    }
    if ([zeek_ssl][last_alert]) {
      mutate { id => "mutate_merge_field_zeek_ssl_result_last_alert"
               merge => { "[zeek][result]" => "[zeek_ssl][last_alert]" } }
    }
    if ([zeek_ssl][validation_status]) and ([zeek_ssl][validation_status] != 'ok') {
      mutate { id => "mutate_merge_field_zeek_ssl_result_validation_status"
               merge => { "[zeek][result]" => "[zeek_ssl][validation_status]" } }
    }
  }

  #####################################################################################################################
  # remove any duplicates from action and result
  if ([zeek][action]) {
    ruby {
      id => "ruby_zeek_action_uniq"
      code => "event.set('[zeek][action]', event.get('[zeek][action]').uniq)"
    }
  }

  if ([zeek][result]) {
    ruby {
      id => "ruby_zeek_result_uniq"
      code => "event.set('[zeek][result]', event.get('[zeek][result]').uniq)"
    }
  }

  # FUIDs #############################################################################################################
  # collect all other FUIDs under parent [zeek][fuid] array (some were already done at the root level in
  # the "rename" in 11_zeek_logs.conf)

  if ([zeek_files][parent_fuid])                { mutate { id => "mutate_merge_normalize_zeek_files_parent_fuid"
                                                           merge => { "[zeek][fuid]" => "[zeek_files][parent_fuid]" } } }

  if ([zeek_http][orig_fuids])                  { mutate { id => "mutate_merge_normalize_zeek_http_orig_fuids"
                                                           merge => { "[zeek][fuid]" => "[zeek_http][orig_fuids]" } } }

  if ([zeek_http][resp_fuids])                  { mutate { id => "mutate_merge_normalize_zeek_http_resp_fuids"
                                                           merge => { "[zeek][fuid]" => "[zeek_http][resp_fuids]" } } }

  if ([zeek_kerberos][client_cert_fuid])        { mutate { id => "mutate_merge_normalize_zeek_kerberos_client_cert_fuid"
                                                           merge => { "[zeek][fuid]" => "[zeek_kerberos][client_cert_fuid]" } } }

  if ([zeek_kerberos][server_cert_fuid])        { mutate { id => "mutate_merge_normalize_zeek_kerberos_server_cert_fuid"
                                                           merge => { "[zeek][fuid]" => "[zeek_kerberos][server_cert_fuid]" } } }

  if ([zeek_ssl][cert_chain_fuids])             { mutate { id => "mutate_merge_normalize_zeek_ssl_cert_chain_fuids"
                                                           merge => { "[zeek][fuid]" => "[zeek_ssl][cert_chain_fuids]" } } }

  if ([zeek_ssl][client_cert_chain_fuids])      { mutate { id => "mutate_merge_normalize_zeek_ssl_client_cert_chain_fuids"
                                                           merge => { "[zeek][fuid]" => "[zeek_ssl][client_cert_chain_fuids]" } } }

  if ([zeek][fuid]) {
    ruby {
      id => "ruby_zeek_fuid_uniq"
      code => "event.set('[zeek][fuid]', event.get('[zeek][fuid]').uniq)"
    }
  }

  # File/MIME types ###################################################################################################
  # collect all file/MIME types under the parent [zeek][filetype] array

  if ([zeek_files][mime_type])                  { mutate { id => "mutate_merge_normalize_zeek_files_mime_type"
                                                           merge => { "[zeek][filetype]" => "[zeek_files][mime_type]" } } }

  if ([zeek_ftp][mime_type])                    { mutate { id => "mutate_merge_normalize_zeek_ftp_mime_type"
                                                           merge => { "[zeek][filetype]" => "[zeek_ftp][mime_type]" } } }

  if ([zeek_http][orig_mime_types])             { mutate { id => "mutate_merge_normalize_zeek_http_orig_mime_types"
                                                           merge => { "[zeek][filetype]" => "[zeek_http][orig_mime_types]" } } }

  if ([zeek_http][resp_mime_types])             { mutate { id => "mutate_merge_normalize_zeek_http_resp_mime_types"
                                                           merge => { "[zeek][filetype]" => "[zeek_http][resp_mime_types]" } } }

  if ([zeek_irc][dcc_mime_type])                { mutate { id => "mutate_merge_normalize_zeek_irc_dcc_mime_type"
                                                           merge => { "[zeek][filetype]" => "[zeek_irc][dcc_mime_type]" } } }

  if ([zeek_intel][file_mime_type])             { mutate { id => "mutate_merge_normalize_zeek_intel_file_mime_type"
                                                           merge => { "[zeek][filetype]" => "[zeek_intel][file_mime_type]" } } }

  if ([zeek_notice][file_mime_type])            { mutate { id => "mutate_merge_normalize_zeek_notice_file_mime_type"
                                                           merge => { "[zeek][filetype]" => "[zeek_notice][file_mime_type]" } } }

  if ([zeek_sip][content_type])                 { mutate { id => "mutate_merge_normalize_zeek_sip_content_type"
                                                           merge => { "[zeek][filetype]" => "[zeek_sip][content_type]" } } }

  if ([zeek][filetype]) {
    ruby {
      id => "ruby_zeek_filetype_uniq"
      code => "event.set('[zeek][filetype]', event.get('[zeek][filetype]').uniq)"
    }
  }

  # Filenames #########################################################################################################
  # collect all filenames under the parent [zeek][filename] array

  if ([zeek_files][filename])                   { mutate { id => "mutate_merge_normalize_zeek_files_filename"
                                                           merge => { "[zeek][filename]" => "[zeek_files][filename]" } } }

  if ([zeek_http][orig_filenames])              { mutate { id => "mutate_merge_normalize_zeek_http_orig_filenames"
                                                           merge => { "[zeek][filename]" => "[zeek_http][orig_filenames]" } } }

  if ([zeek_http][resp_filenames])              { mutate { id => "mutate_merge_normalize_zeek_http_resp_filenames"
                                                           merge => { "[zeek][filename]" => "[zeek_http][resp_filenames]" } } }

  if ([zeek_irc][dcc_file_name])                { mutate { id => "mutate_merge_normalize_zeek_irc_dcc_file_name"
                                                           merge => { "[zeek][filename]" => "[zeek_irc][dcc_file_name]" } } }

  if ([zeek_smb_files][name])                   { mutate { id => "mutate_merge_normalize_zeek_smb_files_name"
                                                           merge => { "[zeek][filename]" => "[zeek_smb_files][name]" } } }

  if ([zeek_smb_files][prev_name])              { mutate { id => "mutate_merge_normalize_zeek_smb_files_prev_name"
                                                           merge => { "[zeek][filename]" => "[zeek_smb_files][prev_name]" } } }

  if ([zeek][filename]) {
    ruby {
      id => "ruby_zeek_filename_uniq"
      code => "event.set('[zeek][filename]', event.get('[zeek][filename]').uniq)"
    }
  }

}